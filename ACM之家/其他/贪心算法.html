<div class="c-top2" id="post-55">
<div class="datetime">2014<br/>01-03</div>
<div class="tit"><h1 class="entry-title">贪心算法</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/zhuanti/algorithm" rel="category tag" title="查看算法分析中的全部文章">算法分析</a></span><span class="i4">围观2313次</span><span class="i3"><a class="ds-thread-count" data-thread-key="3378" href="http://www.acmerblog.com/greed-algorithm-3378.html#comments" title="《贪心算法》上的评论">16 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<h1 class="p0" style="text-align: center;">贪心算法</h1>
<p class="p0">顾名思义，贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的<span style="color: #ff0000;">局部最优</span>选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p>
<h2 class="p0">问题一、活动安排问题</h2>
<p class="p0"><strong>问题表述</strong>：设有<span style="font-family: 'Courier New';">n</span><span style="font-family: 宋体;">个活动的集合</span><span style="font-family: 'Courier New';">E = {1,2,</span>…,n}<span style="font-family: 宋体;">，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">都有一个要求使用该资源的起始时间</span><span style="font-family: 'Courier New';">si</span><span style="font-family: 宋体;">和一个结束时间</span><span style="font-family: 'Courier New';">fi,</span><span style="font-family: 宋体;">且</span><span style="font-family: 'Courier New';">si &lt; fi </span><span style="font-family: 宋体;">。如果选择了活动</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">，则它在半开时间区间</span><span style="font-family: 'Courier New';">[si, fi)</span><span style="font-family: 宋体;">内占用资源。若区间</span><span style="font-family: 'Courier New';">[si, fi)</span><span style="font-family: 宋体;">与区间</span><span style="font-family: 'Courier New';">[sj, fj)</span><span style="font-family: 宋体;">不相交，则称活动</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">与活动</span><span style="font-family: 'Courier New';">j</span><span style="font-family: 宋体;">是相容的。也就是说，当</span><span style="font-family: 'Courier New';">si &gt;= fj</span><span style="font-family: 宋体;">或</span><span style="font-family: 'Courier New';">sj &gt;= fi</span><span style="font-family: 宋体;">时，活动</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">与活动</span><span style="font-family: 'Courier New';">j</span><span style="font-family: 宋体;">相容。</span></p>
<p class="p0">由于输入的活动以其完成时间的非减序排列，所以算法<span style="font-family: 'Courier New';">greedySelector</span><span style="font-family: 宋体;">每次总是选择具有最早完成时间的相容活动加入集合</span><span style="font-family: 'Courier New';">A</span><span style="font-family: 宋体;">中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。</span></p>
<p class="p0">算法<span style="font-family: 'Courier New';">greedySelector</span><span style="font-family: 宋体;">的效率极高。当输入的活动已按结束时间的非减序排列，算法只需</span><span style="font-family: 'Courier New';">O(n)</span><span style="font-family: 宋体;">的时间安排</span><span style="font-family: 'Courier New';">n</span><span style="font-family: 宋体;">个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用</span><span style="font-family: 'Courier New';">O(nlogn)</span><span style="font-family: 宋体;">的时间重排。</span></p>
<p class="p0">例：设待安排的<span style="font-family: 'Courier New';">11</span><span style="font-family: 宋体;">个活动的开始时间和结束时间按结束时间的非减序排列如下：</span></p>
<p class="p0"><span style="font-family: 宋体;"><img alt="" class="cnblogs_code" height="150" src="http://cdn.acmerblog.com/img/1388749259287.jpg" width="622"/><br/></span></p>
<p class="p0">算法<span style="font-family: 'Courier New';">greedySelector </span><span style="font-family: 宋体;">的计算过程如下图所示。图中每行相应于算法的一次迭代。阴影长条表示的活动是已选入集合</span><span style="font-family: 'Courier New';">A</span><span style="font-family: 宋体;">的活动，而空白长条表示的活动是当前正在检查相容性的活动。</span></p>
<p class="p0"><span style="font-family: 宋体;"><img alt="" height="400" src="http://cdn.acmerblog.com/img/1388749259500.jpg" width="343"/><br/></span></p>
<p class="p0">若被检查的活动<span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">的开始时间</span><span style="font-family: 'Courier New';">Si</span><span style="font-family: 宋体;">小于最近选择的活动</span><span style="font-family: 'Courier New';">j</span><span style="font-family: 宋体;">的结束时间</span><span style="font-family: 'Courier New';">fi</span><span style="font-family: 宋体;">，则不选择活动</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">，否则选择活动</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">加入集合</span><span style="font-family: 'Courier New';">A</span><span style="font-family: 宋体;">中。 </span></p>
<p class="p0">贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，贪心算法<span style="font-family: 'Courier New';">greedySelector</span><span style="font-family: 宋体;">却总能求得的整体最优解，即它最终所确定的相容活动集合</span><span style="font-family: 'Courier New';">A</span><span style="font-family: 宋体;">的规模最大。这个结论可以用数学归纳法证明。</span></p>
<p class="p0"><span style="font-family: 宋体;">活动安排问题实现：</span></p>
<p class="p0"><span style="font-family: 宋体;"> </span></p>
<pre class="brush:cpp ">/* 主题：活动安排问题
* 作者：chinazhangjie
* 邮箱：chinajiezhang@gmail.com
* 开发语言：C++
* 开发环境：Vicrosoft Visual Studio
* 时间: 2010.11.21
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std ;

struct ActivityTime
{
public:
    ActivityTime (int nStart, int nEnd) 
        : m_nStart (nStart), m_nEnd (nEnd) 
    { }
    ActivityTime ()
        : m_nStart (0), m_nEnd (0)
    { }
    friend 
    bool operator &lt; (const ActivityTime&amp; lth, const ActivityTime&amp; rth) 
    {
        return lth.m_nEnd &lt; lth.m_nEnd ;
    }
public:
    int m_nStart ;
    int m_nEnd ;
} ;

class ActivityArrange 
{
public:
    ActivityArrange (const vector&lt;ActivityTime&gt;&amp; vTimeList) 
    {
        m_vTimeList = vTimeList ;
        m_nCount = vTimeList.size () ;
        m_bvSelectFlag.resize (m_nCount, false) ;
    }
    // 活动安排
    void greedySelector () 
    {
        __sortTime () ;
        // 第一个活动一定入内
        m_bvSelectFlag[0] = true ;    
        int j = 0 ;
        for (int i = 1; i &lt; m_nCount ; ++ i) {
            if (m_vTimeList[i].m_nStart &gt; m_vTimeList[j].m_nEnd) {
                m_bvSelectFlag[i] = true ;
                j = i ;
            }
        }
        
        copy (m_bvSelectFlag.begin(), m_bvSelectFlag.end() ,ostream_iterator&lt;bool&gt; (cout, ” “));
        cout &lt;&lt; endl ;
    }

private:
    // 按照活动结束时间非递减排序
    void __sortTime () 
    {
        sort (m_vTimeList.begin(), m_vTimeList.end()) ;
        for (vector&lt;ActivityTime&gt;::iterator ite = m_vTimeList.begin() ;
                ite != m_vTimeList.end() ; 
                ++ ite) {
            cout &lt;&lt; ite-&gt;m_nStart &lt;&lt; “, “&lt;&lt; ite -&gt;m_nEnd &lt;&lt; endl ;
        }
    }

private:
    vector&lt;ActivityTime&gt;    m_vTimeList ;    // 活动时间安排列表
    vector&lt;bool&gt;            m_bvSelectFlag ;// 是否安排活动标志
    int    m_nCount ;    // 总活动个数
} ;

int main()
{
    vector&lt;ActivityTime&gt; vActiTimeList ;
    vActiTimeList.push_back (ActivityTime(1, 4)) ;
    vActiTimeList.push_back (ActivityTime(3, 5)) ;
    vActiTimeList.push_back (ActivityTime(0, 6)) ;
    vActiTimeList.push_back (ActivityTime(5, 7)) ;
    vActiTimeList.push_back (ActivityTime(3, 8)) ;
    vActiTimeList.push_back (ActivityTime(5, 9)) ;
    vActiTimeList.push_back (ActivityTime(6, 10)) ;
    vActiTimeList.push_back (ActivityTime(8, 11)) ;
    vActiTimeList.push_back (ActivityTime(8, 12)) ;
    vActiTimeList.push_back (ActivityTime(2, 13)) ;
    vActiTimeList.push_back (ActivityTime(12, 14)) ;

    ActivityArrange aa (vActiTimeList) ;
    aa.greedySelector () ;
    return 0 ;
}</pre>
<p> </p>
<h2 class="p0">贪心算法的基本要素</h2>
<p class="p0">对于一个具体的问题，怎么知道是否可用贪心算法解此问题，以及能否得到问题的最优解呢<span style="font-family: 'Courier New';">?</span><span style="font-family: 宋体;">这个问题很难给予肯定的回答。</span></p>
<p class="p0">但是，从许多可以用贪心算法求解的问题中看到这类问题一般具有<span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">个重要的性质：贪心选择性质和最优子结构性质。</span></p>
<h3 class="p0">1、贪心选择性质</h3>
<p class="p0">所谓贪心选择性质是指所求问题的<span style="color: #ff0000;">整体最优解可以通过一系列局部最优的选择</span>，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p>
<p class="p0">动态规划算法通常以<span style="color: #ff0000;">自底向上</span>的方式解各子问题，而贪心算法则通常以<span style="color: #ff0000;">自顶向下</span>的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。 </p>
<p class="p0">对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p>
<h3 class="p0">2、最优子结构性质</h3>
<p class="p0">当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。 </p>
<h3 class="p0">3、贪心算法与动态规划算法的差异</h3>
<p class="p0">贪心算法和动态规划算法都要求问题具有最优子结构性质，这是<span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">类算法的一个共同点。但是，对于具有最优子结构的问题应该选用贪心算法还是动态规划算法求解</span><span style="font-family: 'Courier New';">?</span><span style="font-family: 宋体;">是否能用动态规划算法求解的问题也能用贪心算法求解</span><span style="font-family: 'Courier New';">?</span><span style="font-family: 宋体;">下面研究</span><span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">个经典的组合优化问题，并以此说明贪心算法与动态规划算法的主要差别。</span></p>
<h4 class="p0">0-1<span style="font-family: 宋体;">背包问题：</span></h4>
<p class="p0">给定<span style="font-family: 'Courier New';">n</span><span style="font-family: 宋体;">种物品和一个背包。物品</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">的重量是</span><span style="font-family: 'Courier New';">Wi</span><span style="font-family: 宋体;">，其价值为</span><span style="font-family: 'Courier New';">Vi</span><span style="font-family: 宋体;">，背包的容量为</span><span style="font-family: 'Courier New';">C</span><span style="font-family: 宋体;">。应如何选择装入背包的物品，使得装入背包中物品的总价值最大</span><span style="font-family: 'Courier New';">?</span></p>
<p class="p0">在选择装入背包的物品时，<span style="color: #0000ff;">对每种物品<span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">只有</span><span style="font-family: 'Courier New';">2</span></span><span style="font-family: 宋体;"><span style="color: #0000ff;">种选择，即装入背包或不装入背包</span>。不能将物品</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">装入背包多次，也不能只装入部分的物品</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">。</span></p>
<h4 class="p0">背包问题：</h4>
<p class="p0">与<span style="font-family: 'Courier New';">0-1</span><span style="font-family: 宋体;">背包问题类似，所不同的是在选择物品</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">装入背包时，可以选择物品</span><span style="font-family: 'Courier New';">i</span><span style="font-family: 宋体;">的一部分，而不一定要全部装入背包，</span><span style="font-family: 'Courier New';">1</span> &lt;= i &lt;= n<span style="font-family: 宋体;">。</span></p>
<p class="p0">这<span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">类问题都具有最优子结构性质，极为相似，但背包问题可以用贪心算法求解，而</span><span style="font-family: 'Courier New';">0-1</span><span style="font-family: 宋体;">背包问题却不能用贪心算法求解。</span></p>
<h3 class="p0">用贪心算法解背包问题的基本步骤：</h3>
<p class="p0">首先计算每种物品单位重量的价值<span style="font-family: 'Courier New';">Vi/Wi</span><span style="font-family: 宋体;">，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。若将这种物品全部装入背包后，背包内的物品总重量未超过</span><span style="font-family: 'Courier New';">C</span><span style="font-family: 宋体;">，则选择单位重量价值次高的物品并尽可能多地装入背包。依此策略一直地进行下去，直到背包装满为止。</span></p>
<p class="p0">伪代码：</p>
<p class="p0">void Knapsack(int n,float M,float v[],float w[],float x[])</p>
<p class="p0">{</p>
<p class="p0">　　Sort(n,v,w);</p>
<p class="p0">　　int i;</p>
<p class="p0">　　for (i = 1 ; i &lt;= n ; i++) </p>
<p class="p0">　　　　x[i] = 0;</p>
<p class="p0">　　　　float c=M;</p>
<p class="p0">　　　　for (i=1;i&lt;=n;i++) {</p>
<p class="p0">　　　　　　if (w[i] &gt; c) break;</p>
<p class="p0">　　　　x[i]=1;</p>
<p class="p0">　　　　c-=w[i];</p>
<p class="p0">　　}</p>
<p class="p0">　　if (i &lt;= n) </p>
<p class="p0">　　　　x[i]=c / w[i];</p>
<p class="p0">}</p>
<p class="p0">算法<span style="font-family: 'Courier New';">knapsack</span><span style="font-family: 宋体;">的主要计算时间在于将各种物品依其单位重量的价值从大到小排序。因此，算法的计算时间上界为 </span><span style="font-family: 'Courier New';">O</span><span style="font-family: 宋体;">（</span><span style="font-family: 'Courier New';">nlogn</span><span style="font-family: 宋体;">）。</span></p>
<p class="p0">为了证明算法的正确性，还必须证明背包问题具有贪心选择性质。</p>
<p class="p0">对于<span style="font-family: 'Courier New';">0-1</span><span style="font-family: 宋体;">背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。事实上，在考虑</span><span style="font-family: 'Courier New';">0-1</span><span style="font-family: 宋体;">背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。这正是该问题可用动态规划算法求解的另一重要特征。实际上也是如此，动态规划算法的确可以有效地解</span><span style="font-family: 'Courier New';">0-1</span><span style="font-family: 宋体;">背包问题。</span></p>
<h2 class="p0">问题二、 哈夫曼编码</h2>
<p class="p0">哈夫曼编码是广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在<span style="font-family: 'Courier New';">20%</span><span style="font-family: 宋体;">～</span><span style="font-family: 'Courier New';">90%</span><span style="font-family: 宋体;">之间。哈夫曼编码算法用字符在文件中出现的频率表来建立一个用</span><span style="font-family: 'Courier New';">0</span><span style="font-family: 宋体;">，</span><span style="font-family: 'Courier New';">1</span><span style="font-family: 宋体;">串表示各字符的最优表示方式。</span></p>
<p class="p0">给出现频率高的字符较短的编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p>
<table border="0" class="cnblogs_code_collapse">
<tbody>
<tr>
<td align="center">
<p class="p0"> </p>
</td>
<td align="center">
<p class="p0">a</p>
</td>
<td align="center">
<p class="p0">b</p>
</td>
<td align="center">
<p class="p0">c</p>
</td>
<td align="center">
<p class="p0">d</p>
</td>
<td align="center">
<p class="p0">e</p>
</td>
<td align="center">
<p class="p0">f</p>
</td>
</tr>
<tr>
<td align="center">
<p class="p0">频率（千次）</p>
</td>
<td align="center">
<p class="p0">45</p>
</td>
<td align="center">
<p class="p0">13</p>
</td>
<td align="center">
<p class="p0">12</p>
</td>
<td align="center">
<p class="p0">16</p>
</td>
<td align="center">
<p class="p0">9</p>
</td>
<td align="center">
<p class="p0">5</p>
</td>
</tr>
<tr>
<td align="center">
<p class="p0">定长码</p>
</td>
<td align="center">
<p class="p0">000</p>
</td>
<td align="center">
<p class="p0">001</p>
</td>
<td align="center">
<p class="p0">010</p>
</td>
<td align="center">
<p class="p0">011</p>
</td>
<td align="center">
<p class="p0">100</p>
</td>
<td align="center">
<p class="p0">101</p>
</td>
</tr>
<tr>
<td align="center">
<p class="p0">变长码</p>
</td>
<td align="center">
<p class="p0">0</p>
</td>
<td align="center">
<p class="p0">101</p>
</td>
<td align="center">
<p class="p0">100</p>
</td>
<td align="center">
<p class="p0">111</p>
</td>
<td align="center">
<p class="p0">1101</p>
</td>
<td align="center">
<p class="p0">1100</p>
</td>
</tr>
</tbody>
</table>
<p class="p0">定长码：</p>
<p class="p0">　　3*(45+13+12+16+9+5) = 300 <span style="font-family: 宋体;">千位</span></p>
<p class="p0">变长码：</p>
<p class="p0">　　1*45+3*13+3*12+3*16+4*9+4*5 <span style="font-family: 宋体;">＝ </span><span style="font-family: 'Courier New';">224 </span><span style="font-family: 宋体;">千位</span></p>
<h3 class="p0">1<span style="font-family: 宋体;">、前缀码</span></h3>
<p class="p0">对每一个字符规定一个<span style="font-family: 'Courier New';">0,1</span><span style="font-family: 宋体;">串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀。</span>这种编码称为<strong>前缀码</strong>。</p>
<p class="p0">编码的前缀性质可以使译码方法非常简单。 </p>
<p class="p0">表示最优前缀码的二叉树总是一棵完全二叉树，即树中任一结点都有<span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">个儿子结点。</span></p>
<p class="p0">f(c)<span style="font-family: 宋体;">表示字符</span><span style="font-family: 'Courier New';">c</span><span style="font-family: 宋体;">出现的概率，</span><span style="font-family: 'Courier New';">dt(c)</span><span style="font-family: 宋体;">表示</span><span style="font-family: 'Courier New';">c</span><span style="font-family: 宋体;">的码长</span></p>
<p class="p0">平均码长定义为：<img alt="" height="50" src="http://cdn.acmerblog.com/img/1388749259815.jpg"/></p>
<p class="p0">使平均码长达到最小的前缀码编码方案称为给定编码字符集<span style="font-family: 'Courier New';">C</span><span style="font-family: 宋体;">的</span><strong>最优前缀码</strong>。</p>
<h3 class="p0">2、构造哈夫曼编码</h3>
<p class="p0">哈夫曼提出构造最优前缀码的贪心算法，由此产生的编码方案称为<strong>哈夫曼编码</strong>。</p>
<p class="p0">哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树<span style="font-family: 'Courier New';">T</span><span style="font-family: 宋体;">。</span></p>
<p class="p0">算法以<span style="font-family: 'Courier New';">|C|</span><span style="font-family: 宋体;">个叶结点开始，执行</span><span style="font-family: 'Courier New';">|C|</span><span style="font-family: 宋体;">－</span><span style="font-family: 'Courier New';">1</span><span style="font-family: 宋体;">次的“合并”运算后产生最终所要求的树</span><span style="font-family: 'Courier New';">T</span><span style="font-family: 宋体;">。 </span></p>
<p class="p0">以<span style="font-family: 'Courier New';">f</span><span style="font-family: 宋体;">为键值的优先队列</span><span style="font-family: 'Courier New';">Q</span><span style="font-family: 宋体;">用在贪心选择时有效地确定算法当前要合并的</span><span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">棵具有最小频率的树。一旦</span><span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的</span><span style="font-family: 'Courier New';">2</span><span style="font-family: 宋体;">棵树的频率之和，并将新树插入优先队列</span><span style="font-family: 'Courier New';">Q</span><span style="font-family: 宋体;">。经过</span><span style="font-family: 'Courier New';">n</span><span style="font-family: 宋体;">－</span><span style="font-family: 'Courier New';">1</span><span style="font-family: 宋体;">次的合并后，优先队列中只剩下一棵树，即所要求的树</span><span style="font-family: 'Courier New';">T</span><span style="font-family: 宋体;">。</span></p>
<p class="p0">算法<span style="font-family: 'Courier New';">huffmanTree</span><span style="font-family: 宋体;">用最小堆实现优先队列</span><span style="font-family: 'Courier New';">Q</span><span style="font-family: 宋体;">。初始化优先队列需要</span><span style="font-family: 'Courier New';">O(n)</span><span style="font-family: 宋体;">计算时间，由于最小堆的</span><span style="font-family: 'Courier New';">removeMin</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Courier New';">put</span><span style="font-family: 宋体;">运算均需</span><span style="font-family: 'Courier New';">O(logn)</span><span style="font-family: 宋体;">时间，</span><span style="font-family: 'Courier New';">n</span><span style="font-family: 宋体;">－</span><span style="font-family: 'Courier New';">1</span><span style="font-family: 宋体;">次的合并总共需要</span><span style="font-family: 'Courier New';">O(nlogn)</span><span style="font-family: 宋体;">计算时间。因此，关于</span><span style="font-family: 'Courier New';">n</span><span style="font-family: 宋体;">个字符的哈夫曼算法的计算时间为</span><span style="font-family: 'Courier New';">O(nlogn) </span><span style="font-family: 宋体;">。</span></p>
<h3 class="p0">3<span style="font-family: 宋体;">、哈夫曼算法的正确性</span></h3>
<p class="p0">要证明哈夫曼算法的正确性，只要证明最优前缀码问题具有贪心选择性质和最优子结构性质。</p>
<p class="p0">(1)<span style="font-family: 宋体;">贪心选择性质</span></p>
<p class="p0">(2)<span style="font-family: 宋体;">最优子结构性质</span></p>
<p class="p0"><span style="font-family: 宋体;">实现：</span></p>
<p class="p0"><span style="font-family: 宋体;"></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('42322ac1-e3f5-465d-a830-289cb5591d93')"><img alt="" class="code_img_closed" id="code_img_closed_42322ac1-e3f5-465d-a830-289cb5591d93" src="http://cdn.acmerblog.com/img/1388749259993.gif"/><img alt="" class="code_img_opened" id="code_img_opened_42322ac1-e3f5-465d-a830-289cb5591d93" onclick="cnblogs_code_hide('42322ac1-e3f5-465d-a830-289cb5591d93',event)" src="http://cdn.acmerblog.com/img/1388749260073.gif" style="display: none;"/><span class="cnblogs_code_collapse">代码</span>
<div class="cnblogs_code_hide" id="cnblogs_code_open_42322ac1-e3f5-465d-a830-289cb5591d93">
<pre><div>&lt;<br/><br/>Code highlighting produced by Actipro CodeHighlighter (freeware)<br/>http://www.CodeHighlighter.com/<br/><br/>&gt;<span style="color: #008000;">/*</span><span style="color: #008000;"> 主题: Haffman编码<br/>* 作者: chinazhangjie<br/>* 邮箱: chinajiezhang@gmail.com<br/>* 开发环境 : Microsoft Visual Studio 2008<br/>* 时间 : 2010.11.21<br/></span><span style="color: #008000;">*/</span><span style="color: #000000;"><br/><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iostream</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">vector</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">queue</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> <br/></span><span style="color: #0000ff;">using</span><span style="color: #000000;"> </span><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std ;<br/><br/><br/></span><span style="color: #0000ff;">class</span><span style="color: #000000;"> HaffmanNode<br/>{<br/></span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br/>    HaffmanNode (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> nKeyValue, <br/>                HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;"> pLeft </span><span style="color: #000000;">=</span><span style="color: #000000;"> NULL,<br/>                HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;"> pRight </span><span style="color: #000000;">=</span><span style="color: #000000;"> NULL)<br/>    { <br/>        m_nKeyValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> nKeyValue ;<br/>        m_pLeft </span><span style="color: #000000;">=</span><span style="color: #000000;"> pLeft ;<br/>        m_pRight </span><span style="color: #000000;">=</span><span style="color: #000000;"> pRight ;<br/>    }<br/><br/>    friend <br/>    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> </span><span style="color: #0000ff;">operator</span><span style="color: #000000;"> </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> HaffmanNode</span><span style="color: #000000;">&amp;</span><span style="color: #000000;"> lth, </span><span style="color: #0000ff;">const</span><span style="color: #000000;"> HaffmanNode</span><span style="color: #000000;">&amp;</span><span style="color: #000000;"> rth)<br/>    {<br/>        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> lth.m_nKeyValue </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> rth.m_nKeyValue ;<br/>    }<br/><br/></span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br/>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;">        m_nKeyValue ;    <br/>    HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;">    m_pLeft ;<br/>    HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;">    m_pRight ;<br/>} ;<br/><br/></span><span style="color: #0000ff;">class</span><span style="color: #000000;"> HaffmanCoding<br/>{<br/></span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br/>    typedef priority_queue</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">HaffmanNode</span><span style="color: #000000;">*&gt;</span><span style="color: #000000;"> MinHeap ;<br/>    typedef HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;">    HaffmanTree ;<br/><br/></span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br/>    HaffmanCoding (</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;&amp;</span><span style="color: #000000;"> weight) <br/>        : m_pTree(NULL)<br/>    {<br/>        m_stCount </span><span style="color: #000000;">=</span><span style="color: #000000;"> weight.size () ;<br/>        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (size_t i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> weight.size() ; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>            m_minheap.push (</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> HaffmanNode(weight[i], NULL, NULL)) ;<br/>        }<br/>    }<br/>    </span><span style="color: #000000;">~</span><span style="color: #000000;"> HaffmanCoding()<br/>    {<br/>        __destroy (m_pTree) ;<br/>    }<br/><br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 按照左1右0编码 </span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> doHaffmanCoding ()<br/>    {<br/>        vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> vnCode(m_stCount</span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">) ;<br/>        __constructTree () ;<br/>        __traverse (m_pTree, </span><span style="color: #800080;">0</span><span style="color: #000000;">, vnCode) ;<br/>    }<br/>    <br/></span><span style="color: #0000ff;">private</span><span style="color: #000000;">:<br/>    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> __destroy(HaffmanTree</span><span style="color: #000000;">&amp;</span><span style="color: #000000;"> ht) <br/>    {<br/>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pLeft </span><span style="color: #000000;">!=</span><span style="color: #000000;"> NULL) {<br/>            __destroy (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pLeft) ;<br/>        }<br/>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pRight </span><span style="color: #000000;">!=</span><span style="color: #000000;"> NULL) {<br/>            __destroy (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pRight) ;<br/>        }<br/>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pLeft </span><span style="color: #000000;">==</span><span style="color: #000000;"> NULL </span><span style="color: #000000;">&amp;&amp;</span><span style="color: #000000;"> ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pRight </span><span style="color: #000000;">==</span><span style="color: #000000;"> NULL) {<br/>            </span><span style="color: #008000;">//</span><span style="color: #008000;"> cout &lt;&lt; "delete" &lt;&lt; endl ;</span><span style="color: #008000;"><br/></span><span style="color: #000000;">            delete ht ;<br/>            ht </span><span style="color: #000000;">=</span><span style="color: #000000;"> NULL ;<br/>        }<br/>    }<br/>    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> __traverse (HaffmanTree ht,</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> layers, vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;&amp;</span><span style="color: #000000;"> vnCode) <br/>    {<br/>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pLeft </span><span style="color: #000000;">!=</span><span style="color: #000000;"> NULL) {<br/>            vnCode[layers] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;"> ;<br/>            __traverse (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pLeft, </span><span style="color: #000000;">++</span><span style="color: #000000;"> layers, vnCode) ;<br/>            </span><span style="color: #000000;">--</span><span style="color: #000000;"> layers ;<br/>        }<br/>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pRight </span><span style="color: #000000;">!=</span><span style="color: #000000;"> NULL) {<br/>            vnCode[layers] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>            __traverse (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pRight, </span><span style="color: #000000;">++</span><span style="color: #000000;"> layers, vnCode) ;<br/>            </span><span style="color: #000000;">--</span><span style="color: #000000;"> layers ;<br/>        }<br/>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pLeft </span><span style="color: #000000;">==</span><span style="color: #000000;"> NULL </span><span style="color: #000000;">&amp;&amp;</span><span style="color: #000000;"> ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_pRight </span><span style="color: #000000;">==</span><span style="color: #000000;"> NULL) {<br/>            cout </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> ht</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_nKeyValue </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> </span><span style="color: #800000;">"</span><span style="color: #800000;"> coding:  </span><span style="color: #800000;">"</span><span style="color: #000000;"> ;<br/>            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> layers; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>                 cout </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> vnCode[i] </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> </span><span style="color: #800000;">"</span><span style="color: #800000;"> </span><span style="color: #800000;">"</span><span style="color: #000000;"> ;<br/>            }<br/>            cout </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> endl ;<br/>        }<br/>    }<br/><br/>    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> __constructTree ()<br/>    {<br/>        size_t i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;"> ;<br/>        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> m_stCount) {<br/>            HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;"> lchild </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_minheap.top () ;<br/>            m_minheap.pop () ;<br/>            HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;"> rchild </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_minheap.top () ;<br/>            m_minheap.pop () ;<br/>            <br/>            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 确保左子树的键值大于有子树的键值</span><span style="color: #008000;"><br/></span><span style="color: #000000;">            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (lchild</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_nKeyValue </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> rchild</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_nKeyValue) {<br/>                HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;"> temp </span><span style="color: #000000;">=</span><span style="color: #000000;"> lchild ;<br/>                lchild </span><span style="color: #000000;">=</span><span style="color: #000000;"> rchild ;<br/>                rchild </span><span style="color: #000000;">=</span><span style="color: #000000;"> temp ;<br/>            }<br/>            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 构造新结点</span><span style="color: #008000;"><br/></span><span style="color: #000000;">            HaffmanNode</span><span style="color: #000000;">*</span><span style="color: #000000;"> pNewNode </span><span style="color: #000000;">=</span><span style="color: #000000;"> <br/>                </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> HaffmanNode (lchild</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_nKeyValue </span><span style="color: #000000;">+</span><span style="color: #000000;"> rchild</span><span style="color: #000000;">-&gt;</span><span style="color: #000000;">m_nKeyValue,<br/>                lchild, rchild ) ;<br/>            m_minheap.push (pNewNode) ;<br/>            </span><span style="color: #000000;">++</span><span style="color: #000000;"> i ;<br/>        }<br/>        m_pTree </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_minheap.top () ;<br/>        m_minheap.pop () ;<br/>    }<br/><br/></span><span style="color: #0000ff;">private</span><span style="color: #000000;">:<br/>    vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> m_vnWeight ;    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 权值</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    HaffmanTree m_pTree ;<br/>    MinHeap        m_minheap ;<br/>    size_t        m_stCount ;        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 叶结点个数</span><span style="color: #008000;"><br/></span><span style="color: #000000;">} ;<br/><br/><br/></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br/>{    <br/>    vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> vnWeight ;<br/>    vnWeight.push_back (</span><span style="color: #800080;">45</span><span style="color: #000000;">) ;<br/>    vnWeight.push_back (</span><span style="color: #800080;">13</span><span style="color: #000000;">) ;<br/>    vnWeight.push_back (</span><span style="color: #800080;">12</span><span style="color: #000000;">) ;<br/>    vnWeight.push_back (</span><span style="color: #800080;">16</span><span style="color: #000000;">) ;<br/>    vnWeight.push_back (</span><span style="color: #800080;">9</span><span style="color: #000000;">) ;<br/>    vnWeight.push_back (</span><span style="color: #800080;">5</span><span style="color: #000000;">) ;<br/><br/>    HaffmanCoding hc (vnWeight) ;<br/>    hc.doHaffmanCoding () ;<br/>    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>}</span></div></pre>
</div>
</div>
<p> </p>
<p></p>
<h2 class="p0">问题三、单源最大路径</h2>
<p class="p0">给定带权有向图<span style="font-family: 'Courier New';">G =(V,E)</span><span style="font-family: 宋体;">，其中每条边的权是非负实数。另外，还给定</span><span style="font-family: 'Courier New';">V</span><span style="font-family: 宋体;">中的一个顶点，称为</span>源。现在要计算从源到所有其它各顶点的最短路长度。这里路的长度是指路上各边权之和。这个问题通常称为单源最短路径问题。</p>
<h3 class="p0">1<span style="font-family: 宋体;">、算法基本思想</span></h3>
<p class="p0">Dijkstra<span style="font-family: 宋体;">算法是解单源最短路径问题的贪心算法。</span></p>
<p class="p0">其基本思想是，设置顶点集合<span style="font-family: 'Courier New';">S</span><span style="font-family: 宋体;">并不断地作贪心选择来扩充这个集合。一个顶点属于集合</span><span style="font-family: 'Courier New';">S</span><span style="font-family: 宋体;">当且仅当从源到该顶点的最短路径长度已知。</span></p>
<p class="p0">初始时，<span style="font-family: 'Courier New';">S</span><span style="font-family: 宋体;">中仅含有源。设</span><span style="font-family: 'Courier New';">u</span><span style="font-family: 宋体;">是</span><span style="font-family: 'Courier New';">G</span><span style="font-family: 宋体;">的某一个顶点，把从源到</span><span style="font-family: 'Courier New';">u</span><span style="font-family: 宋体;">且中间只经过</span><span style="font-family: 'Courier New';">S</span><span style="font-family: 宋体;">中顶点的路称为从源到</span><span style="font-family: 'Courier New';">u</span><span style="font-family: 宋体;">的特殊路径，并用数组</span><span style="font-family: 'Courier New';">dist</span><span style="font-family: 宋体;">记录当前每个顶点所对应的最短特殊路径长度。</span><span style="font-family: 'Courier New';">Dijkstra</span><span style="font-family: 宋体;">算法每次从</span><span style="font-family: 'Courier New';">V-S</span><span style="font-family: 宋体;">中取出具有最短特殊路长度的顶点</span><span style="font-family: 'Courier New';">u</span><span style="font-family: 宋体;">，将</span><span style="font-family: 'Courier New';">u</span><span style="font-family: 宋体;">添加到</span><span style="font-family: 'Courier New';">S</span><span style="font-family: 宋体;">中，同时对数组</span><span style="font-family: 'Courier New';">dist</span><span style="font-family: 宋体;">作必要的修改。一旦</span><span style="font-family: 'Courier New';">S</span><span style="font-family: 宋体;">包含了所有</span><span style="font-family: 'Courier New';">V</span><span style="font-family: 宋体;">中顶点，</span><span style="font-family: 'Courier New';">dist</span><span style="font-family: 宋体;">就记录了从源到所有其它顶点之间的最短路径长度。</span></p>
<p class="p0">例如，对下图中的有向图，应用<span style="font-family: 'Courier New';">Dijkstra</span><span style="font-family: 宋体;">算法计算从源顶点</span><span style="font-family: 'Courier New';">1</span><span style="font-family: 宋体;">到其它顶点间最短路径的过程列在下表中。</span></p>
<p class="p0"><span style="font-family: 宋体;"><img alt="" height="200" src="http://cdn.acmerblog.com/img/1388749260258.jpg"/><br/></span></p>
<p class="p0">Dijkstra<span style="font-family: 宋体;">算法的迭代过程：</span></p>
<table border="0" class="cnblogs_code_collapse">
<tbody>
<tr>
<td valign="center" width="72">
<p class="p0">迭代</p>
</td>
<td valign="center" width="108">
<p class="p0">s</p>
</td>
<td valign="center" width="55">
<p class="p0">u</p>
</td>
<td valign="center" width="67">
<p class="p0">dist[2]</p>
</td>
<td valign="center" width="67">
<p class="p0">dist[3]</p>
</td>
<td valign="center" width="67">
<p class="p0">dist[4]</p>
</td>
<td valign="center" width="67">
<p class="p0">dist[5]</p>
</td>
</tr>
<tr>
<td valign="center" width="72">
<p class="p0">初始</p>
</td>
<td valign="center" width="108">
<p class="p0">{1}</p>
</td>
<td valign="center" width="55">
<p class="p0">-</p>
</td>
<td valign="center" width="67">
<p class="p0">10</p>
</td>
<td valign="center" width="67">
<p class="p0">maxint</p>
</td>
<td valign="center" width="67">
<p class="p0">30</p>
</td>
<td valign="center" width="67">
<p class="p0">100</p>
</td>
</tr>
<tr>
<td valign="center" width="72">
<p class="p0">1</p>
</td>
<td valign="center" width="108">
<p class="p0">{1,2}</p>
</td>
<td valign="center" width="55">
<p class="p0">2</p>
</td>
<td valign="center" width="67">
<p class="p0">10</p>
</td>
<td valign="center" width="67">
<p class="p0">60</p>
</td>
<td valign="center" width="67">
<p class="p0">30</p>
</td>
<td valign="center" width="67">
<p class="p0">100</p>
</td>
</tr>
<tr>
<td valign="center" width="72">
<p class="p0">2</p>
</td>
<td valign="center" width="108">
<p class="p0">{1,2,4}</p>
</td>
<td valign="center" width="55">
<p class="p0">4</p>
</td>
<td valign="center" width="67">
<p class="p0">10</p>
</td>
<td valign="center" width="67">
<p class="p0">50</p>
</td>
<td valign="center" width="67">
<p class="p0">30</p>
</td>
<td valign="center" width="67">
<p class="p0">90</p>
</td>
</tr>
<tr>
<td valign="center" width="72">
<p class="p0">3</p>
</td>
<td valign="center" width="108">
<p class="p0">{1,2,4,3}</p>
</td>
<td valign="center" width="55">
<p class="p0">3</p>
</td>
<td valign="center" width="67">
<p class="p0">10</p>
</td>
<td valign="center" width="67">
<p class="p0">50</p>
</td>
<td valign="center" width="67">
<p class="p0">30</p>
</td>
<td valign="center" width="67">
<p class="p0">60</p>
</td>
</tr>
<tr>
<td valign="center" width="72">
<p class="p0">4</p>
</td>
<td valign="center" width="108">
<p class="p0">{1,2,4,3,5}</p>
</td>
<td valign="center" width="55">
<p class="p0">5</p>
</td>
<td valign="center" width="67">
<p class="p0">10</p>
</td>
<td valign="center" width="67">
<p class="p0">50</p>
</td>
<td valign="center" width="67">
<p class="p0">30</p>
</td>
<td valign="center" width="67">
<p class="p0">60</p>
</td>
</tr>
</tbody>
</table>
<p class="p0">2<span style="font-family: 宋体;">、算法的正确性和计算复杂性</span></p>
<p class="p0">(1)<span style="font-family: 宋体;">贪心选择性质</span></p>
<p class="p0">(2)<span style="font-family: 宋体;">最优子结构性质</span></p>
<p class="p0">(3)<span style="font-family: 宋体;">计算复杂性</span></p>
<p class="p0">对于具有<span style="font-family: 'Courier New';">n</span><span style="font-family: 宋体;">个顶点和</span><span style="font-family: 'Courier New';">e</span><span style="font-family: 宋体;">条边的带权有向图，如果用带权邻接矩阵表示这个图，那么</span><span style="font-family: 'Courier New';">Dijkstra</span><span style="font-family: 宋体;">算法的主循环体需要</span><span style="font-family: 'Courier New';">O(n)</span><span style="font-family: 宋体;">时间。这个循环需要执行</span><span style="font-family: 'Courier New';">n-1</span><span style="font-family: 宋体;">次，所以完成循环需要O(n)时间。算法的其余部分所需要时间不超过</span><span style="font-family: 'Courier New';">O(n^2)</span><span style="font-family: 宋体;">。</span></p>
<p class="p0">实现：</p>
<p class="p0"><span style="font-family: 宋体;"> </span></p>
<pre class="brush:cpp ">/* 主题: Dijkastra算法
* 作者: chinazhangjie
* 邮箱: chinajiezhang@gmail.com
* 开发环境 : Microsoft Visual Studio 2008
* 时间 : 2010.11.23
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;limits&gt;
using namespace std ;

class BBShortestDijkstra
{
public:
    BBShortestDijkstra (const vector&lt;vector&lt;int&gt; &gt;&amp; vnGraph) 
        :m_cnMaxInt (numeric_limits&lt;int&gt;::max()) 
    {
        m_vnGraph = vnGraph ;
        m_stCount = vnGraph.size () ;
        m_vnDist.resize (m_stCount) ;
        for (size_t i = 0; i &lt; m_stCount; ++ i) {
            m_vnDist[i].resize (m_stCount) ;
        }
    }
    
    void doDijkatra ()
    {
        int nMinIndex = 0 ;
        int nMinValue = m_cnMaxInt ;
        vector&lt;bool&gt; vbFlag (m_stCount, false) ;
        for (size_t i = 0; i &lt; m_stCount; ++ i) {
            m_vnDist[0][i] = m_vnGraph[0][i] ;
            if (nMinValue &gt; m_vnGraph[0][i]) {
                nMinValue = m_vnGraph[0][i] ;
                nMinIndex = i ;
            }
        }

        vbFlag[0] = true ;
        size_t k = 1 ;
        while (k &lt; m_stCount) {
            vbFlag[nMinIndex] = true ;
            for (size_t j = 0; j &lt; m_stCount ; ++ j) {
                // 没有被选择
                if (!vbFlag[j] &amp;&amp; m_vnGraph[nMinIndex][j] != m_cnMaxInt ) {
                    if (m_vnGraph[nMinIndex][j] + nMinValue
                        &lt; m_vnDist[k-1][j]) {
                        m_vnDist[k][j] = m_vnGraph[nMinIndex][j] + nMinValue ;
                    }
                    else {
                        m_vnDist[k][j] = m_vnDist[k-1][j] ;
                    }
                }
                else {
                    m_vnDist[k][j] = m_vnDist[k-1][j] ;
                }
            }
            nMinValue = m_cnMaxInt ;
            for (size_t j = 0; j &lt; m_stCount; ++ j) {
                if (!vbFlag[j] &amp;&amp; (nMinValue &gt; m_vnDist[k][j])) {
                    nMinValue = m_vnDist[k][j] ;
                    nMinIndex = j ;
                }
            }
            ++ k ;
        }

        for (int i = 0; i &lt; m_stCount; ++ i) {
            for (int j = 0; j &lt; m_stCount; ++ j) {
                if (m_vnDist[i][j] == m_cnMaxInt) {
                    cout &lt;&lt; "maxint " ;
                }
                else {
                    cout &lt;&lt; m_vnDist[i][j] &lt;&lt; " " ;
                }
            }
            cout &lt;&lt; endl ;
        }
    }
private:  
    vector&lt;vector&lt;int&gt; &gt;    m_vnGraph ;
    vector&lt;vector&lt;int&gt; &gt;    m_vnDist ;
    size_t m_stCount ;
    const int m_cnMaxInt ;
} ;

int main()
{
    const int cnCount = 5 ;
    vector&lt;vector&lt;int&gt; &gt; vnGraph (cnCount) ;
    for (int i = 0; i &lt; cnCount; ++ i) {
        vnGraph[i].resize (cnCount, numeric_limits&lt;int&gt;::max()) ;
    }
    vnGraph[0][1] = 10 ;
    vnGraph[0][3] = 30 ;
    vnGraph[0][4] = 100 ;
    vnGraph[1][2] = 50 ;
    vnGraph[2][4] = 10 ;
    vnGraph[3][2] = 20 ;
    vnGraph[3][4] = 60 ;

    BBShortestDijkstra bbs (vnGraph) ;
    bbs.doDijkatra () ;
}</pre>
<p> </p>
<p> </p>
<p class="p0"><span style="font-family: 宋体;"><br/></span></p>
<p class="p0"><strong><span style="font-family: 宋体;">参考资料 《算法分析与设计》 王晓东编著</span></strong></p>
<p class="p0"><strong><span style="font-family: 宋体;">授课教师  张阳教授</span></strong></p>
<p>转自：http://www.cnblogs.com/chinazhangjie/archive/2010/11/23/1885330.html</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-86483">
<article class="comment" id="comment-86483">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919527639" rel="external nofollow">新用户189821</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-86483" rel="nofollow"><time datetime="2017-04-13T05:36:37+00:00" pubdate="">2017年4月13日 at 上午5:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这是怪物猎人里面的工具啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-65050">
<article class="comment" id="comment-65050">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.kaixin001.com/home/?uid=145877219" rel="external nofollow">熊翔爱</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-65050" rel="nofollow"><time datetime="2017-03-11T03:54:05+00:00" pubdate="">2017年3月11日 at 上午3:54</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>▅▅▅▅▅▅▅▅看а片 【 <a href="http://www.rennn.info" rel="nofollow">http://www.rennn.info</a> 】 你*懂*得▅▅▅▅▅▅▅▅ ▅▅▅▅▅▅▅▅看а片 【 <a href="http://www.rennn.info" rel="nofollow">http://www.rennn.info</a> 】 你*懂*得▅▅▅▅▅▅▅▅ ▅▅▅▅▅▅▅▅看а片 【 <a href="http://www.rennn.info" rel="nofollow">http://www.rennn.info</a> 】 你*懂*得▅▅▅▅▅▅▅▅ .</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19983">
<article class="comment" id="comment-19983">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">hao555sky</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19983" rel="nofollow"><time datetime="2015-06-18T11:35:21+00:00" pubdate="">2015年6月18日 at 上午11:35</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>map[nodes <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> .index][nodes <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/af/newj_org.gif"/> .index] == 0 就是判断不相邻的。这个是可以证明的。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19987">
<article class="comment" id="comment-19987">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">HaibaraAi</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19987" rel="nofollow"><time datetime="2015-05-20T16:55:55+00:00" pubdate="">2015年5月20日 at 下午4:55</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p><a href="http://beeder.me" rel="nofollow">http://beeder.me</a> 这个网站上有很多poj和hihoCoder的题解，质量不错，欢迎转载。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19990">
<article class="comment" id="comment-19990">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wynk0804</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19990" rel="nofollow"><time datetime="2015-05-19T13:47:52+00:00" pubdate="">2015年5月19日 at 下午1:47</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p><a href="http://beeder.me" rel="nofollow">http://beeder.me</a> 这个网站上有很多poj和hihoCoder的题解，质量不错，欢迎转载。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19984">
<article class="comment" id="comment-19984">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">645198</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19984" rel="nofollow"><time datetime="2015-03-27T14:49:00+00:00" pubdate="">2015年3月27日 at 下午2:49</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>是O(m+n)，不小心打错了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19982">
<article class="comment" id="comment-19982">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">gaotong2055</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19982" rel="nofollow"><time datetime="2015-02-10T18:17:37+00:00" pubdate="">2015年2月10日 at 下午6:17</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>DFS方法的原理还是不太清楚啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19978">
<article class="comment" id="comment-19978">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">skyand</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19978" rel="nofollow"><time datetime="2015-01-13T23:41:56+00:00" pubdate="">2015年1月13日 at 下午11:41</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>总结的很全面，学习了！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19981">
<article class="comment" id="comment-19981">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">samjustin</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19981" rel="nofollow"><time datetime="2014-10-30T09:14:29+00:00" pubdate="">2014年10月30日 at 上午9:14</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>正有此意，欢迎更多的建议~</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19986">
<article class="comment" id="comment-19986">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">hehe_snail</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19986" rel="nofollow"><time datetime="2014-10-25T05:38:40+00:00" pubdate="">2014年10月25日 at 上午5:38</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好。代码比书上的简练！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19985">
<article class="comment" id="comment-19985">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">AC_Grazy</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19985" rel="nofollow"><time datetime="2014-07-11T08:42:21+00:00" pubdate="">2014年7月11日 at 上午8:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>因为是要把从字符串s的start位到当前位在hash中重置，修改提交后能accept，但是不修改居然也能accept</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19980">
<article class="comment" id="comment-19980">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">xun.gong</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19980" rel="nofollow"><time datetime="2014-06-13T07:31:29+00:00" pubdate="">2014年6月13日 at 上午7:31</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的思路，可以借鉴</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19989">
<article class="comment" id="comment-19989">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">rtaxa</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19989" rel="nofollow"><time datetime="2014-06-08T01:09:45+00:00" pubdate="">2014年6月8日 at 上午1:09</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>其实就是DFS搜索，数据量较小，穷举了所有情况</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19991">
<article class="comment" id="comment-19991">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">pain</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19991" rel="nofollow"><time datetime="2014-03-25T02:37:13+00:00" pubdate="">2014年3月25日 at 上午2:37</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>正有此意，欢迎更多的建议~</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19979">
<article class="comment" id="comment-19979">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Ding Qiangyuan</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19979" rel="nofollow"><time datetime="2014-02-15T10:11:50+00:00" pubdate="">2014年2月15日 at 上午10:11</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很强大啊，佩服</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19988">
<article class="comment" id="comment-19988">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">sgx_go</a></span> on <a href="http://www.acmerblog.com/greed-algorithm-3378.html#comment-19988" rel="nofollow"><time datetime="2014-01-25T04:57:02+00:00" pubdate="">2014年1月25日 at 上午4:57</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好！！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>