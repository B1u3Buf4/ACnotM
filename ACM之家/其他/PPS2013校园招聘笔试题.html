<div class="c-top2" id="post-55">
<div class="datetime">2014<br/>01-05</div>
<div class="tit"><h1 class="entry-title">PPS2013校园招聘笔试题</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/offer" rel="category tag" title="查看剑指offer中的全部文章">剑指offer</a></span><span class="i4">围观1636次</span><span class="i3"><a class="ds-thread-count" data-thread-key="3414" href="http://www.acmerblog.com/interview-pps-3414.html#comments" title="《PPS2013校园招聘笔试题》上的评论">14 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<p><span style="font-family: Verdana; font-size: 14px;">一、简答题<br/>
（1）一位老师有2个推理能力很强的学生，他告诉学生他手里有以下的牌：<br/>
黑桃：2 ， 5 ， 7 ， 9 ， J ， K<br/>
红心：3 ， 4 ， 9 ， J ， K<br/>
梅花：5 ， 8 ， 9 ， Q<br/>
方块：2 ， 7 ， 8<br/>
然后从中拿出一张牌，告诉A这张牌的大小，告诉了B这张牌的花色；<br/>
A：我不知道这张是什么牌<br/>
B：我就知道你肯定不知道这张是什么牌<br/>
A：现在我知道<br/>
B：现在我也知道了<br/>
请问这张是什么牌？<br/>
答：方块8</span></p>
<p>（2）有11个乒乓球，其中有一个球是伪劣产品并存在质量较轻的问题，现有一个没有砝码的天平，只能称3次把那个假货给称出来。<br/>
答：<br/>
第一次，天平两端各放5个乒乓球，如果天平平衡，那么剩下的那个就是伪劣产品。<br/>
如果不平衡，则将天平较轻那端的5个乒乓球选出来，然后在天平两端各放2个乒乓球，如果天平平衡，那么剩下的那个就是伪劣产品。否则，将天平较轻那端的2个乒乓球选出来，放在天平上重新测量，天平较轻端的那个乒乓球就是伪劣产品。</p>
<p>（3）说明指针与引用的区别。<br/>
答：<span style="font-family: Verdana; font-size: 14px;">●</span>指针是一个实体，而引用仅是个别名；<br/>
●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；<br/>
●引用没有const，指针有const，const的指针不可变；<br/>
●引用不能为空，指针可以为空；<br/>
●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；<br/>
●指针和引用的自增(++)运算意义不一样；<br/>
●引用是类型安全的，而指针不是 (引用比指针多了类型检查<br/>
从内存分配上看：程序为指针变量分配内存区域，而引用不分配内存区域。指针：指向另一个内存空间的变量，我们可以通过它来索引另一个内存空间的内容，本身有自己的内存空间。</p>
<p>（4）列出C++类型转换操作符，并分别举例。<br/>
dynamic_cast: 在多态类型转换时使用，用来执行继承体系中”安全的向下转型或跨系转型动作”,就是子类对象指针转化为父类对象指针。实现在运行时，并进行运行时检测，如果转换失败，返回值是NULL。<br/>
static_cast：与dynamic_cast相反，static_cast是在编译时转换类型的，故称为static_cast，它可以用在值类型转换中<br/>
const_cast：一般用于去除const, volatile等修饰属性上.<br/>
reinterpret_cast：特意用于底层的强制转型，这个操作符能够在非相关的类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。</p>
<p>（5）写个简单的函数，用于判断CPU的字节序（little endian/big endian）</p>
<pre class="brush:cpp ">//若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1。
int checkCPU(void)
{
	union
	{
		int a;
		char b;
	}c;
	c.a = 1;
	return (c.b == 1);
}</pre>
<p><span style="font-size: 14px;"><span style="font-family: Verdana;">（6）实现一个128位整数的类，并且完成后面的函数，测试一个数是否为素数。<br/>
class int128<br/>
{<br/>
};<br/>
bool isPrime(int128 &amp; number)<br/>
{<br/>
…<br/>
}<br/>
答：<br/>
</span></span></p>
<pre class="brush:cpp ">#include&lt;bitset&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;deque&gt;
using namespace std;

class int128;

void shift(int128 &amp; in,deque&lt;bool&gt; &amp; de);

template&lt;size_t N&gt;
bool operator&lt;(bitset&lt;N&gt; const&amp; b1,bitset&lt;N&gt; const&amp; b2)
{
	int i=N;
	while( i-- &amp;&amp; b1[i]==b2[i] ) { }

	return ((-1 == i) ? false : (b1[i]&lt;b2[i]));
}

class int128
{
    bitset&lt;128&gt; number;
public:
    explicit int128(string str):number(str){}
    int128(bitset&lt;128&gt;const&amp; b):number(b){}
    int128(int a = 0 , int b = 0 , int c = 0 , int d = 0)
	{
        bitset&lt;32&gt; b1(a),b2(b),b3(c),b4(d);
		int i, k = 128;
		for(i = 32 ; i ; number[--k] = b1[--i]) { }
		for(i = 32 ; i ; number[--k] = b2[--i]) { }
		for(i = 32 ; i ; number[--k] = b3[--i]) { }
		for(i = 32 ; i ; number[--k] = b4[--i]) { }
    }
    bool operator[](size_t i)const
	{
        return number[i];
    }
    bitset&lt;128&gt;::reference operator[](size_t i)
	{
        return number[i];
    }
    friend bool operator&lt;(int128 const&amp; i1,int128 const&amp; i2)
	{
        return i1.number &lt; i2.number;
    }

    friend int128 operator+(int128 const&amp; i1,int128 const&amp; i2)
	{
        if(i1 == 0)
			return i2;
		if(i2 == 0)
			return i1;
        int128 result;
        bitset&lt;2&gt; sum;

        for(int i = 0 ; i &lt; 128 ; ++i)
		{
            sum=i1[i]+i2[i]+sum.to_ulong();
            result[i]=sum[0];
            sum&gt;&gt;=1;
        }
        return result;
    }

    friend int128 operator-(int128 const&amp; i1,int128 const&amp; i2)
	{
        if(i2==0)
			return i1;

        int128 result=i1;

        for(int i = 0 ; i &lt; 128 ; ++i)
		{
            if(i2[i] == 0)   {}
            else
			{
                if(result[i] == 1)
					result[i] = 0;
                else
				{
                    int k = i;
                    while(k &lt; 128 &amp;&amp; result[k] == 0)
					{
						result[k] = 1;
						++k;
					}
                    if(k != 128)
						result[k] = 0;
                }
            }
        }

        return result;
    }
    friend int128 operator*(int128 const&amp; i1,int128 const&amp; i2)
	{
        if(i1==0 || i2==0)
			return int128();
        if(i1==1)
			return i2;
		if(i2==1)
			return i1;

        int128 acc=int128();

        for(int i=0;i&lt;128;++i)
		{
            if(i2[i]==1)
			{
                acc=acc+(i1&lt;&lt;i);
            }
        }

        return acc;
    }
    friend int128 operator/(int128 const&amp; i1,int128 const&amp; i2)
	{
        if(i1 &lt; i2)
			return int128();
        deque&lt;bool&gt; de;
        bool flag = 0;
        for(int i = 127 ; i &gt;= 0 ; --i)
		{
            if(flag == 0 &amp;&amp; i1[i] == 0)   {}
            else
			{
                flag = 1;
                de.push_back(i1[i]);
            }
        }

        int128 div = int128();
        int128 result = int128();

        while(!de.empty())
		{
            shift(div,de);
            if(div &lt; i2)
			{
                result = result&lt;&lt;1;
            }
            else
			{
                result = (result&lt;&lt;1) + int128(0,0,0,1);
                div = div - i2;
            }
        }

        return result;
    }
    friend int128 operator%(int128 const&amp; i1,int128 const&amp; i2)
	{
        if(i1 &lt; i2)
			return i1;
        deque&lt;bool&gt; de;
        bool flag = 0;
        for(int i = 127 ; i &gt;= 0 ; --i)
		{
            if(flag == 0 &amp;&amp; i1[i] == 0)   {}
            else
			{
                flag = 1;
                de.push_back(i1[i]);
            }
        }

        int128 div = int128();
        int128 result = int128();

        while(!de.empty())
		{
            shift(div,de);
            if(div &lt; i2)
			{
                result = result&lt;&lt;1;
            }
            else
			{
                result = (result&lt;&lt;1) + int128(0,0,0,1);
                div = div - i2;
            }
        }

        return div;
    }
    friend bool operator==(int128 const&amp; i,int const k)
	{
        bitset&lt;32&gt; bb(k);
        for(int g = 0 ; g &lt; 32 ; ++g)
		{
            if(i[g] != bb[g])
				return 0;
        }
        return 1;
    }
    void operator=(bitset&lt;128&gt;const&amp; b)
	{
        number = b;
    }
    friend ostream&amp; operator&lt;&lt;(ostream&amp; o,int128 const&amp; i)
	{
        o&lt;&lt;i.number;
        return o;
    }
    int128 operator&lt;&lt;(size_t step)const
	{
        return int128(number&lt;&lt;step);
    }
    unsigned long to_ulong()const
	{
		return *((unsigned long*)&amp;number);
    }

public:
	bool ToDecimalStr(std::string &amp;str)
	{
		str.clear();
		char buf[128] = {0};
		int128 Radix(0, 0, 0, 10);
		for(int128 num = number; !(num == 0); num = num/Radix)
		{
			if( sprintf_s(buf, 64, "%d", ((int)(num%Radix).to_ulong())) &lt; 0 )
			{
				return false;
			}
			str = buf + str;
		}
		return true;
	}

	static void Print(int128 &amp; data, bool bEndl = true)
	{
		string str;
		if( data.ToDecimalStr(str) )
		{
			printf("%s%s", str.c_str(), (bEndl?"\n":""));
		}
	}
};

static int128 const one = int128(0,0,0,1);

template&lt;size_t N&gt;
void add_one(bitset&lt;N&gt;&amp; b)
{
    int i = 0;
    while(i &lt; N &amp;&amp; b[i] == 1)
	{
        b[i] = 0;
        ++i;
    }
    if(i == N)
		return;
    b[i] = 1;
}

void add_one(int128&amp; k)
{
    int i = 0;
    while(i &lt; 128 &amp;&amp; k[i] == 1)
	{
        k[i] = 0;
        ++i;
    }
    if(i == 128)
		return;
    k[i] = 1;
}

void shift(int128 &amp; in,deque&lt;bool&gt; &amp; de)
{
    if(de.front()==1)
	{
        de.pop_front();
        in=(in&lt;&lt;1)+one;
    }
    else
	{
        de.pop_front();
        in=in&lt;&lt;1;
    }
}

bool IsPrime(int128 const&amp; number)
{
    for(int128 i = int128(0,0,0,2) ; i &lt; number ; add_one(i))
	{
        if(number%i == 0)
			return 0;
    }
    return 1;
}</pre>
<p>（7）对<span style="font-family: Verdana;">二叉树进行排序，排序后的结果为二叉排序树。<br/>
二叉排序树又称二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树：（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3）左、右子树也分别为二叉排序树；</span><br/>
<span style="font-family: Verdana; font-size: 14px;">struct STreeNode</span><br/>
<span style="font-family: Verdana; font-size: 14px;">{</span><br/>
<span style="font-family: Verdana; font-size: 14px;">int key;</span><br/>
<span style="font-family: Verdana; font-size: 14px;">STreeNode* left_child;</span><br/>
<span style="font-family: Verdana; font-size: 14px;">STreeNode* right_child;</span><br/>
<span style="font-family: Verdana; font-size: 14px;">};</span><br/>
<span style="font-family: Verdana; font-size: 14px;">//返回值为排序后的根节点</span><br/>
<span style="font-family: Verdana; font-size: 14px;">STreeNode* bt2bst(STreeNode* root_node)</span><br/>
<span style="font-family: Verdana; font-size: 14px;">{</span><br/>
<span style="font-family: Verdana; font-size: 14px;">}</span></p>
<pre class="brush:cpp ">struct STreeNode
{
	int key;
	STreeNode* left_child;
	STreeNode* right_child;
};

void InsertBST(STreeNode* t , int key)
{
    if(NULL == t)
    {
        t = new STreeNode; 
        t-&gt;left_child = t-&gt;right_child = NULL;
        t-&gt;key = key;
        return; 
    }

    if(key &lt; t-&gt;key) 
        InsertBST(t-&gt;left_child , key);
    else
        InsertBST(t-&gt;right_child , key ); 
}

//先序遍历树并插入建立排序树
void PreOrder(STreeNode* t , STreeNode* tBST)
{
   if(NULL != t)
   {
	   InsertBST(tBST , t-&gt;key);
	   PreOrder(t-&gt;left_child , tBST);
	   PreOrder(t-&gt;right_child , tBST);
   }
}

//目标函数
STreeNode* bt2bst(STreeNode* root_node)
{
    STreeNode* bstTreeRoot = NULL;
    PreOrder(root_node , bstTreeRoot);
    return bstTreeRoot;
}</pre>
<p><span style="font-family: Verdana; font-size: 14px;">二、扩展题<br/>
（1）列出几种你了解的IPC机制。<br/>
答：共享内存：是一片指定的物理内存区域，这个区域通常是在存放正常程序数据区域的外面, 它允许两个或多个进程共享一给定的存储区，是针对其他通信机制运行效率较低而设计的。使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。<br/>
信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。<br/>
套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上。<br/>
消息队列(MessageQueue)是一个结构化的排序内存段表，这个队列是进程存放或检索数据的地方，是一个消息的链表，可以被多个进程所共享。<br/>
（2）列举一种死锁发生的场景，并给出解决方案。<br/>
答：最经典的场景就是生产者/消费者，生产者线程生产物品，然后将物品放置在一个空缓冲区中供消费者线程消费。消费者线程从缓冲区中获得物品，然后释放缓冲区。由于生产者/消费者都在操作缓冲区，容易导致死锁的发生。<br/>
可以通过添加锁的保护来对缓冲区进行互斥的访问，保证某一时刻只有一个线程对缓冲区进行操作，当缓冲区满的时候，生产者线程就会挂起，同时通知消费者线程。而缓冲区空的时候，消费者线程就会挂起，同时通知生产者线程。<br/>
（3）列举编写一个TCP的服务器端程序可能需要用到的socket API，如果这些API的调用有先后关系，请按先后关系列出。<br/>
（4）举例说明什么是MVC。<br/>
答：MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。<br/>
视图是用户看到并与之交互的界面。对老式的Web应用程序来说，视图就是由HTML元素组成的界面，在新式的Web应用程序中，HTML依旧在视图中扮演着重要的角色，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。<br/>
模型表示企业数据和业务规则。在MVC的三个部件中，模型拥有最多的处理任务。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。<br/>
控制器接受用户的输入并调用模型和视图去完成用户的需求。所以当单击Web页面中的超链接和发送HTML表单时，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后用确定用哪个视图来显示模型处理返回的数据。</span></p>
<p>转载请标明出处，原文地址：<a href="http://blog.csdn.net/hackbuteer1/article/details/11473405" target="_blank">http://blog.csdn.net/hackbuteer1/article/details/11473405</a></p>
<p>转自：http://blog.csdn.net/hackbuteer1/article/details/11473405</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-21443">
<article class="comment" id="comment-21443">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">slowlight</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21443" rel="nofollow"><time datetime="2015-07-04T04:11:21+00:00" pubdate="">2015年7月4日 at 上午4:11</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>抱歉，确实是弄错了，原来的代码是错误的，删掉了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21444">
<article class="comment" id="comment-21444">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wkhuahuo</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21444" rel="nofollow"><time datetime="2015-06-19T03:11:10+00:00" pubdate="">2015年6月19日 at 上午3:11</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>问题3是不是应该为1/4  .因为截取的三段，无论是否能组成三角形， x， y-x ，1-y,都应大于0，所以  x&lt;y,基础应该是一个大三角形。小三角是大三角的 1/4.</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21442">
<article class="comment" id="comment-21442">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">xiaoliubuer</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21442" rel="nofollow"><time datetime="2014-10-01T09:35:04+00:00" pubdate="">2014年10月1日 at 上午9:35</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>51行错了，改为：void Union(struct subset subsets[], int x, int y)</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21447">
<article class="comment" id="comment-21447">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">hanyi</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21447" rel="nofollow"><time datetime="2014-09-05T13:10:26+00:00" pubdate="">2014年9月5日 at 下午1:10</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第36行，struct node **head_ref，怎么理解，那个函数感觉不是很懂啊！？？弱渣求助</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21445">
<article class="comment" id="comment-21445">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">userwawa</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21445" rel="nofollow"><time datetime="2014-07-26T23:24:07+00:00" pubdate="">2014年7月26日 at 下午11:24</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>学习了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21448">
<article class="comment" id="comment-21448">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">April</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21448" rel="nofollow"><time datetime="2014-06-12T07:55:02+00:00" pubdate="">2014年6月12日 at 上午7:55</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>居然看懂了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21450">
<article class="comment" id="comment-21450">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">hunangangli</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21450" rel="nofollow"><time datetime="2014-05-02T19:36:03+00:00" pubdate="">2014年5月2日 at 下午7:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这个也是算法导论的习题</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21446">
<article class="comment" id="comment-21446">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">magicSky</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21446" rel="nofollow"><time datetime="2014-04-26T00:08:10+00:00" pubdate="">2014年4月26日 at 上午12:08</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第36行，struct node **head_ref，怎么理解，那个函数感觉不是很懂啊！？？弱渣求助</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-44995">
<article class="comment" id="comment-44995">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">litao</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-44995" rel="nofollow"><time datetime="2014-04-08T06:42:18+00:00" pubdate="">2014年4月8日 at 上午6:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>2的64次方是多少？ 这到底是在考什么啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21449">
<article class="comment" id="comment-21449">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">zrw</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-21449" rel="nofollow"><time datetime="2014-04-04T07:18:00+00:00" pubdate="">2014年4月4日 at 上午7:18</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很有意思，可惜我很菜啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-132">
<article class="comment" id="comment-132">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn">会飞的鱼</span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-132" rel="nofollow"><time datetime="2014-01-08T00:45:18+00:00" pubdate="">2014年1月8日 at 上午12:45</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第一句可以忽略不计了吧。从第二句开始分析，说明这个花色下的所有牌都会在其它里面出现，那么还剩下♠️和♦️。第三句，可以排除2和7，因为在两种花色里有。现在是第四句，因为♠️还剩下多个，只有是♦️B才能知道答案。</p>
</div>
</article><!-- #comment-## -->
<ul class="children">
<li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-136">
<article class="comment" id="comment-136">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.acmerblog.com/" rel="external nofollow">从此醉</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-136" rel="nofollow"><time datetime="2014-01-10T12:56:55+00:00" pubdate="">2014年1月10日 at 下午12:56</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>分析的很专业！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
<li class="comment even thread-odd thread-alt depth-1" id="li-comment-81">
<article class="comment" id="comment-81">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn">会飞的鱼</span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-81" rel="nofollow"><time datetime="2014-01-08T00:45:18+00:00" pubdate="">2014年1月8日 at 上午12:45</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第一句可以忽略不计了吧。从第二句开始分析，说明这个花色下的所有牌都会在其它里面出现，那么还剩下♠️和♦️。第三句，可以排除2和7，因为在两种花色里有。现在是第四句，因为♠️还剩下多个，只有是♦️B才能知道答案。</p>
</div>
</article><!-- #comment-## -->
<ul class="children">
<li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-85">
<article class="comment" id="comment-85">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.acmerblog.com/" rel="external nofollow">从此醉</a></span> on <a href="http://www.acmerblog.com/interview-pps-3414.html#comment-85" rel="nofollow"><time datetime="2014-01-10T12:56:55+00:00" pubdate="">2014年1月10日 at 下午12:56</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>分析的很专业！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ol>