<div class="c-top2" id="post-55">
<div class="datetime">2014<br/>01-28</div>
<div class="tit"><h1 class="entry-title">UVa-129-Krypton Factor[DFS]</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/search/dfs" rel="category tag" title="查看DFS搜索中的全部文章">DFS搜索</a>, <a href="http://www.acmerblog.com/category/problemset/uva" rel="category tag" title="查看UVA中的全部文章">UVA</a></span><span class="i4">围观686次</span><span class="i3"><a class="ds-thread-count" data-thread-key="3809" href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comments" title="《UVa-129-Krypton Factor[DFS]》上的评论">15 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<p>Time limit: 3.000 seconds<br/><span style="color: #888888;">限时：3.000秒</span></p>
<h2>Problem<br/><span style="color: #888888;">问题</span></h2>
<p>You have been employed by the organisers of a Super Krypton Factor Contest in which contestants have very high mental and physical abilities. In one section of the contest the contestants are tested on their ability to recall a sequence of characters which has been read to them by the Quiz Master. Many of the contestants are very good at recognising patterns. Therefore, in order to add some difficulty to this test, the organisers have decided that sequences containing certain types of repeated subsequences should not be used. However, they do not wish to remove all subsequences that are repeated, since in that case no single character could be repeated. This in itself would make the problem too easy for the contestants. Instead it is decided to eliminate all sequences containing an occurrence of two adjoining identical subsequences. Sequences containing such an occurrence will be called “easy”. Other sequences will be called “hard”.<br/><span style="color: #888888;">“超级氪因素大赛”(译注：英国的一档电视心智竞答节目）的</span><span style="color: #888888;">主办方雇</span><span style="color: #888888;">你来对付那些足智多谋的参赛选手。在比赛的一个环节中，节目主持人将念出一长串的字母来考验选手的记忆能力。因为许多选手都是分析字串模式的高手，为了增加一些比赛的难度，主办方决定不再使用那些含有特定重复子串的字串。但是他们又不能将所有重复的子串都删掉，如果那样的话字串中就不存在两个相同的单字了，这反倒会让问题变的非常简单。为了解决这一问题，他们决定仅删除那些包含相邻重复子串的字串。我们将存在上述相邻重复情况的字串称为“easy”（简单），否则称为“hard”（难）。</span></p>
<p>For example, the sequence ABACBCBAD is easy, since it contains an adjoining repetition of the subsequence CB. Other examples of easy sequences are:<br/><span style="color: #888888;">比方说，字串ABACBCBAD就是一个“easy”，因为它里面有相邻的重复子串“CB”。另举一些“easy”字串的例子如下：</span></p>
<ul>
<li>BB</li>
<li>ABCDACABCAB</li>
<li>ABCDABCD </li>
</ul>
<p>Some examples of hard sequences are:<br/><span style="color: #888888;">下面是一个“hard”字串的例子：</span></p>
<ul>
<li>D</li>
<li>DC</li>
<li>ABDAB</li>
<li>CBABCBA </li>
</ul>
<p> </p>
<h2>Input and Output<br/><span style="color: #888888;">输入和输出</span></h2>
<p>In order to provide the Quiz Master with a potentially unlimited source of questions you are asked to write a program that will read input lines that contain integers n and L (in that order), where n &gt; 0 and L is in the range 1 ≤ L ≤ 26, and for each input line prints out the nth hard sequence (composed of letters drawn from the first L letters in the alphabet), in increasing alphabetical order (alphabetical ordering here corresponds to the normal ordering encountered in a dictionary), followed (on the next line) by the length of that sequence. The first sequence in this ordering is A. You may assume that for given n and L there do exist at least n hard sequences.<br/><span style="color: #888888;">为了能给节目主持人提供无限量的问题字串，</span><span style="color: #888888;">要求</span><span style="color: #888888;">你来写一个程序执行生成运算。程序从输入中读取多行数据，每行包括两个整数n和L（即按此顺序给出），其中n &gt; 0，L的范围是1 ≤ L ≤ 26。根据这些输入，程序要按照字母表升序打印出第n个“hard”字串（由字母表中的前L个字母构成），并在接下来的一行打印这个串的长度。按照上述规则，第一个串应该是“A”。对于给定的n和L，你可以认为第n个“hard”串是一定存在的。</span></p>
<p>For example, with L = 3, the first 7 hard sequences are:<br/><span style="color: #888888;">比方说，当L = 3时，头7个“hard”字串为：</span></p>
<p style="margin-left: 2em;">A<br/>AB<br/>ABA<br/>ABAC<br/>ABACA<br/>ABACAB<br/>ABACABA </p>
<p>As each sequence is potentially very long, split it into groups of four (4) characters separated by a space. If there are more than 16 such groups, please start a new line for the 17th group.<br/><span style="color: #888888;">字串可能很长，因此要将它们分成4个字为一组，中间用空格隔开。如果超过16组，则换一行，再接着输出第17组。</span></p>
<p>Therefore, if the integers 7 and 3 appear on an input line, the output lines produced should be: </p>
<p><span style="color: #888888;">按照此格式，对于输入的整数7和3，输出应该为：</span></p>
<p>ABAC ABA<br/>7</p>
<p>Input is terminated by a line containing two zeroes. Your program may assume a maximum sequence length of 80.<br/><span style="color: #888888;">输入由一行两个零表示结束。你的程序可以限定最大的字串长度为80。</span></p>
<p> </p>
<h2></h2>
<h2>Sample Input<br/><span style="color: #888888;">输入示例</span></h2>
<p>30 3<br/>0 0</p>
<h2></h2>
<h2>Sample Output<br/><span style="color: #888888;">输出示例</span></h2>
<p>ABAC ABCA CBAB CABA CABC ACBA CABA<br/>28</p>
<p> </p>
<h2>Analysis<br/><span style="color: #888888;">分析</span></h2>
<p>很经典的递归调用过程，难度适中，推荐先认真的做一下再来看解析。题目本身不是很好懂，需要认真思考才能明白其意图。</p>
<p>避免相邻重复的子串很好办：如果生成字符串是逐个在后面添加字符的话，只要每次在添加后检查当前串是否满足条件就可以了。不满足的不能添加，这样就能保证字符串里没有任何相邻重复的子串。检查的方法是从长度1开始，检查最后1个字符及其前面1个字符是否相等，再将长度增为2，检查最后2个字符及其前面2个字符是否相等，以此类推。</p>
<p>题目要求按字母表顺序生成字串，通过观查给出的例子(7 3)可知字串都是以A开始，逐个向后生成。每次在末尾添加一个尽量靠前的（在ASCII表中较小的）又可以满足要求的字母，如果都不满足要求则向前回溯，将前一个字母增大再试。每次成功的添加一个都算作生成了一个字串。直到生成的字串数达到给定的数量n。</p>
<p>思路理清后代码就很容易写了，算是一个小程序。有一点要注意，输出时一定要按照要求的格式，每过四个字符加一个空格，达到4×16的字符后不要加空格，而要加一个回车。后面的仍是每过四个加一个空格。千万注意！</p>
<p> </p>
<h2>Solution<br/><span style="color: #888888;">解答</span></h2>
<pre class="brush:cpp ">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
//递归过程，顺序生成所有的字串。str保存结果，n和L为题目中给出的同名变量
void Sequence(string &amp;str, int &amp;n, int L) {
	//记录字串长度，以加快运算
	int nLen = str.length(), nHalf = (str.length() + 1) / 2;
	//在结果字串后面依次尝试添加前L个大写字母
	for (char i = 'A', iEnd = L + 'A', m = 1; i &lt; iEnd; ++i) {
		str.push_back(i); //插入当前字符
		//下面判断新生成的字符串中是否存在相邻的重复
		//第1次判断最后1个字符，第2次判断最后2个字符，以此类推
		for (m = 1; m &lt;= nHalf; ++m) {
			//将最后的i个字符与之前的i个字符比较，如果有相同则跳出
			if (equal(str.end() - m, str.end(), str.end() - m * 2)) {
				m = 0; //将m置为0表示存在重复的相邻子串
				break; //跳出循环
			}
		}
		if (m != 0) { //如果不存在重复
			//如果生成的字串已经够数，返回上一级
			if (--n == 0) return;
			Sequence(str, n, L); //进入下一级调用
			//如果生成的字串已经够数，返回上一级
			if (n == 0) return;
		} //删除刚添加在后面的字符，保持结果字串在进入这一级时的原状
		str.erase(nLen); //准备为添加下一个字符作准备
	}
}
//主函数
int main(void) {
	for (int n, L; cin &gt;&gt; n &gt;&gt; L &amp;&amp; n != 0; ) { //循环读取每一组输入的数据
		string str; //结果字符串
		Sequence(str, n, L); //递归生成所有的无相邻重复字串
		int nLen = str.length(); //保留生成字串的字符数量
		for (size_t i = 4; i &lt; str.length(); i += 5) { //按格式处理字串
			//每隔4个插入一个空格，每隔80字符插入一个回车
			str.insert(str.begin() + i, i == 79 ? '\n' : ' ');
		} //输出结果字串和字符数量
		cout &lt;&lt; str &lt;&lt; '\n' &lt;&lt; nLen &lt;&lt; endl;
	}
	return 0;
}</pre>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-84389">
<article class="comment" id="comment-84389">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919463752" rel="external nofollow">新用户643560</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-84389" rel="nofollow"><time datetime="2017-04-12T23:52:08+00:00" pubdate="">2017年4月12日 at 下午11:52</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>小黑们真是阴魂不散啊～都快死了还要来污染中国</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-22442">
<article class="comment" id="comment-22442">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yunyang088</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-22442" rel="nofollow"><time datetime="2015-06-25T18:53:38+00:00" pubdate="">2015年6月25日 at 下午6:53</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>和编译器有关吧，我用的g++正常。头文件可能还需要一个&lt;string.h&gt;</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-22443">
<article class="comment" id="comment-22443">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">la0bei</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-22443" rel="nofollow"><time datetime="2015-06-06T09:24:02+00:00" pubdate="">2015年6月6日 at 上午9:24</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的方法，学习了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45433">
<article class="comment" id="comment-45433">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">xin</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-45433" rel="nofollow"><time datetime="2015-04-24T09:35:56+00:00" pubdate="">2015年4月24日 at 上午9:35</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>m /= i; 是一直在变的。参考这一篇关于质因数的http://www.acmerblog.com/integer-factorization-5124.html</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-22446">
<article class="comment" id="comment-22446">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">nsoi_onion</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-22446" rel="nofollow"><time datetime="2015-03-30T21:26:13+00:00" pubdate="">2015年3月30日 at 下午9:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>程序员会算法，等于一个古惑仔带了zhi抢啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-22447">
<article class="comment" id="comment-22447">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">litaotao</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-22447" rel="nofollow"><time datetime="2015-03-14T17:49:00+00:00" pubdate="">2015年3月14日 at 下午5:49</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>原来的主机不行，目前更换到了国内主机</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45436">
<article class="comment" id="comment-45436">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">AcmDream</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-45436" rel="nofollow"><time datetime="2015-02-22T21:06:23+00:00" pubdate="">2015年2月22日 at 下午9:06</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>题目需要求解的是最小值，而且没有考虑可能存在环，比如<br/>
0 0 0 0 0<br/>
1 1 1 1 0<br/>
1 0 0 0 0<br/>
1 0 1 0 1<br/>
1 0 0 0 0<br/>
会陷入死循环</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45437">
<article class="comment" id="comment-45437">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">sum_tsai</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-45437" rel="nofollow"><time datetime="2015-02-12T09:05:48+00:00" pubdate="">2015年2月12日 at 上午9:05</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>多谢指出，已改正</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-22445">
<article class="comment" id="comment-22445">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">ycaxgjd</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-22445" rel="nofollow"><time datetime="2014-11-28T22:37:55+00:00" pubdate="">2014年11月28日 at 下午10:37</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>…. 配图居然是没方向的。。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45432">
<article class="comment" id="comment-45432">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">dongxi</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-45432" rel="nofollow"><time datetime="2014-11-13T12:15:24+00:00" pubdate="">2014年11月13日 at 下午12:15</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p><a href="https://coding.net/moon/miracle" rel="nofollow">https://coding.net/moon/miracle</a></p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45434">
<article class="comment" id="comment-45434">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">pascal</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-45434" rel="nofollow"><time datetime="2014-11-12T00:50:39+00:00" pubdate="">2014年11月12日 at 上午12:50</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>程序输出是对的，呈三角型。原程序是按C++写的，已经改成了C的</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45435">
<article class="comment" id="comment-45435">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">MyHome</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-45435" rel="nofollow"><time datetime="2014-09-02T10:44:17+00:00" pubdate="">2014年9月2日 at 上午10:44</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>Java真是解决大数的利器</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-62624">
<article class="comment" id="comment-62624">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">tufei</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-62624" rel="nofollow"><time datetime="2014-07-08T21:34:17+00:00" pubdate="">2014年7月8日 at 下午9:34</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>华为这题目略显简单啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-22448">
<article class="comment" id="comment-22448">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Lint</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-22448" rel="nofollow"><time datetime="2014-05-26T17:11:41+00:00" pubdate="">2014年5月26日 at 下午5:11</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第二种想法，我想来好久，为啥需要一个newhead，发现是把最后一个节点一直返回到嘴上面这层函数。厉害，这道题之前没样子想过。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-22444">
<article class="comment" id="comment-22444">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">la0bei</a></span> on <a href="http://www.acmerblog.com/uva-129-krypton-factor-3809.html#comment-22444" rel="nofollow"><time datetime="2014-04-25T21:59:23+00:00" pubdate="">2014年4月25日 at 下午9:59</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>afsasfasfasf</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>