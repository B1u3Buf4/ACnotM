<div class="c-top2" id="post-55">
<div class="datetime">2014<br/>01-03</div>
<div class="tit"><h1 class="entry-title">动态规划</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/zhuanti/algorithm" rel="category tag" title="查看算法分析中的全部文章">算法分析</a></span><span class="i4">围观1614次</span><span class="i3"><a class="ds-thread-count" data-thread-key="3376" href="http://www.acmerblog.com/article-np-3376.html#comments" title="《动态规划》上的评论">14 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<p><strong>动态规划</strong><strong> </strong></p>
<p><strong>算法总体思想</strong><strong> </strong></p>
<p>动态规划算法与分治法类似，其基本思想也是将<span style="color: #ff0000;">待求解问题分解成若干个子问题</span>。</p>
<p><img alt="" height="162" src="http://cdn.acmerblog.com/img/1388749251848.jpg" width="416"/></p>
<p>但是经分解得到的<span style="color: #ff0000;">子问题往往不是互相独立</span>的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</p>
<p><img alt="" height="180" src="http://cdn.acmerblog.com/img/1388749251998.jpg" width="419"/></p>
<p>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。</p>
<p><img alt="" height="211" src="http://cdn.acmerblog.com/img/1388749252196.jpg" width="423"/></p>
<p>动态规划基本步骤:</p>
<p><span style="color: #0000ff;">(1)找出最优解的性质，并刻划其结构特征。</span></p>
<p><span style="color: #0000ff;">(2)递归地定义最优值。</span></p>
<p><span style="color: #0000ff;">(3)以自底向上的方式计算出最优值。</span></p>
<p><span style="color: #0000ff;">(4)根据计算最优值时得到的信息，构造最优解。</span></p>
<p><strong>实例一、完全加括号的矩阵连乘积</strong><strong> </strong></p>
<p><strong>问题可递归定义：</strong><strong> </strong></p>
<p>（1）单个矩阵是完全加括号的；</p>
<p>（2）矩阵连乘积A是完全加括号的 ，则A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即 A = （BC）。</p>
<p>设有四个矩阵A,B,C,D它们的维数分别是: A = 50*10 , B = 10*40 , C = 40*30 , D = 30*5 </p>
<p>总共有五中完全加括号的方式：</p>
<p><img alt="" src="http://cdn.acmerblog.com/img/1388749252335.jpg"/></p>
<p> </p>
<p>例如：((A(BC))D): 10 * 40 * 30 + 10 * 30 * 50 + 50 * 30 * 5 = 34500</p>
<p>    给定矩阵{A1, A2, A3,…, An}，其中Ai与A(i+1)是可乘的。i = 1,2,3, …, n – 1。考察这n个矩阵的连乘积A1*A2*A3…An.</p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已完全加括号，则可以依此次序反复调用</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">2</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">个矩阵相乘的标准算法计算出矩阵连乘积。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p><strong>矩阵连乘问题</strong><strong> </strong></p>
<p>    给定矩阵{A1, A2, A3,…, An}，其中Ai与A(i+1)是可乘的。i = 1,2,3, …, n – 1。考察这n个矩阵的连乘积A1*A2*A3…An. 如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少.</p>
<p><strong>穷举法</strong>：列举出所有可能的计算次序，并计算出每一种计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序。</p>
<p>算法复杂度分析：</p>
<p>对于n个矩阵的连乘积，设其不同的计算次序为P(n)</p>
<p>由于每种加括号方式都可以分解为两个子矩阵的加括号问题</p>
<p>(A1…Ak)(A(k+1)…An)可以得到关于P(n)的递推式如下：</p>
<p><img alt="" src="http://cdn.acmerblog.com/img/1388749252467.jpg"/></p>
<p><strong>动态规划</strong>：将矩阵连乘积A(i)A(i+1)…A(j)简记为A[i:j]，这里 i &lt;= j。</p>
<p>考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵A(k)和A(k+1)之间将矩阵链断开，i &lt;= k &lt; j, 则其相应完全加括号方式为(A(i)A(i+1)…A(k)) * (A(k+1)A(k+2)…A(j))。</p>
<p>计算量：A[i:k]的计算量加上A[k+1,j]，再加上A[i:k] * A[k+1][j]的计算量。</p>
<p><strong>分析最优解的结构</strong><strong> </strong></p>
<p>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。</p>
<p>矩阵连乘计算次序问题的<span style="color: #ff0000;">最优解包含着其子问题的最优解</span>。这种性质称为<strong>最优子结构性质</strong>。<span style="text-decoration: underline;">问题的最优子结构性质是该问题可用动态规划算法求解的显著特征</span>。</p>
<p><strong>建立递归关系</strong><strong> </strong></p>
<p>设计算A[i:j]，1 &lt;= i &lt;= j &lt;= n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n] </p>
<p>当i = j时，A[i:j]=Ai，因此，m[i,i] = 0，i = 1,2,…,n</p>
<p>当i &lt; j时，m[i,j] = m[i,k] + m[k+1,j] + p(i-1)p(k)p(j)</p>
<p>这里A(i)的维数为p(i-1)*(i)(注：p(i-1)为矩阵A(i)的行数，p(i)为矩阵A[i]的列数)</p>
<p><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">可以递归地定义</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">m[i,j]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">为：</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p><img alt="" height="71" src="http://cdn.acmerblog.com/img/1388749252682.jpg" width="367"/></p>
<p>k的位置只有j – i种。</p>
<p><strong>计算最优值</strong><strong> </strong></p>
<p>对于1 &lt;= i &lt;= j &lt;= n不同的有序对(i,j)对应于不同的子问题。因此，不同子问题的个数最多只有：</p>
<p><img alt="" height="77" src="http://cdn.acmerblog.com/img/1388749252849.jpg" width="393"/></p>
<p>（大括号表示C(n,2)，组合的意思。后面的符号表示 “紧渐近界记号”）</p>
<p>但是，在递归计算时，许多子问题被重复计算多次。这也是该问题可用动态规划算法求解的又一显著特征。</p>
<p>用动态规划算法解此问题，可依据其递归式以自底向上的方式进行计算。在计算过程中，保存已解决的子问题答案。每个子问题只计算一次，而在后面需要时只要简单查一下，从而避免大量的重复计算，最终得到多项式时间的算法。</p>
<p><strong>用动态规划法求最优解</strong><strong> </strong></p>
<p>连乘矩阵假如为：</p>
<p><img alt="" height="73" src="http://cdn.acmerblog.com/img/1388749253016.jpg" width="447"/></p>
<p>计算过程为：</p>
<p><img alt="" height="189" src="http://cdn.acmerblog.com/img/1388749253196.jpg" width="551"/></p>
<p>从m可知最小连乘次数为m[1][6] = 15125</p>
<p>从s可知计算顺序为((A1(A2A3))((A4A5))A6))</p>
<p>实现：</p>
<p> </p>
<pre class="brush:cpp ">/* 主题：矩阵连乘问题
* 作者：chinazhangjie
* 邮箱：chinajiezhang@gmail.com
* 开发语言：C++
* 开发环境：Mircosoft Virsual Studio 2008
* 时间: 2010.11.14
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std ;

class matrix_chain
{
public:
    matrix_chain(const vector&lt;int&gt; &amp; c) {
        cols = c ;
        count = cols.size () ;
        mc.resize (count) ;
        s.resize (count) ;
        for (int i = 0; i &lt; count; ++ i) {
            mc[i].resize (count) ;
            s[i].resize (count) ;
        }
        for (int i = 0; i &lt; count; ++ i) {
            for (int j = 0; j &lt; count; ++ j) {
                mc[i][j] = 0 ;
                s[i][j] = 0 ;
            }
        }
    }

    // 使用备忘录方法计算
    void lookup_chain () {
        __lookup_chain (1, count - 1) ;
        min_count = mc[1][count - 1] ;
        cout &lt;&lt; "min_multi_count = "&lt;&lt; min_count &lt;&lt; endl ;
        // 输出最优计算次序
        __trackback (1, count - 1) ;
    }

    // 使用普通方法进行计算
    void calculate () {
        int n = count - 1; // 矩阵的个数
        // r 表示每次宽度
        // i,j表示从从矩阵i到矩阵j
        // k 表示切割位置
        for (int r = 2; r &lt;= n; ++ r) {
            for (int i = 1; i &lt;= n - r + 1; ++ i) {
                int j = i + r - 1 ;
                // 从矩阵i到矩阵j连乘，从i的位置切割，前半部分为0
                mc[i][j] = mc[i+1][j] + cols[i-1] * cols[i] * cols[j] ;
                s[i][j] = i ;
                for (int k = i + 1; k &lt; j; ++ k) {
                    int temp = mc[i][k] + mc[k + 1][j] + 
                        cols[i-1] * cols[k] * cols[j] ;
                    if (temp &lt; mc[i][j]) {
                        mc[i][j] = temp ;
                        s[i][j] = k ;
                    }
                } // for k
            } // for i
        } // for r
        min_count = mc[1][n] ;
        cout &lt;&lt; "min_multi_count = "&lt;&lt; min_count &lt;&lt; endl ;
        // 输出最优计算次序
        __trackback (1, n) ;

    }

private:
    int __lookup_chain (int i, int j) {
        // 该最优解已求出，直接返回
        if (mc[i][j] &gt; 0) {
            return mc[i][j] ;
        }
        if (i == j) {
            return 0 ;    // 不需要计算，直接返回
        }

        // 下面两行计算从i到j按照顺序计算的情况
        int u = __lookup_chain (i, i) + __lookup_chain (i + 1, j) 
            + cols[i-1] * cols[i] * cols[j] ;
        s[i][j] = i ;
        for (int k = i + 1; k &lt; j; ++ k) {
            int temp = __lookup_chain(i, k) + __lookup_chain(k + 1, j) 
                + cols[i - 1] * cols[k] * cols[j] ;
            if (temp &lt; u) {
                u = temp ;
                s[i][j] = k ;
            }
        }
        mc[i][j] = u ;
        return u ;
    } 

    void __trackback (int i, int j) {
        if (i == j) { 
            return ; 
        }
        __trackback (i, s[i][j]) ;
        __trackback (s[i][j] + 1, j) ;
        cout &lt;&lt;i &lt;&lt; "," &lt;&lt; s[i][j] &lt;&lt; " " &lt;&lt; s[i][j] + 1 &lt;&lt; "," &lt;&lt; j &lt;&lt; endl; 
    }

private:
    vector&lt;int&gt;    cols ;    // 列数
    int            count ;    // 矩阵个数  + 1
    vector&lt;vector&lt;int&gt; &gt;    mc;    // 从第i个矩阵乘到第j个矩阵最小数乘次数
    vector&lt;vector&lt;int&gt; &gt;    s;    // 最小数乘的切分位置
    int            min_count ;        // 最小数乘次数
} ;

int main() 
{
    // 初始化
    const int MATRIX_COUNT = 6 ;
    vector&lt;int&gt;    c(MATRIX_COUNT + 1) ;
    c[0] = 30 ;
    c[1] = 35 ;
    c[2] = 15 ;
    c[3] = 5 ;
    c[4] = 10 ;
    c[5] = 20 ;
    c[6] = 25 ;

    matrix_chain mc (c) ;
    // mc.calculate () ;
    mc.lookup_chain () ;
    return 0 ;
}</pre>
<p> </p>
<p> </p>
<p><strong>算法复杂度分析：</strong><strong> </strong></p>
<p>算法matrixChain的主要计算量取决于算法中对r，i和k的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3)。因此算法的计算时间上界为O(n^3)。算法所占用的空间显然为O(n^2)。</p>
<p><strong>动态规划算法的基本要素</strong><strong> </strong></p>
<p><strong>一、最优子结构</strong><strong> </strong></p>
<p>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。</p>
<p>在分析问题的最优子结构性质时，所用的方法具有普遍性：首先假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾。 </p>
<p>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。</p>
<p>同一个问题可以有多种方式刻划它的最优子结构，有些表示方法的求解速度更快（空间占用小，问题的维度低）</p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">二、重叠子问题</span></strong></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;"> </span></strong><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为<strong style="mso-bidi-font-weight: normal;"><span style="color: red;">子问题的重叠性质</span></strong>。</span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;"> </span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"> </span></p>
<p><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式时间，从而获得较高的解题效率。</span></p>
<p><strong>三、备忘录方法</strong></p>
<p>备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。</p>
<p>实现（见矩阵连乘源码）</p>
<p><strong>实例二、最长公共子序列</strong><strong> </strong></p>
<p>    若给定的序列X = {x1,x2,…,xm},则另一序列Z = {z1,z2,…,zk}，是X的子序列是指<span style="color: #0000ff;">存在一个严格下表序列{i1,i2,…,ik}使得对于所有的j = 1,2,…k有zj = xij</span>。例如，序列Z = {B,C,D,B}是序列X = {A,B,C,B,D,A,B}的子序列，相应的递增下标序列为{2,3,5,7}。</p>
<p>给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的<span style="color: #ff0000;">公共子序列</span>。</p>
<p><span style="color: #ff0000;">问题表述：给定2个序列X={x1,x2,…,xm}和Y = {y1,y2,…,yn}，找出X和Y的最长公共子序列。</span></p>
<p><strong>最长公共子序列的结构</strong><strong> </strong></p>
<p>设序列X = {x1,x2,…,xm}和Y = {y1,y2,…,yn}的最长公共子序列为Z = {z1,z2,…,zk} ，则</p>
<p>(1)若xm = yn，则zk = xm = yn，且z(k-1)是x(m-1)和y(n-1)的最长公共子序列。</p>
<p>(2)若xm != yn且zk != xm，则Z是x(m-1)和Y的最长公共子序列。</p>
<p>(3)若xm != yn且zk != yn，则Z是X和y(n-1)的最长公共子序列。</p>
<p><span style="color: #0000ff;">由此可见，2个序列的最长公共子序列包含了这2个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有<span style="text-decoration: underline;">最优子结构性质</span>。 </span></p>
<p><strong>子问题的递归结构</strong><strong> </strong></p>
<p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i][j]记录序列Xi和Yi的最长公共子序列的长度。其中， Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i = 0或j = 0时，空序列是Xi和Yj的最长公共子序列。故此时C[i][j] = 0。其它情况下，由最优子结构性质可建立递归关系如下： </p>
<p><img alt="" height="85" src="http://cdn.acmerblog.com/img/1388749253461.jpg" width="501"/></p>
<p>由于在所考虑的子问题空间中，总共有θ(mn)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率</p>
<p><strong>计算最优值和构造最长公共子序列（见源码）</strong><strong> </strong></p>
<p><strong>实现：</strong><strong> </strong></p>
<div><strong> </strong></div>
<p><strong>
</strong></p>
<pre class="brush:cpp ">/* 主题：最长公共子序列
* 作者：chinazhangjie
* 邮箱：chinajiezhang@gmail.com
* 开发语言：C++
* 开发环境：Microsoft Visual Studio 2008
* 时间: 2010.11.14
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std ;

// longest common sequence
class LonComSequence
{
public:
    typedef vector&lt;vector&lt;int&gt; &gt;    LCS_Type ;
    typedef vector&lt;vector&lt;int&gt; &gt;    MarkType ;

public:
    LonComSequence (const vector&lt;char&gt;&amp; vSeq1,
                    const vector&lt;char&gt;&amp; vSeq2) 
        : mc_nEqual (1), mc_nSq1move(2), mc_nSq2move(3)
    {
        m_vSeq1 = vSeq1 ;
        m_vSeq2 = vSeq2 ;
        m_nLen1 = vSeq1.size() ;
        m_nLen2 = vSeq2.size() ;

        // 初始化最长公共子序列的长度
        m_lcsLen.resize (m_nLen1 + 1) ;
        m_mtMark.resize (m_nLen1 + 1) ;
        for (int i = 0; i &lt; m_nLen1 + 1; ++ i) {
            m_lcsLen[i].resize (m_nLen2 + 1) ;
            m_mtMark[i].resize (m_nLen2 + 1) ;
        }
    }

    // 计算最长公共子序列的长度
    int calLcsLength ()    
    {
        for (int i = 1; i &lt;= m_nLen1; ++ i) {
            m_lcsLen[i][0] = 0 ; // 序列二的长度为0，公共子序列的长度为0
        } 
        for (int i = 1; i &lt;= m_nLen2; ++ i) {
            m_lcsLen[0][i] = 0 ; // 序列一的长度为0，公共子序列的长度为0
        }
    
        for (int i = 0; i &lt; m_nLen1; ++ i) {
            for (int j = 0; j &lt; m_nLen2; ++ j) {
                if (m_vSeq1[i] == m_vSeq2[j]) {
                    m_lcsLen[i+1][j+1] = m_lcsLen[i][j] + 1 ;
                    m_mtMark[i+1][j+1] = mc_nEqual ;
                }
                else if (m_lcsLen[i][j+1] &gt;= m_lcsLen[i+1][j]) {
                    m_lcsLen[i+1][j+1] = m_lcsLen[i][j+1] ;
                    m_mtMark[i+1][j+1] = mc_nSq1move ;
                }
                else {
                    m_lcsLen[i+1][j+1] = m_lcsLen[i+1][j] ;
                    m_mtMark[i+1][j+1] = mc_nSq2move ;
                }
            }
        }
        return m_lcsLen[m_nLen1][m_nLen2] ;
    }
    // 构造最长公共子序列
    void LCS() {
        cout &lt;&lt; "LCS is : " ;
        __LCS(m_nLen1, m_nLen2);
        cout &lt;&lt; endl ;
    }

private:
    void __LCS (int i, int j) 
    {
        if (i == 0 || j == 0) {
            return ;
        }

        if (m_mtMark[i][j] == mc_nEqual) {
            __LCS (i - 1, j - 1) ;
            cout &lt;&lt; m_vSeq1[i - 1] &lt;&lt; " " ;
        }
        else if (m_mtMark[i][j] == mc_nSq1move) {
            __LCS (i - 1, j) ;
        }
        else {
            __LCS (i, j - 1) ;
        }
    }

private:
    vector&lt;char&gt;    m_vSeq1 ;    // 序列一
    vector&lt;char&gt;    m_vSeq2 ;    // 序列二
    int                m_nLen1 ;    // 序列一的长度
    int                m_nLen2 ;    // 序列二的长度
    LCS_Type        m_lcsLen ;    // 最长公共子序列的长度
    MarkType        m_mtMark ;    // 记录m_lcsLen
    const int mc_nEqual ;        // 相等的标志
    const int mc_nSq1move ;        // 序列一左移的标志
    const int mc_nSq2move ;        // 序列二左移的标志
} ;


int main()
{
    vector&lt;char&gt; s1 ; 
    s1.push_back ('A') ;
    s1.push_back ('B') ;
    s1.push_back ('C') ;
    s1.push_back ('D') ;
    s1.push_back ('E') ;
    s1.push_back ('F') ;

    vector&lt;char&gt; s2 ;
    s2.push_back ('B') ;
    s2.push_back ('D') ;
    s2.push_back ('F') ;
    s2.push_back ('G') ;
    s2.push_back ('H') ;

    LonComSequence lcs(s1, s2) ;
    cout &lt;&lt; lcs.calLcsLength () &lt;&lt; endl ;
    lcs.LCS();

    return 0 ;
}</pre>
<p> </p>
<p> </p>
<p></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">算法的改进</span></strong><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></strong></p>
<p class="MsoNormal" style="text-indent: 21pt; margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">在算法</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">lcsLength</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">和</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">lcs</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">中，可进一步将数组</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">b</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">省去。事实上，数组元素</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i][j]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">的值仅由</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i-1][j-1]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i-1][j]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">和</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i][j-1]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">这</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">3</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">个数组元素的值所确定。对于给定的数组元素</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i][j]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">，可以不借助于数组</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">b</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">而仅借助于</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">本身在时间内确定</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i][j]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">的值是由</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i-1][j-1]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i-1][j]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">和</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i][j-1]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">中哪一个值所确定的。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p class="MsoNormal" style="text-indent: 21pt; margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">如果只需要计算最长公共子序列的长度，则算法的空间需求可大大减少。事实上，在计算</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c[i][j]</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">时，只用到数组</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">c</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">的第</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">i</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">行和第</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">i-1</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">行。因此，用</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">2</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">行的数组空间就可以计算出最长公共子序列的长度。进一步的分析还可将空间需求减至</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">O(min(m,n))</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p><strong>实例三、最大子段和</strong><strong> </strong></p>
<p><strong>问题表述</strong><strong> </strong></p>
<p>n个数(可能是负数）组成的序列a1,a2,…an.求该序列</p>
<p>例如:  序列(-2,11,-4,13,-5,-2) ，最大子段和：</p>
<p>       11 – 4 + 13＝20。</p>
<p><strong>（</strong><strong>1</strong><strong>）穷举算法</strong>： O(n3), O(n2)</p>
<p><strong>（</strong><strong>2</strong><strong>）分治法：</strong><strong></strong></p>
<p>将序列a[1:n]从n/2处截成两段：a[1:n/2], a[n/2+1:n]</p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 新宋体; font-size: 12pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New';">实例三、最大子段和</span></strong><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US" style="font-family: 'Courier New'; font-size: 12pt; mso-fareast-font-family: 新宋体;"></span></strong></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt;">问题表述</span></strong><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></strong></p>
<p><span lang="EN-US" style="font-family: 'Courier New'; font-size: 10.5pt; mso-fareast-font-family: 新宋体; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">n</span><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">个数</span><span lang="EN-US" style="font-family: 'Courier New'; font-size: 10.5pt; mso-fareast-font-family: 新宋体; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">(</span><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">可能是负数）组成的序列</span><span lang="EN-US" style="font-family: 'Courier New'; font-size: 10.5pt; mso-fareast-font-family: 新宋体; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">a1,a2,…an.</span><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">求该序列 <span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;"><img alt="" height="31" src="http://cdn.acmerblog.com/img/1388749257169.jpg" width="78"/></span></span><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">子序列的最大值。</span></p>
<p><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">也就是<img alt="" height="51" src="http://cdn.acmerblog.com/img/1388749257262.jpg" width="183"/></span></p>
<p> </p>
<p>例如:  序列(-2,11,-4,13,-5,-2) ，最大子段和：</p>
<p>     11 – 4 + 13＝20。</p>
<p><strong>（</strong><strong>1</strong><strong>）穷举算法</strong>： O(n3), O(n2)</p>
<p><strong>（</strong><strong>2</strong><strong>）分治法：</strong><strong></strong></p>
<p>将序列a[1:n]从n/2处截成两段：a[1:n/2], a[n/2+1:n]</p>
<p><img alt="" height="50" src="http://cdn.acmerblog.com/img/1388749257364.jpg" width="405"/></p>
<p>一共存在三种情况：</p>
<p>a.最大子段和出现在左边一段</p>
<p>b.最大子段和出现在右边一段</p>
<p>c.最大子段和跨越中间的断点</p>
<p>对于前两种情况，只需继续递归调用，而对于第三种情况：</p>
<p><img alt="" height="110" src="http://cdn.acmerblog.com/img/1388749257489.jpg" width="257"/></p>
<p>那么S1+S2是第三种情况的最优值。</p>
<p><strong>（</strong><strong>3</strong><strong>）动态规划法：</strong></p>
<p>定义b[j]：</p>
<p><strong><img alt="" height="58" src="http://cdn.acmerblog.com/img/1388749257602.jpg" width="312"/></strong></p>
<p>含义：从元素i开始，到元素j为止的所有的元素构成的子段有多个，这些子段中的子段和最大的那个。</p>
<p>那么：</p>
<p>如果：b[j-1] &gt; 0, 那么b[j] = b[j-1] + a[j]</p>
<p>如果：b[j-1] &lt;= 0,那么b[j] = a[j]</p>
<p>这样，显然，我们要求的最大子段和，是b[j]数组中最大的那个元素。</p>
<p><strong>实现：</strong></p>
<div><strong> </strong></div>
<p><strong>
</strong></p>
<pre class="brush:cpp ">/* 主题：最大子段和
* 作者：chinazhangjie
* 邮箱：chinajiezhang@gmail.com
* 开发语言：C++
* 开发环境：Microsoft Virsual Studio 2008
* 时间: 2010.11.15
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std ;

class MaxSubSum 
{
public:
    MaxSubSum (const vector&lt;int&gt;&amp; intArr) 
    {
        m_vIntArr = intArr ;
        m_nLen = m_vIntArr.size () ;
    }

    // use divide and conquer 
    int use_DAC () 
    {
        m_nMssValue = __use_DAC (0, m_nLen - 1) ;
        return m_nMssValue ;
    }

    // use dynamic programming
    int use_DP () 
    {
        int sum = 0 ;
        int temp = 0 ;

        for (int i = 0; i &lt; m_nLen; ++ i) {
            if (temp &gt; 0) {
                temp += m_vIntArr[i] ;
            }
            else {
                temp = m_vIntArr[i] ;
            }
            if (temp &gt; sum) {
                sum = temp ;
            }
        }
        m_nMssValue = sum ;
        return sum ;
    }

private:
    int __use_DAC (int left, int right) 
    {
        // cout &lt;&lt; left &lt;&lt; "," &lt;&lt; right &lt;&lt; endl ;
        if (left == right) {
            return (m_vIntArr[left] &gt; 0 ? m_vIntArr[left] : 0) ;
        }

        // 左边区域的最大子段和
        int leftSum = __use_DAC (left, (left + right) / 2) ;
        // 右边区域的最大子段和
        int rightSum = __use_DAC ((left + right) / 2 + 1, right) ;
        // 中间区域的最大子段和
        int sum1 = 0 ;
        int max1 = 0 ;
        int sum2 = 0 ;
        int max2 = 0 ;
        for (int i = (left + right) / 2; i &gt;= left; -- i) {
            sum1 += m_vIntArr[i] ;
            if (sum1 &gt; max1) {
                max1 = sum1 ;
            }
        }
        for (int i = (left + right) / 2 + 1; i &lt;= right; ++ i) {
            sum2 += m_vIntArr[i] ;
            if (sum2 &gt; max2) {
                max2 = sum2 ;
            }
        }
        int max0 = max1 + max2 ;
        max0 = (max0 &gt; 0 ? max0 : 0) ;
        // cout &lt;&lt; max0 &lt;&lt; ", " &lt;&lt; leftSum &lt;&lt; ", " &lt;&lt; rightSum &lt;&lt; endl ;
        return max (max0 , max (leftSum, rightSum)) ;
    }

private:
    vector&lt;int&gt;    m_vIntArr ;    // 整形序列
    int            m_nLen ;    // 序列长度
    int            m_nMssValue;// 最大子段和
} ;

int main()
{
    vector&lt;int&gt; vArr ;
    vArr.push_back (-2) ;
    vArr.push_back (11) ;
    vArr.push_back (-4) ;
    vArr.push_back (13) ;
    vArr.push_back (-5) ;
    vArr.push_back (-2) ;

    MaxSubSum mss (vArr) ;
    cout &lt;&lt; mss.use_DP () &lt;&lt; endl ;
    return 0 ;
}</pre>
<p> </p>
<p> </p>
<p></p>
<p><strong>实例四、多边形游戏</strong><strong></strong></p>
<p>多边形游戏是一个单人玩的游戏，开始时有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符”+”或”*”。所有边依次用整数从1到n编号。</p>
<p><span style="color: #0000ff;">游戏第1步，将一条边删除。</span></p>
<p><span style="color: #0000ff;">随后n-1步按以下方式操作：</span></p>
<p><span style="color: #0000ff;">(1)选择一条边E以及由E连接着的2个顶点V1和V2；</span></p>
<p><span style="color: #0000ff;">(2)用一个新的顶点取代边E以及由E连接着的2个顶点V1和V2。将由顶点V1和V2的整数值通过边E上的运算得到的结果赋予新顶点。</span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">最后，所有边都被删除，游戏结束。游戏的得分就是所剩顶点上的整数值。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; color: red; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">问题</span><span lang="EN-US" style="font-family: 'Courier New'; color: red; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">: </span><span style="font-family: 新宋体; color: red; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">对于给定的多边形，计算最高得分。</span><span lang="EN-US" style="font-family: 'Courier New'; color: red; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p><span style="color: #0000ff;"><img alt="" height="230" src="http://cdn.acmerblog.com/img/1388749257713.jpg" width="354"/></span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">最优子结构性质</span></strong><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></strong></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">按照<span style="text-decoration: underline; text-underline: red;">顺时针</span>顺序，多边形和顶点的顺序可以写成：</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">    </span>op[1], v[1], op[2], v[2], </span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">…</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">, op[n], v[n]</span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">在所给多边形中，从顶点</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">i(1 &lt;= i &lt;= n)</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">开始，长度为</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">j(</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">链中有</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">j</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">个顶点</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">)</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">的顺时针链</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">p(i</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">j) </span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">可表示为</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p>v[i], op[i+1], v[i+1],…, op[i+j-1], v[i+j-1]</p>
<p>如果这条链在op[i + s]处进行最后一次合并运算(1 &lt;= s &lt;= j-1)，则可在op[i+s]处将链分割为2个子链：</p>
<p class="MsoNormal" style="text-indent: 21pt; margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">从</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">i</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">开始长度为</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">s</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">的链：</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">  </span>p(i</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">s)</span></p>
<p class="MsoNormal" style="text-indent: 21pt; margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">从</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">i + s</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">开始，长度为</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">j – s</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">的链：</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">p(i + s</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">j-s)</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">设</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">:</span></p>
<p>m1是对子链p(i，s)的任意一种合并方式得到的值，而a和b分别是在所有可能的合并中得到的最小值和最大值。</p>
<p>m2是p(i+s，j-s)的任意一种合并方式得到的值，而c和d分别是在所有可能的合并中得到的最小值和最大值。</p>
<p>依此定义有a &lt;= m1 &lt;= b，c &lt;= m2 &lt;= d</p>
<p>(1)当op[i+s] = ‘+’时，显然有a + c &lt;= m &lt;= b + d</p>
<p>(2)当op[i+s] = ’*’时，有</p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">min {ac</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">ad</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">bc</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">bd} &lt;= m &lt;= max {ac</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">ad</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">bc</span><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">，</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;">bd}</span></p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 新宋体; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Courier New';">换句话说，<span style="color: red;">主链的最大值和最小值可由子链的最大值和最小值得到</span>。</span><span lang="EN-US" style="font-family: 'Courier New'; mso-fareast-font-family: 新宋体; mso-bidi-font-size: 10.5pt;"></span></p>
<p><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-hansi-font-family: 'Courier New';"><span style="font-family: Courier New;">实现：</span></span></p>
<div><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-hansi-font-family: 'Courier New';"><span style="font-family: Courier New;"> </span></span></div>
<p><span style="font-family: 新宋体; font-size: 10.5pt; mso-ascii-font-family: 'Courier New'; mso-bidi-font-family: 'Courier New'; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-hansi-font-family: 'Courier New';"><span style="font-family: Courier New;"></span></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5d4d8b31-95de-462c-861b-47ff08967ade')"><img alt="" class="code_img_closed" id="code_img_closed_5d4d8b31-95de-462c-861b-47ff08967ade" src="http://cdn.acmerblog.com/img/1388749257932.gif"/><img alt="" class="code_img_opened" id="code_img_opened_5d4d8b31-95de-462c-861b-47ff08967ade" onclick="cnblogs_code_hide('5d4d8b31-95de-462c-861b-47ff08967ade',event)" src="http://cdn.acmerblog.com/img/1388749258051.gif" style="display: none;"/><span class="cnblogs_code_collapse">代码</span>
<div class="cnblogs_code_hide" id="cnblogs_code_open_5d4d8b31-95de-462c-861b-47ff08967ade">
<pre><div>&lt;<br/><br/>Code highlighting produced by Actipro CodeHighlighter (freeware)<br/>http://www.CodeHighlighter.com/<br/><br/>&gt;<span style="color: #008000;">/*</span><span style="color: #008000;"> 主题：多边形游戏<br/>* 作者：chinazhangjie<br/>* 邮箱：chinajiezhang@gmail.com<br/>* 开发语言：C++<br/>* 开发环境：Vicrosoft Visual Studio<br/>* 时间: 2010.11.15<br/></span><span style="color: #008000;">*/</span><span style="color: #000000;"><br/><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iostream</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">vector</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/></span><span style="color: #0000ff;">using</span><span style="color: #000000;"> </span><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std ;<br/><br/></span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> SegInfo<br/>{<br/></span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br/>    SegInfo () <br/>        : m_nMaxValue (</span><span style="color: #800080;">0</span><span style="color: #000000;">), m_nMinValue(</span><span style="color: #800080;">0</span><span style="color: #000000;">) <br/>    {}<br/>    SegInfo (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> maxValue, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> minValue) <br/>        : m_nMaxValue (maxValue), m_nMinValue (minValue) <br/>    {}<br/></span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br/>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> m_nMaxValue ;<br/>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> m_nMinValue ;<br/>} ;<br/><br/></span><span style="color: #0000ff;">class</span><span style="color: #000000;"> PolyGame <br/>{<br/></span><span style="color: #0000ff;">public</span><span style="color: #000000;">:<br/>    PolyGame (</span><span style="color: #0000ff;">const</span><span style="color: #000000;"> vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">char</span><span style="color: #000000;">&gt;&amp;</span><span style="color: #000000;"> op, </span><span style="color: #0000ff;">const</span><span style="color: #000000;"> vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;&amp;</span><span style="color: #000000;"> vertex) <br/>    {<br/>        m_vcOp </span><span style="color: #000000;">=</span><span style="color: #000000;"> op ;<br/>        m_vnVertex </span><span style="color: #000000;">=</span><span style="color: #000000;"> vertex ;<br/>        m_nCount </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vcOp.size () ;<br/><br/>        m_vSeg.resize (m_nCount) ;<br/>        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> m_nCount; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>            m_vSeg[i].resize (m_nCount) ;<br/>        }<br/>    }<br/>    <br/>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> beginCalulate () <br/>    {<br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 初始边界</span><span style="color: #008000;"><br/></span><span style="color: #000000;">        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> m_nCount; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>            m_vSeg[i][</span><span style="color: #800080;">1</span><span style="color: #000000;">].m_nMaxValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vnVertex[i] ;<br/>            m_vSeg[i][</span><span style="color: #800080;">1</span><span style="color: #000000;">].m_nMinValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vnVertex[i] ;<br/>        }<br/><br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> i: 起点<br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> j: 长度<br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> s: 子切分位置</span><span style="color: #008000;"><br/></span><span style="color: #000000;">        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> j </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">; j </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> m_nCount ; </span><span style="color: #000000;">++</span><span style="color: #000000;"> j) {<br/>            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> m_nCount; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> s </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">; s </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> j; </span><span style="color: #000000;">++</span><span style="color: #000000;"> s) {<br/>                    SegInfo si </span><span style="color: #000000;">=</span><span style="color: #000000;"> __calMinAndMax(i, s, j) ;<br/>                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m_vSeg[i][j].m_nMinValue </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> si.m_nMinValue) {<br/>                        m_vSeg[i][j].m_nMinValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> si.m_nMinValue ;<br/>                    } <br/>                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m_vSeg[i][j].m_nMaxValue </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> si.m_nMaxValue) {<br/>                        m_vSeg[i][j].m_nMaxValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> si.m_nMaxValue ;<br/>                    }<br/>                }<br/>            }<br/>        }<br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 找到最大值</span><span style="color: #008000;"><br/></span><span style="color: #000000;">        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> temp </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vSeg[</span><span style="color: #800080;">1</span><span style="color: #000000;">][m_nCount </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">].m_nMaxValue ;<br/>        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> m_nCount; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (temp </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> m_vSeg[i][m_nCount </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">].m_nMaxValue) {<br/>                temp </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vSeg[i][m_nCount </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">].m_nMaxValue ;<br/>            }<br/>        }<br/>        m_nResult </span><span style="color: #000000;">=</span><span style="color: #000000;"> temp ;<br/>        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> m_nResult ;<br/>    }<br/><br/></span><span style="color: #0000ff;">private</span><span style="color: #000000;">:<br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 从i开始，长度为j，s为切分位置</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    SegInfo __calMinAndMax (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> s, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> j) <br/>    {<br/>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> minL </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> maxL </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> minR </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> maxR </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>        minL </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vSeg[i][s].m_nMinValue ;<br/>        maxL </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vSeg[i][s].m_nMaxValue ;<br/>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> r </span><span style="color: #000000;">=</span><span style="color: #000000;"> (i </span><span style="color: #000000;">+</span><span style="color: #000000;"> s </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">) </span><span style="color: #000000;">%</span><span style="color: #000000;"> (m_nCount </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">) </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;"> ;<br/>        minR </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vSeg[r][j </span><span style="color: #000000;">-</span><span style="color: #000000;"> s].m_nMinValue ;<br/>        maxR </span><span style="color: #000000;">=</span><span style="color: #000000;"> m_vSeg[r][j </span><span style="color: #000000;">-</span><span style="color: #000000;"> s].m_nMaxValue ;<br/><br/>        SegInfo si ;<br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 处理加法</span><span style="color: #008000;"><br/></span><span style="color: #000000;">        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m_vcOp[r] </span><span style="color: #000000;">==</span><span style="color: #000000;"> </span><span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">) {<br/>            si.m_nMinValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> minL </span><span style="color: #000000;">+</span><span style="color: #000000;"> minR ;<br/>            si.m_nMaxValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> maxL </span><span style="color: #000000;">+</span><span style="color: #000000;"> maxR ;<br/>        }<br/>        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 处理乘法</span><span style="color: #008000;"><br/></span><span style="color: #000000;">            vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> mm ;<br/>            mm.push_back (minL </span><span style="color: #000000;">*</span><span style="color: #000000;"> minR) ;<br/>            mm.push_back (minL </span><span style="color: #000000;">*</span><span style="color: #000000;"> maxR) ;<br/>            mm.push_back (maxL </span><span style="color: #000000;">*</span><span style="color: #000000;"> minR) ;<br/>            mm.push_back (maxL </span><span style="color: #000000;">*</span><span style="color: #000000;"> maxR) ;<br/>            </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> min </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>            </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> max </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br/>            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">::iterator ite </span><span style="color: #000000;">=</span><span style="color: #000000;"> mm.begin(); <br/>                ite </span><span style="color: #000000;">!=</span><span style="color: #000000;"> mm.end() ; </span><span style="color: #000000;">++</span><span style="color: #000000;"> ite) {<br/>                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (</span><span style="color: #000000;">*</span><span style="color: #000000;">ite </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> min) {<br/>                    min </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">ite ;<br/>                }<br/>                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (</span><span style="color: #000000;">*</span><span style="color: #000000;">ite </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> max) {<br/>                    max </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">ite ;<br/>                } <br/>            }<br/>            si.m_nMinValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> min ;<br/>            si.m_nMaxValue </span><span style="color: #000000;">=</span><span style="color: #000000;"> max ;<br/>        }<br/>        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> si ;<br/>     }<br/><br/></span><span style="color: #0000ff;">private</span><span style="color: #000000;"> :<br/>    vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">char</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">    m_vcOp ;    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 运算符(下标从1开始)</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">        m_vnVertex ;</span><span style="color: #008000;">//</span><span style="color: #008000;"> 顶点值(下标从1开始)</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">int</span><span style="color: #000000;">                m_nCount ;    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 边的个数</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">int</span><span style="color: #000000;">                m_nResult ;    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 结果</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    vector</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">vector</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">SegInfo</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> m_vSeg ;</span><span style="color: #008000;">//</span><span style="color: #008000;"> 合并后的信息</span><span style="color: #008000;"><br/></span><span style="color: #000000;">} ;<br/><br/></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br/>{<br/>    </span><span style="color: #0000ff;">const</span><span style="color: #000000;"> </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cnCount </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">5</span><span style="color: #000000;"> ;<br/>    vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">char</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> op (cnCount </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">);<br/>    vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">     vertex (cnCount </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">);<br/>    op[</span><span style="color: #800080;">1</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;"> ;<br/>    op[</span><span style="color: #800080;">2</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;"> ;<br/>    op[</span><span style="color: #800080;">3</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;"> ;<br/>    op[</span><span style="color: #800080;">4</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;"> ;<br/>    op[</span><span style="color: #800080;">5</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;"> ;<br/><br/>    vertex[</span><span style="color: #800080;">1</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">10</span><span style="color: #000000;"> ;<br/>    vertex[</span><span style="color: #800080;">2</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #000000;">-</span><span style="color: #800080;">8</span><span style="color: #000000;"> ;<br/>    vertex[</span><span style="color: #800080;">3</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">3</span><span style="color: #000000;">;<br/>    vertex[</span><span style="color: #800080;">4</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #000000;">-</span><span style="color: #800080;">2</span><span style="color: #000000;"> ;<br/>    vertex[</span><span style="color: #800080;">5</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;"> ;<br/><br/>    PolyGame pg (op, vertex) ;<br/>    cout </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> pg.beginCalulate () </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> endl ;<br/>}</span></div></pre>
</div>
</div>
<p> </p>
<p></p>
<p>转自：http://www.cnblogs.com/chinazhangjie/archive/2010/11/16/1878400.html</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-86486">
<article class="comment" id="comment-86486">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919467065" rel="external nofollow">新用户030223</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-86486" rel="nofollow"><time datetime="2017-04-13T05:36:37+00:00" pubdate="">2017年4月13日 at 上午5:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>精彩大片你懂，htTP://uVU.Cc/ijW7</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-44375">
<article class="comment" id="comment-44375">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">gnipuohz</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-44375" rel="nofollow"><time datetime="2015-05-19T20:44:40+00:00" pubdate="">2015年5月19日 at 下午8:44</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这张页面太松散拉，重新编辑一下，弄紧凑一点。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-62359">
<article class="comment" id="comment-62359">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">bobo</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-62359" rel="nofollow"><time datetime="2015-04-25T12:35:40+00:00" pubdate="">2015年4月25日 at 下午12:35</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>正在学习搜索，很好</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19967">
<article class="comment" id="comment-19967">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">modstart</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-19967" rel="nofollow"><time datetime="2015-02-17T13:36:41+00:00" pubdate="">2015年2月17日 at 下午1:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>if(j){<br/>
                    int ans=a <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/af/newj_org.gif"/> ;<br/>
                    for(int x=j-1;x&gt;=0;x–){<br/>
                        if(!a <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/d7/newx_org.gif"/> ) break;<br/>
                        ans=min(ans,a <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/d7/newx_org.gif"/> );<br/>
                        sum+=ans;<br/>
                    }<br/>
                }<br/>
求解释，，dp的思路是什么呢？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-44374">
<article class="comment" id="comment-44374">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">zoe_music</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-44374" rel="nofollow"><time datetime="2015-02-15T22:30:43+00:00" pubdate="">2015年2月15日 at 下午10:30</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>学算法中的数据结构学到一定程度会乐此不疲的，比如其中的2－3树，类似的红黑树，我甚至可以自己写个逻辑文件系统结构来。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-56409">
<article class="comment" id="comment-56409">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">litao</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-56409" rel="nofollow"><time datetime="2015-02-03T11:43:13+00:00" pubdate="">2015年2月3日 at 上午11:43</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第36行，struct node **head_ref，怎么理解，那个函数感觉不是很懂啊！？？弱渣求助</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-44376">
<article class="comment" id="comment-44376">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">gaotong2055</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-44376" rel="nofollow"><time datetime="2014-12-20T02:46:57+00:00" pubdate="">2014年12月20日 at 上午2:46</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>赞一个！权限已更新:）</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-44378">
<article class="comment" id="comment-44378">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">dream</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-44378" rel="nofollow"><time datetime="2014-10-22T11:01:06+00:00" pubdate="">2014年10月22日 at 上午11:01</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>我表示楼主不要乱抄题，你写的另一个题吧，直接扒了代码没跑吧</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-44377">
<article class="comment" id="comment-44377">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">mr_zhang2011</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-44377" rel="nofollow"><time datetime="2014-06-15T12:51:30+00:00" pubdate="">2014年6月15日 at 下午12:51</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>非常不错</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-44379">
<article class="comment" id="comment-44379">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">2013283119</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-44379" rel="nofollow"><time datetime="2014-06-03T08:09:46+00:00" pubdate="">2014年6月3日 at 上午8:09</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>感觉第二种方法其实也不是很好，不过的确要比第一种方法要好一点。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-44373">
<article class="comment" id="comment-44373">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">MyHome</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-44373" rel="nofollow"><time datetime="2014-05-16T19:33:38+00:00" pubdate="">2014年5月16日 at 下午7:33</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第二种想法，我想来好久，为啥需要一个newhead，发现是把最后一个节点一直返回到嘴上面这层函数。厉害，这道题之前没样子想过。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19964">
<article class="comment" id="comment-19964">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">huangdilj</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-19964" rel="nofollow"><time datetime="2014-03-29T23:36:03+00:00" pubdate="">2014年3月29日 at 下午11:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这一题的代码这样提交时错误的~少考虑了很多情况</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-19965">
<article class="comment" id="comment-19965">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">ygxqqx</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-19965" rel="nofollow"><time datetime="2014-02-04T20:08:30+00:00" pubdate="">2014年2月4日 at 下午8:08</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>约瑟夫也用说这么长……很成熟的一个问题了，分治的方法解起来o(n)就可以了，有兴趣可以看看具体数学的第一章，关于约瑟夫问题推导出了一系列的结论，很漂亮</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-19966">
<article class="comment" id="comment-19966">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wuzirui</a></span> on <a href="http://www.acmerblog.com/article-np-3376.html#comment-19966" rel="nofollow"><time datetime="2014-01-10T20:49:48+00:00" pubdate="">2014年1月10日 at 下午8:49</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>此题答案确实应该是A。文中已修改，感谢一楼的提醒！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>