<div class="c-top2" id="post-55">
<div class="datetime">2014<br/>01-10</div>
<div class="tit"><h1 class="entry-title">UVa-175-Keywords(关键字)搜索</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/uva" rel="category tag" title="查看UVA中的全部文章">UVA</a>, <a href="http://www.acmerblog.com/category/search/backtracking" rel="category tag" title="查看回溯和剪枝中的全部文章">回溯和剪枝</a></span><span class="i4">围观1552次</span><span class="i3"><a class="ds-thread-count" data-thread-key="3657" href="http://www.acmerblog.com/uva-175-keywords-3657.html#comments" title="《UVa-175-Keywords(关键字)搜索》上的评论">15 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<p>Time limit: 3.000 seconds<br/><span style="color: #888888;">限时3.000秒</span></p>
<p> </p>
<h2>Problem<br/><span style="color: #888888;">问题</span></h2>
<p>Many researchers are faced with an ever increasing number of journal articles to read and find it difficult to locate papers of relevance to their particular lines of research. However, it is possible to subscribe to various services which claim that they will find articles that fit an `interest profile’ that you supply, and pass them on to you. One simple way of performing such a search is to determine whether a pair of keywords occurs `sufficiently’ close to each other in the title of an article. The threshold is determined by the researchers themselves, and refers to the number of words that may occur between the pair of keywords. Thus an archeologist interested in cave paintings could specify her profile as “0 rock art”, meaning that she wants all titles in which the words “<span style="font-family: courier new,courier;">rock</span>” and “<span style="font-family: courier new,courier;">art</span>” appear with 0 words in between, that is next to each other. This would select not only “<span style="font-family: courier new,courier;">Rock Art of the Maori</span>” but also “<span style="font-family: courier new,courier;">Pop Art, Rock, and the Art of Hang-glider Maintenance</span>”.<br/><span style="color: #888888;">许多研究人员都面临这样一个问题：阅读的期刊文章数量与日俱增，要找到与他们特定研究方向相关的文章困难重重。然而，有一些订阅服务声称它们可以按你制定的“兴趣配置”找到匹配的文章，并传送给你。一种简单的方式就是执行这样一种搜索：确定文章中是否有一对单词出现的“足够” 靠近。研究人员设定一个阈值，指出一对单词之间应出现的单词数量。例如一个考古学家对岩洞壁画感兴趣，就会指定她的兴趣配置为“0 rock</span></p>
<p>art”，意思是她希望标题中出现“rock”和“art”且间隔为0单词的所有文章，即这两个单词彼此相临。这样的兴趣配置会选出的标题包括“Rock<br/>
 Art of the Maori”和“Pop Art, Rock, and the Art of Hang-glider<br/>
Maintenance”等。</p>
<p>Write a program that will read in a series of<br/>
profiles followed by a series of titles and determine which of the<br/>
titles (if any) are selected by each of the profiles. A title is<br/>
selected by a profile if at least one pair of keywords from the profile<br/>
is found in the title, separated by no more than the given threshold.<br/>
For the purposes of this program, a word is a sequence of letters,<br/>
preceded by one or more blanks and terminated by a blank or the end of<br/>
line marker. <br/><span style="color: #888888;">写一个程序，读入一系列的配置文件，再读入一系列的标题，确定哪些标题（如果有）会被各配置选中。一个标题被一个配置选中仅当配置中的至少一对单词出现在标题中，并且间隔没有超过给定的阈值。对于这个程序而言，一个单词就是字母的序列，前面有一个或多个空白，并以空白或行结束符作为结束。</span></p>
<p> </p>
<h2>Input<br/><span style="color: #888888;">输入</span></h2>
<p>Input will consist of no more than 50 profiles followed by no more than 250 titles. Each profile and title will be numbered in the order of their appearance, starting from 1, although the numbers will not appear in the file. <br/><span style="color: #888888;">输入的配置不会超过50个，标题不会超过250个。每一个配置和标题都以给出的顺序编号（从1开始计数），但编号并不会在输入中给出。</span></p>
<p> </p>
<p>Each<br/>
 profile will start with the characters “P:”, and will consist of a<br/>
number representing a threshold, followed by two or more keywords in<br/>
lower case. <br/><span style="color: #888888;">每个配置都以字符“P:”开始，包括一个表示阈值的数，接下来是两个或更多的关键字，均为小写形式。</span></p>
<p> </p>
<p>Each<br/>
title will start with the characters “T:”, and will consist of a<br/>
string of characters terminated by “|”. The character “|” will not<br/>
occur anywhere in a title except at the end. No title will be longer<br/>
than 255 characters, and if necessary it will flow on to more than one<br/>
line. No line will be longer than eighty characters and each<br/>
continuation line of a title will start with at least one blank. Line<br/>
breaks will only occur between words. <br/><span style="color: #888888;">每个标题都以字符“T:”开始，会包括一个以“|”作为结束的字符串。字符“|”不会出现在标题中除末尾外的任何位置。标题都不会超过255个字节，如果必要会分成多行给出。所有行的长度都不会超过80个字符，且标题的每个续行都以至少一个空白作为开始。换行只会出现在单词之间。</span></p>
<p> </p>
<p>All non-alphabetic characters are to<br/>
be ignored, thus the title “Don’t Rock — the Boat as Metaphor in<br/>
1984” would be treated as “Dont Rock the Boat as Metaphor in” and<br/>
“HP2100X” will be treated as “HPX”. The file will be terminated by a<br/>
 line consisting of a single #. <br/><span style="color: #888888;">所有非字母的字符都应忽略，例如标题“Don’t Rock — the<br/>
Boat as Metaphor in 1984”应被当作“Dont Rock the Boat as Metaphor<br/>
in”处理，“HP2100X”将被当作“HPX”处理。输入文件以只有一个#的一行作为结束。</span></p>
<p> </p>
<h2>Output<br/><span style="color: #888888;">输出</span></h2>
<p>Output will consist of a series of lines, one for each profile in the input. Each line will consist of the profile number (the number of its appearance in the input) followed by “:”, a blank space, and the numbers of the selected titles in numerical order, separated by commas and with no spaces. <br/><span style="color: #888888;">输出由多行构成，每行对应输入的一个配置。每行都应包括配置的编号（配置在输入中的编号）跟着一个“:”，一个空格，然后是以数字顺序排列的选中标题的编号，中间以逗号隔开，不要空格。</span></p>
<p> </p>
<h2>Sample input<br/><span style="color: #888888;">示例输入</span></h2>
<p> </p>
<h2>Sample output<br/><span style="color: #888888;">示例输出</span></h2>
<p> </p>
<h2>Analysis<br/><span style="color: #888888;">分析</span></h2>
<p>这道题重点考察对搜索匹配问题的建模能力，实际和字符串处理关系不大。要注意以下几点：</p>
<ol>
<li>所有非字母的字符都不处理；</li>
<li>仅以空格或换行作为单词的分隔符；</li>
<li>单词均以小写形式处理；</li>
<li>配置中的单词任两个都要算做一对。</li>
</ol>
<p>前三条原则实际上就把单词给量化了，如果对单词编号建表，那么配置和标题就都成为了一堆数字（每个数字皆为单词的编号）</p>
<p>一、以正确的方式处理输入的配置，录入全部配置中的单词。遍历配置中的所有单词，建立从单词到编号的对应表（即单词表），此处可以使用stl中的map作为单词表的数据结构。接下来用单词表规格化处理所有的配置和标题，标题中不在单词表中的单词可用-1标记。</p>
<p>二、建立数据配置中的单词对数据。对于配置中的每一对单词，实际上是一个三元组：（单词对，阈值，所属配置编号）。由于在第一步已经将所有单词规格化为数字了，因此单词对就是两个整数。考虑单词的总数一定不会上万，且单词对中两个单词的顺序无所谓，因此可以用两个字节表示一个编号，然后将较小的编号放在高字节，较大的放低位构成一个4字节的整数，这个整数就可以唯一的表示一个单词对。那么所有配置中的单词对的数据就可以多种形式来表达了，这里使用map映射，key是单词对的整数，value是一个结构体的动态数组，结构体中包括阈值和所属配置编号。</p>
<p>三、建立标题中的单词对数据。标题中的单词包括非关键词（编号为-1）和关键词，要求出各标题中每一对存在的关键词的最短距离，并用一种数据结构表达。这里使用和第二步相似的数据结构，每一对关键词是一个三元组：（单词对，最短距离，所属标题编号）。查找标题中所有关键词对的最短距离用暴力搜索就可以了，遍历的顺序和冒泡排序一样，复杂度是n<sup>2</sup>。所有数值求出来后，建立map映射，key是单词对的整数，value是一个结构体的动态数组，结构体中包括最短距离和所属标题的编号。</p>
<p>四、最后就是比对配置的映射表和标题的映射表，找出相同的单词对，然后比对各自的数组。如果有最短距离小于或等于阈值的，那就在这个标题编号和配置编号建立一个联系。找出所有的配置编号-标题编号关系后，按配置编号排序，整理输出即可。</p>
<p> </p>
<h2>Solution<br/><span style="color: #888888;">解答</span><br/>
</h2>
<p> </p>
<pre class="brush:cpp ">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;utility&gt;

typedef unsigned long ulong;
typedef unsigned short ushort;

// 用于存储profile中的阈值和转成数字序列的关键词组合
struct PROFILE
{
	size_t nThreshold;
	std::vector&lt;ushort&gt; nArray;
};

// 用于存储profile中的阈值和profile的编号，title中的包含的两个关键字之间的距离和title的编号
struct INFO
{
	size_t nDist;
	size_t nIdx;
};

typedef std::vector&lt;std::string&gt; VECSTR;
typedef std::vector&lt;ushort&gt; ARRAY;
typedef std::vector&lt;ARRAY&gt; MATRIX;
typedef std::map&lt;ulong, std::vector&lt;INFO&gt; &gt; MAPINFO;
typedef std::pair&lt;size_t, size_t&gt; PAIR;

// 将keywords对中的两个单词用数字序列表示，用一个unsigned short数据类型存储
ulong MakeWordPair(ushort w1, ushort w2)
{
	return (w1 &gt; w2)? (w1 | (w2 &lt;&lt; 16)) : (w2 | (w1 &lt;&lt; 16));
}

// 排序过程，重载“&lt;”运算符
bool operator &lt; (const INFO &amp;f1, const INFO &amp;f2)
{
	return (f1.nDist &lt; f2.nDist || (f1.nDist == f2.nDist &amp;&amp; f1.nIdx &lt; f2.nIdx));
}

// 去重过程，重载“==”运算符
bool operator == (const INFO &amp;f1, const INFO &amp;f2)
{
	return (f1.nDist == f2.nDist &amp;&amp; f1.nIdx == f2.nIdx);
}

int main(void)
{
	VECSTR profileStrs, titleStrs;
	for (std::string str; getline(std::cin, str) &amp;&amp; str[0] != '#'; ) {
		// 读入数据，若以“P：”开头，则表示profile，若以“T：”开头，则表示title，若以空格或者tab开头，则承接上一个title。
		switch(str[0]) {
		case 'P':
			profileStrs.push_back(std::string(str.begin() + 2, str.end()));
			break;
		case 'T':
			titleStrs.push_back(std::string(str.begin() + 2, str.end()));
			break;
		case ' ':
		case '\t':
			titleStrs.back() += str;
			break;
		}
	}
	std::map&lt;std::string, ushort&gt; wordTbl;	     // 用于给每一个keywords编号，keywords与编号的映射关系存入wordTbl中
	std::vector&lt;PROFILE&gt; arrProfile;	         // 将每个profile中的keywords序列转化为相应的keywords编号序列
	for (VECSTR::iterator i = profileStrs.begin(); i != profileStrs.end(); ++i) {
		i-&gt;push_back(' ');
		std::string::iterator iBeg = i-&gt;begin();
		// 由于profile由阈值和keywords串组成，遍历profile字符串，找到阈值的起始位置
		for (; iBeg != i-&gt;end() &amp;&amp; !isdigit(*iBeg); ++iBeg);
		// 找到阈值的结束位置，读取阈值
		std::string strThre;
		std::string::iterator iEnd = iBeg;
		for (; iEnd != i-&gt;end() &amp;&amp; isdigit(*iEnd); ++iEnd)
			strThre.push_back(*iEnd);
		// 保存每一个profile的阈值和由keywords的编号组成的序列
		arrProfile.push_back(PROFILE());
		PROFILE &amp;cur = arrProfile.back();
		// 将阈值由文本形式转为数值形式
		cur.nThreshold = atoi(strThre.c_str()); 
		//用于存储keywords中读取的单词
		std::string word;   
		for (std::string::iterator j = iEnd; j != i-&gt;end(); ++j) {
			if (*j != ' ' &amp;&amp; *j != '\t')
				word.push_back(*j);
			else if (!word.empty()) {
				// 更新keywords与编号的映射表
				ushort &amp;wordIdx = wordTbl[word];
				if (wordIdx == 0)
					wordIdx = wordTbl.size();
				// 存储keywords编号序列
				cur.nArray.push_back(wordIdx); 
				word.clear();
			}
		}
	}
	// 原输入为一个profile对应一组keywords pair，将其转变为一个keywords pair对应一个profile编号组，建立映射关系
	MAPINFO profileTbl;
	for (std::vector&lt;PROFILE&gt;::iterator i = arrProfile.begin(); i != arrProfile.end(); ++i)	{
		// 所有的keywords两两组合作为一个keywords pair
		for (ARRAY::iterator j = i-&gt;nArray.begin(); j != i-&gt;nArray.end() - 1; ++j) {
			for (ARRAY::iterator k = j + 1; k != i-&gt;nArray.end(); ++k) {
				INFO info = {i-&gt;nThreshold, i - arrProfile.begin()};
				profileTbl[MakeWordPair(*j, *k)].push_back(info);
			}
		}
	}

	MATRIX titleAry;
	for (VECSTR::iterator i = titleStrs.begin(); i != titleStrs.end(); ++i) {
		(*i)[i-&gt;size() - 1] = ' ';
		titleAry.push_back(ARRAY());
		std::string word;
		// 按题中要求处理title，去掉非字母的符号。再将title序列转化为编号序列，若某一个单词为keyword，则标记为相应的编号，若不是，则标记为-1
		for (std::string::iterator j = i-&gt;begin(); j != i-&gt;end(); ++j) {
			char cTmp = tolower(*j);
			if (cTmp != ' ' &amp;&amp; cTmp != '\t') {
				if (isalpha(cTmp))
					word.push_back(cTmp);
			}
			else if (!word.empty()) {
				std::map&lt;std::string, ushort&gt;::iterator idx = wordTbl.find(word);
				titleAry.back().push_back(idx != wordTbl.end() ? idx-&gt;second : -1);
				word.clear();
			}
		}
	}
	// 每一个title中包含多个keywords pair，计算并存储每对keywords的距离
	MAPINFO titleTbl;
	for (MATRIX::iterator i = titleAry.begin(); i != titleAry.end(); ++i) {
		// 对当前title建立keywords pair，每对keywords的距离以及title编号的映射表
		std::map&lt;ulong, ushort&gt; curWordmap;
		for (ARRAY::iterator j = i-&gt;begin(); j != i-&gt;end() - 1; ++j) {
			if (*j != ushort(-1)) {
				for (ARRAY::iterator k = j + 1; k != i-&gt;end(); ++k) {
					if (*k != ushort(-1)) {
						// 若存在关键字对，则计算两个关键字间的距离，保留最小值
						ushort nDist = k - j;
						ushort &amp;nWord = curWordmap[MakeWordPair(*j, *k)];
						if (nWord == 0 || nDist &lt; nWord)
							nWord = nDist;
					}
				}
			}
		}
		// 将title处理为一个keywords pair对应一组title编号和距离
		for (std::map&lt;ulong, ushort&gt;::iterator j = curWordmap.begin(); j != curWordmap.end(); ++j) {
			INFO info = {j-&gt;second, i - titleAry.begin()};
			titleTbl[j-&gt;first].push_back(info);
		}
	}
	// 比较profile和title，确定哪些title属于相应的profile
	std::vector&lt;PAIR&gt; result;
	for (MAPINFO::iterator i = profileTbl.begin(); i != profileTbl.end(); ++i) {
		std::vector&lt;INFO&gt; &amp;curP = i-&gt;second;
		std::vector&lt;INFO&gt; &amp;curT = titleTbl[i-&gt;first];
		// 判断title中是否有该keywords pair
		if (!curT.empty()) {
			// 当profile和title包含相同的keywords时，将当前的profile编号排序去重
			std::sort(curP.begin(), curP.end());
			curP.erase(std::unique(curP.begin(), curP.end()), curP.end());
			std::sort(curT.begin(), curT.end());    // 将当前的title编号排序
			for (std::vector&lt;INFO&gt;::iterator icurP = curP.begin(), icurT = curT.begin(); 
				icurP != curP.end() &amp;&amp; icurT != curT.end();) {
					// 若当前title中关键字的距离小于当前profile中阈值，则该title的编号必定属于当前之后的所有profile（包含当前profile）
					// 若大于当前阈值，则去下一个profile的阈值
				if (icurT-&gt;nDist - 1 &lt;= icurP-&gt;nDist) {
					for (std::vector&lt;INFO&gt;::iterator j = icurP; j != curP.end(); ++j)
						result.push_back(std::make_pair(j-&gt;nIdx + 1, icurT-&gt;nIdx + 1));
					++icurT;
				}
				else
					++icurP;
			}
		}
		else
			result.push_back(std::make_pair(curP.front().nIdx + 1, 0));
	}
	// 对结果排序并输出
	std::sort(result.begin(), result.end());
	int nProfIdx = 0;
	for (std::vector&lt;PAIR&gt;::iterator i = result.begin(); i != result.end(); ++i) {
		if (i-&gt;first != nProfIdx) {
			nProfIdx = i-&gt;first;
			if (i != result.begin())
				std::cout &lt;&lt; std::endl;
			std::cout &lt;&lt; nProfIdx &lt;&lt; ": ";
			if (i-&gt;second != 0)
				std::cout &lt;&lt; i-&gt;second;
		}
		else if (i-&gt;second != 0)
				std::cout &lt;&lt; ',' &lt;&lt; i-&gt;second;
		}
	}
	std::cout &lt;&lt; std::endl;
	return 0;
}</pre>
<p> </p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-85291">
<article class="comment" id="comment-85291">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919456994" rel="external nofollow">新用户214494</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-85291" rel="nofollow"><time datetime="2017-04-13T03:10:06+00:00" pubdate="">2017年4月13日 at 上午3:10</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>如果我能把这鞋子600块卖出去，那我确实是赚了300.</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21500">
<article class="comment" id="comment-21500">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">pain</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21500" rel="nofollow"><time datetime="2015-06-23T11:29:22+00:00" pubdate="">2015年6月23日 at 上午11:29</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>我表示楼主不要乱抄题，你写的另一个题吧，直接扒了代码没跑吧</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21508">
<article class="comment" id="comment-21508">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yupeng.bai</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21508" rel="nofollow"><time datetime="2015-05-12T06:26:55+00:00" pubdate="">2015年5月12日 at 上午6:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不错，值得借鉴</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21506">
<article class="comment" id="comment-21506">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">BGPY</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21506" rel="nofollow"><time datetime="2014-11-01T13:17:26+00:00" pubdate="">2014年11月1日 at 下午1:17</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第15行代码，/n/n，应该改为\n\n</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21498">
<article class="comment" id="comment-21498">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">leowww</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21498" rel="nofollow"><time datetime="2014-08-26T11:49:28+00:00" pubdate="">2014年8月26日 at 上午11:49</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第一个真的要比较两次吗，换成else if 不可以吗</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21505">
<article class="comment" id="comment-21505">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wawa_zmt</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21505" rel="nofollow"><time datetime="2014-08-15T18:32:54+00:00" pubdate="">2014年8月15日 at 下午6:32</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>示例程序中的代码不够稳健，没有考虑到输入了非法字符或者不合理输入的情况。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21501">
<article class="comment" id="comment-21501">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">dream</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21501" rel="nofollow"><time datetime="2014-08-04T18:00:05+00:00" pubdate="">2014年8月4日 at 下午6:00</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>没敢用map，总怕stl用着会超时</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21496">
<article class="comment" id="comment-21496">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">130920099</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21496" rel="nofollow"><time datetime="2014-07-29T19:36:19+00:00" pubdate="">2014年7月29日 at 下午7:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不错，感谢分享。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21499">
<article class="comment" id="comment-21499">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">zjd1988</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21499" rel="nofollow"><time datetime="2014-07-19T17:16:11+00:00" pubdate="">2014年7月19日 at 下午5:16</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不好意思，写错了．应该是　path[0]=0,  visited[V] = true;</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21507">
<article class="comment" id="comment-21507">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">room306</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21507" rel="nofollow"><time datetime="2014-05-10T17:19:08+00:00" pubdate="">2014年5月10日 at 下午5:19</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>失误失误，转载错了。已经改正，抱歉。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21495">
<article class="comment" id="comment-21495">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">943965021</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21495" rel="nofollow"><time datetime="2014-04-21T23:37:50+00:00" pubdate="">2014年4月21日 at 下午11:37</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>学习了。找到这题</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21502">
<article class="comment" id="comment-21502">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">CHEATBEATER</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21502" rel="nofollow"><time datetime="2014-03-18T10:26:14+00:00" pubdate="">2014年3月18日 at 上午10:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>博主的C++功底真是好</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21497">
<article class="comment" id="comment-21497">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">MyHome</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21497" rel="nofollow"><time datetime="2014-03-03T14:03:23+00:00" pubdate="">2014年3月3日 at 下午2:03</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>图像处理那题解题报告在哪儿呢？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-21503">
<article class="comment" id="comment-21503">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">tzf88888888</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21503" rel="nofollow"><time datetime="2014-02-28T04:01:54+00:00" pubdate="">2014年2月28日 at 上午4:01</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>和编译器有关吧，我用的g++正常。头文件可能还需要一个&lt;string.h&gt;</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-21504">
<article class="comment" id="comment-21504">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yupeng.bai</a></span> on <a href="http://www.acmerblog.com/uva-175-keywords-3657.html#comment-21504" rel="nofollow"><time datetime="2014-02-15T09:05:20+00:00" pubdate="">2014年2月15日 at 上午9:05</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这是研发类的题还是算法类？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>