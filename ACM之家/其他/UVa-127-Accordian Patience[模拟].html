<div class="c-top2" id="post-55">
<div class="datetime">2014<br/>01-28</div>
<div class="tit"><h1 class="entry-title">UVa-127-Accordian Patience[模拟]</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/uva" rel="category tag" title="查看UVA中的全部文章">UVA</a>, <a href="http://www.acmerblog.com/category/basis/simulate" rel="category tag" title="查看模拟法中的全部文章">模拟法</a></span><span class="i4">围观796次</span><span class="i3"><a class="ds-thread-count" data-thread-key="3808" href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comments" title="《UVa-127-Accordian Patience[模拟]》上的评论">15 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<p>Time limit: 3.000 seconds<br/><span style="color: #888888;">限时：3.000秒</span></p>
<p> </p>
<h2>Problem<br/><span style="color: #888888;">问题</span></h2>
<p>You are to simulate the playing of games of “Accordian” patience, the rules for which are as follows:<br/><span style="color: #888888;">模拟玩一个“手风琴”纸牌游戏，规则如下：</span></p>
<p style="margin-left: 4em; margin-right: 4em;">Deal cards one by one in a row from left to right, not overlapping. Whenever the card matches its immediate neighbour on the left, or matches the third card to the left, it may be moved onto that card. Cards match if they are of the same suit or same rank. After making a move, look to see if it has made additional moves possible. Only the top card of each pile may be moved at any given time. Gaps between piles should be closed up as soon as they appear by moving all piles on the right of the gap one position to the left. Deal out the whole pack, combining cards towards the left whenever possible. The game is won if the pack is reduced to a single pile.<br/><span style="color: #888888;">按从左至右的顺序发牌，并摆成一行，发牌不要相互重叠。游戏中一旦出现任何一张牌与它左边的第一张或第三张“匹配”，即</span><span style="color: #888888;">花色或点数相同</span><span style="color: #888888;">，则须立即将其移动到那张牌上面。如果牌被移动后又出现了上述情况，则需再次向左移动。每叠牌只能移动最上面的一张。如果一叠牌被移空，应该立即将右边各叠整体向左移动，补上这个空隙。依次将整副牌都发完，并不断的向左合并。如果全部移动结束后整副牌都放成了一叠，则游戏胜利。</span></p>
<p>Situations can arise where more than one play is possible. Where two cards may be moved, you should adopt the strategy of always moving the leftmost card possible. Where a card may be moved either one position to the left or three positions to the left, move it three positions.<br/><span style="color: #888888;">玩上几次你就会遇到一些状况。如果同时有两张牌都可以移动，你应该采取的策略是移动最左边的牌（当然必须是可以移动的）。当一张牌既可以移动到左边第一张，又可以移动到左边第三张时，应移动到左边第三张上面。</span></p>
<p> </p>
<h2>Input<br/><span style="color: #888888;">输入</span></h2>
<p>Input data to the program specifies the order in which cards are dealt from the pack. The input contains pairs of lines, each line containing 26 cards separated by single space characters. The final line of the input file contains a # as its first character. Cards are represented as a two character code. The first character is the face-value (A=Ace, 2-9, T=10, J=Jack, Q=Queen, K=King) and the second character is the suit (C=Clubs, D=Diamonds, H=Hearts, S=Spades).<br/><span style="color: #888888;">输入到程序中的数据指定了一副牌的顺序。每组输入包括两行，每行26张牌，牌与牌之间用空格隔开。以#号开头的一行作为输入的结束行。每张牌由两个字符表示，第一个字符是点数：（A、 2-9、T=10、J、Q, K）；第二个字符是花色：（C=梅花、D=方块、H=红心、S=黑桃）。</span></p>
<p> </p>
<h2>Output<br/><span style="color: #888888;">输出</span></h2>
<p>One line of output must be produced for each pair of lines (that between them describe a pack of 52 cards) in the input. Each line of output shows the number of cards in each of the piles remaining after playing “Accordian patience” with the pack of cards as described by the corresponding pairs of input lines.<br/><span style="color: #888888;">每两行输入（定义了一副52张牌的顺序）必须产生一行输出。每行输出包括剩下的叠数以及每叠中的牌数。</span></p>
<p> </p>
<h2>Sample Input<br/><span style="color: #888888;">输入示例</span></h2>
<p>QD AD 8H 5S 3H 5H TC 4D JH KS 6H 8S JS AC AS 8D 2H QS TS 3S AH 4H TH TD 3C 6S<br/>8C 7D 4C 4S 7S 9H 7C 5D 2S KD 2D QH JD 6D 9D JC 2C KH 3D QC 6C 9S KC 7H 9C 5C<br/>AC 2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AD 2D 3D 4D 5D 6D 7D 8D TD 9D JD QD KD<br/>AH 2H 3H 4H 5H 6H 7H 8H 9H KH 6S QH TH AS 2S 3S 4S 5S JH 7S 8S 9S TS JS QS KS<br/>#</p>
<p> </p>
<h2>Sample Output<br/><span style="color: #888888;">输出示例</span></h2>
<p>6 piles remaining: 40 8 1 1 1 1<br/>1 pile remaining: 52</p>
<p><span style="color: #888888;">(译注：第一个数字为剩下的叠数，当叠数为1时，后面输出“pile remaining: ”，否则输出“piles remaining: ”。接下来从左至右输出各叠牌的数量）</span></p>
<p> </p>
<h2>Analysis<br/><span style="color: #888888;">分析</span></h2>
<p>这两天UVa OJ的服务器老是不稳定，提交的解答一直“In judge queue”，不得不停工了很长时间！下面的代码用几百组随机数据测试过，与<a href="http://uvatoolkit.com/problemssolve.php">UVa Toolkit</a>提供的所谓正确答案比对，结果是完全相同的。不管怎样思路应该不会错，所以先贴上来，也好清空代码做下一题。如果OJ出来没有AC，再修改也不迟。（更新：OJ出来了，AC，0.772秒）</p>
<p>解这道题前务必认真的理解题意，一点小误差都会引起算法的区大差别。最好先拿副扑克牌先玩几遍，熟练的过程中思路自然就产生了，还可能会发现一些技巧。</p>
<p>总体还是采用步进迭代的方法来解，每发一张牌就执行所有可能的移动，然后再发下一张。直到所有的牌都发完，统计并输出结果。存储牌叠应采用二维动态数组，我使用的是两层vector，如果追求效率可将外层的vector改为list，但实现的代码会比较复杂。</p>
<p>按照题目要求，每次移动一张牌时，应一次性向左移动到再也不能移动的位置上。此时这张牌的右边就可能再次出现可以移动的牌。因此，发牌后可以执行的操作是：将一张牌（新发的牌应放在最后作为第一次移动的牌）向左移动完毕后，向右查找第一个可以移动的牌；找到后再向左移动，然后再从移动后的位置向右查找，以此类推，直到再也找不到可以移动的牌为止。</p>
<p>用三重循环来解决问题，最外层的循环就是按顺序发牌。每次发一张牌就将这张牌放到最后作为新的一叠。中间一层循环用来向右遍例每一张可以移动的牌，找到后就向左移动。最内的循环就是查找当前牌可以移动到的位置（最左边的）。</p>
<p>从该题的Statics来看，OJ给出的测试数据量貌似比较大，因此要比较小心的实现。为了加快运算，我没有使用特别的数据结构来转存牌面，这也是没有必要的，完全可以用原输入的字符进行处理。CARD结构体只是用于表示两个字符的指针。</p>
<p>这道题本身不难，图释就划不来了，还是看代码吧。</p>
<p> </p>
<h2>Solution<br/><span style="color: #888888;">解答</span></h2>
<pre class="brush:cpp ">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
//CARD结构体，存储一张牌，Face[0]表示花色，Face[1]表示点数
struct CARD {char Face[2];} Src;
//比较两张牌是否匹配。花色或点数相同即匹配
inline bool Match(const CARD &amp;c1, const CARD &amp;c2) {
	return (c1.Face[0] == c2.Face[0] || c1.Face[1] == c2.Face[1]);
}
int main(void) { //主函数
	typedef vector&lt;CARD&gt; PILE;
	char Pack[256]; //用于存储输入的一副牌，下面循环读取输入的数据
	for (string Line; getline(cin, Line) &amp;&amp; Line[0] != '#'; cout &lt;&lt; endl) {
		strcpy(Pack, Line.c_str()); //读取并处理输入的数据
		while (getline(cin, Line) &amp;&amp; Line.empty()); //读取第2行
		strcat(Pack, Line.c_str());
		*remove(&amp;Pack[0], &amp;Pack[strlen(Pack)], ' ') = '\0'; //删除行中的空格
		vector&lt;PILE&gt; Piles;
		for (int i = 0; i &lt; 52; ++i) { //循环发出每一张牌
			PILE Stack(1, ((CARD*)&amp;Pack)[i]);
			Piles.push_back(Stack); //将新发的牌放在最后一叠
			//j表示当前牌的位置，k表示j左边与之匹配的牌的位置
			for (size_t j = Piles.size() - 1, k; j &lt; Piles.size(); ++j) {
				//以下循环向左查找可以移到的最左边的位置
				for (k = j, Src = Piles[j].back(); k &gt; 0; --k) {
					if (k &gt;= 3) { //先判定左边是否存在第3张
						if (Match(Src, Piles[k - 3].back())) {
							//如果与左边第3张匹配，则将k指向这张牌
							k -= 2;
							continue;
						} //虚拟移到k指向的位置，继续向左查找
					}
					if (!Match(Src, Piles[k - 1].back())) {
						break; //如果左边第3张和第1张都失配，跳出循环
					}
				}
				if (k != j) { //k与原位置j不相等表示可以移动
					Piles[k].push_back(Piles[j].back()); //移动牌
					Piles[j].pop_back();
					if (Piles[j].empty()) { //如果牌叠被移空则删除之
						Piles.erase(Piles.begin() + j);
					}
					j = k; //将移动牌查找的起点定为k
				}
			}
		} //以下按要求的格式输出结果。注意到Pile有单复数的区分
		int nSize = Piles.size();
		cout &lt;&lt; nSize &lt;&lt; " pile" &lt;&lt; (nSize &gt; 1 ? "s " : " ") &lt;&lt; "remaining:";
		for (int i = 0; i &lt; nSize; cout &lt;&lt; ' ' &lt;&lt; Piles[i++].size());
	}
	return 0;
}</pre>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-84394">
<article class="comment" id="comment-84394">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919460609" rel="external nofollow">新用户534173</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-84394" rel="nofollow"><time datetime="2017-04-12T23:52:09+00:00" pubdate="">2017年4月12日 at 下午11:52</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>琼瑶不管怎么说名气这么大的大牌也要艰辛的拼搏19个月，普通小人物被侵权了也不知道有没办法</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45430">
<article class="comment" id="comment-45430">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">zhuliyan</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45430" rel="nofollow"><time datetime="2015-06-28T15:24:05+00:00" pubdate="">2015年6月28日 at 下午3:24</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>根本过不了。。。。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45429">
<article class="comment" id="comment-45429">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Tree</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45429" rel="nofollow"><time datetime="2015-06-22T11:42:46+00:00" pubdate="">2015年6月22日 at 上午11:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这个系列很不错</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45425">
<article class="comment" id="comment-45425">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">water160</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45425" rel="nofollow"><time datetime="2015-04-28T01:30:30+00:00" pubdate="">2015年4月28日 at 上午1:30</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>能不能说下这个是用的什么算法策略？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45428">
<article class="comment" id="comment-45428">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Ailing</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45428" rel="nofollow"><time datetime="2015-04-01T06:05:12+00:00" pubdate="">2015年4月1日 at 上午6:05</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>我还有个问题想请教一下，就是感觉对于新手来说，递归理解起来有些困难，不知有没有什么好的方法或者什么好的建议？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-62623">
<article class="comment" id="comment-62623">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">645198</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-62623" rel="nofollow"><time datetime="2015-02-26T10:42:27+00:00" pubdate="">2015年2月26日 at 上午10:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>文章写得挺好，就是最后的斐波那契那个没有看明白</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45422">
<article class="comment" id="comment-45422">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wawa_zmt</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45422" rel="nofollow"><time datetime="2015-02-02T21:35:35+00:00" pubdate="">2015年2月2日 at 下午9:35</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>多谢指出，已改正</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45421">
<article class="comment" id="comment-45421">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">jupiterhyun</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45421" rel="nofollow"><time datetime="2015-01-27T03:18:39+00:00" pubdate="">2015年1月27日 at 上午3:18</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这个应该是最朴素的KMP实现</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45431">
<article class="comment" id="comment-45431">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">MyHome</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45431" rel="nofollow"><time datetime="2014-10-29T03:26:08+00:00" pubdate="">2014年10月29日 at 上午3:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>非常不错</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45424">
<article class="comment" id="comment-45424">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">1193658339</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45424" rel="nofollow"><time datetime="2014-10-25T19:21:54+00:00" pubdate="">2014年10月25日 at 下午7:21</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这怎么用Catalan数啊？求解答！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45423">
<article class="comment" id="comment-45423">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">mr-zhang2011</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45423" rel="nofollow"><time datetime="2014-06-15T18:09:30+00:00" pubdate="">2014年6月15日 at 下午6:09</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>正是我要找的，适合新手</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-56876">
<article class="comment" id="comment-56876">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">helloacm</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-56876" rel="nofollow"><time datetime="2014-04-16T23:10:56+00:00" pubdate="">2014年4月16日 at 下午11:10</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>打字员路过。。。。。。算法是啥。。。能干嘛。。。。。。。。能吃么。。哎</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-62622">
<article class="comment" id="comment-62622">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">0xc0de</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-62622" rel="nofollow"><time datetime="2014-04-13T04:09:51+00:00" pubdate="">2014年4月13日 at 上午4:09</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第二块代码if(it != mp.end())应改为if(it != mp.end() &amp;&amp; (i+1)!=(it-&gt;second +1))；因为第二种解法如果数组有重复元素 就不正确</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-45427">
<article class="comment" id="comment-45427">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">rtaxa</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45427" rel="nofollow"><time datetime="2014-04-08T12:58:43+00:00" pubdate="">2014年4月8日 at 下午12:58</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不考虑最后将结果排序的话，快排的时间复杂度是O(N) ，而堆排的是O(N*logK)</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-45426">
<article class="comment" id="comment-45426">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Lin</a></span> on <a href="http://www.acmerblog.com/uva-127-accordian-patience-3808.html#comment-45426" rel="nofollow"><time datetime="2014-03-17T04:57:43+00:00" pubdate="">2014年3月17日 at 上午4:57</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不错的代码！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>