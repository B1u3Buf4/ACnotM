<div class="c-top2" id="post-55">
<div class="datetime">2013<br/>12-26</div>
<div class="tit"><h1 class="entry-title">递归与分治策略（3）</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/zhuanti/algorithm" rel="category tag" title="查看算法分析中的全部文章">算法分析</a></span><span class="i4">围观1324次</span><span class="i3"><a class="ds-thread-count" data-thread-key="2932" href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comments" title="《递归与分治策略（3）》上的评论">19 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<h3 class="p0">棋盘覆盖</h3>
<pre class="p0">在一个<span style="font-family: Courier New;">2k×2k </span><span style="font-family: 新宋体;">个方格组成的棋盘中，恰有一个方格与其它方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的</span><span style="font-family: Courier New;">4</span><span style="font-family: 新宋体;">种不同形态的</span><span style="font-family: Courier New;">L</span><span style="font-family: 新宋体;">型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何</span><span style="font-family: Courier New;">2</span><span style="font-family: 新宋体;">个</span><span style="font-family: Courier New;">L</span><span style="font-family: 新宋体;">型骨牌不得重叠覆盖。</span></pre>
<pre class="p0"><p class="p0" style="margin-top: 0pt; margin-bottom: 0pt;"><span style="font-family: 'Courier New'; font-size: 10.5pt; mso-spacerun: 'yes';">棋盘示例<span style="font-family: Courier New;">(k = 2)和四种L型骨牌示例</span><span style="font-family: 新宋体;">：</span></span></p><p class="p0" style="margin-top: 0pt; margin-bottom: 0pt;"><span style="font-family: 'Courier New'; font-size: 10.5pt; mso-spacerun: 'yes';"> </span></p><endfragment><span style="font-family: 新宋体;"><img alt="" src="http://cdn.acmerblog.com/img/1388062592123.jpg"/></span></endfragment></pre>
<p><img alt="" height="51" src="http://cdn.acmerblog.com/img/1388062592393.jpg" width="308"/></p>
<h3 class="p0">分析</h3>
<pre class="p0">当<span style="font-family: Courier New;">k&gt;0</span><span style="font-family: 新宋体;">时，将</span><span style="font-family: Courier New;">2^k×2^k</span><span style="font-family: 新宋体;">棋盘分割为</span><span style="font-family: Courier New;">4</span><span style="font-family: 新宋体;">个</span><span style="font-family: Courier New;">2^(k-1)×2^(k-1)</span><span style="font-family: 新宋体;">子棋盘所示。</span></pre>
<pre class="p0">特殊方格必位于<span style="font-family: Courier New;">4</span><span style="font-family: 新宋体;">个较小子棋盘之一中，其余</span><span style="font-family: Courier New;">3</span><span style="font-family: 新宋体;">个子棋盘中无特殊方格。为了将这</span><span style="font-family: Courier New;">3</span><span style="font-family: 新宋体;">个无特殊方格的子棋盘转化为特殊棋盘，可以用一个</span><span style="font-family: Courier New;">L</span><span style="font-family: 新宋体;">型骨牌覆盖这</span><span style="font-family: Courier New;">3</span><span style="font-family: 新宋体;">个较小棋盘的会合处，从而将原问题转化为</span><span style="font-family: Courier New;">4</span><span style="font-family: 新宋体;">个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为棋盘</span><span style="font-family: Courier New;">1×1</span><span style="font-family: 新宋体;">。</span></pre>
<p class="p0"><span style="font-family: 新宋体;"><img alt="" src="http://cdn.acmerblog.com/img/1388062592476.jpg"/></span></p>
<h3 class="p0">算法复杂度</h3>
<p class="p0"><img alt="" height="161" src="http://cdn.acmerblog.com/img/1388062592729.jpg" width="459"/></p>
<h3 class="p0">实现</h3>
<p class="p0"> </p>
<pre class="brush:cpp ">/* 主题：棋盘覆盖
* 作者：chinazhangjie
* 邮箱：chinajiezhang@gmail.com
* 开发语言：C++
* 开发环境：Code::Blocks 10.05
* 时间: 2010.10.10
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iterator&gt;
using namespace std;

void __chessboard_cover(vector&lt;vector&lt;int&gt; &gt;&amp; cheb,
                        int tx,int ty,
                        int dx,int dy,
                        int size,
                        int&amp; tile);
/* 棋盘覆盖主函数
* cheb: 棋盘数组
* dx: 特殊方格的横坐标
* dy: 特殊方格的纵坐标
*/
void chessboard_cover(vector&lt;vector&lt;int&gt; &gt;&amp; cheb,int dx,int dy)
{
    int tile = 1;
    __chessboard_cover(cheb,0,0,dx,dy,cheb.size(),tile);
}
/* 棋盘覆盖辅助函数
* cheb: 棋盘数组
* tx: 起始横坐标
* ty: 起始纵坐标
* dx: 特殊方格的横坐标
* dy: 特殊方格的横坐标
* size: 棋盘大小
* tile: 骨牌编号
*/
void __chessboard_cover(vector&lt;vector&lt;int&gt; &gt;&amp; cheb,
                        int tx,int ty,
                        int dx,int dy,
                        int size,
                        int&amp; tile)
{
    if (size == 1)
        return ;
    int t = tile ++ ; // L骨牌号
    int s = size / 2; // 分割棋盘

    // 覆盖左上角子棋盘
    if (dx &lt; tx + s &amp;&amp; dy &lt; ty + s) {
        // 特殊方格在此子棋盘中
        __chessboard_cover(cheb,tx,ty,dx,dy,s,tile);
    }
    else {
        // 此棋盘中无特殊方格,用t号骨牌覆盖下角方格
        cheb[tx + s - 1][ty + s - 1] = t;
        // 覆盖其余方格
        __chessboard_cover(cheb,tx,ty,tx + s - 1, ty + s - 1,s,tile);
    }

    // 覆盖右上角子棋盘
    if (dx &gt;= tx + s &amp;&amp; dy &lt; ty + s) {
        // 特殊方格在此棋盘中
        __chessboard_cover(cheb,tx + s,ty,dx,dy,s,tile);
    }
    else {
        // 用t号L型骨牌覆盖左下角
        cheb[tx + s][ty + s - 1] = t;
        __chessboard_cover(cheb,tx + s,ty,tx + s,ty + s - 1,s,tile);
    }

    // 覆盖左下角子棋盘
    if (dx &lt; tx + s &amp;&amp; dy &gt;= ty + s) {
        // 特殊方格在此棋盘中
        __chessboard_cover(cheb,tx,ty + s,dx,dy,s,tile);
    }
    else {
        // 用t号L型骨牌覆盖右上角
        cheb[tx + s - 1][ty + s] = t;
        __chessboard_cover(cheb,tx,ty + s,tx + s - 1,ty + s,s,tile);
    }

    // 覆盖右下角子棋盘
    if (dx &gt;= tx + s &amp;&amp; dy &gt;= ty + s) {
        // 特殊方格在此棋盘中
        __chessboard_cover(cheb,tx + s,ty + s,dx,dy,s,tile);
    }
    else {
        // 用t号L型骨牌覆盖左上角
        cheb[tx + s][ty + s] = t;
        __chessboard_cover(cheb,tx + s,ty + s,tx + s,ty + s,s,tile);
    }
}
int main()
{
    int k = 2;
    int size = pow (2,k);
    vector&lt;vector&lt;int&gt; &gt; cheb(size);
    for (size_t i=  0 ;i &lt; cheb.size(); ++i) {
        cheb[i].resize(size);
    }

    for (int i = 0; i &lt; size; ++ i) {
        for (int j = 0;j &lt; size; ++ j) {
            int dx = i;
            int dy = j;
            cout &lt;&lt; "dx = " &lt;&lt; dx &lt;&lt; " , dy = " &lt;&lt; dy &lt;&lt; endl;
            cheb[dx][dy] = 0;
            chessboard_cover(cheb,dx,dy);

            for (size_t i = 0;i &lt; cheb.size(); ++ i) {
                copy(cheb[i].begin(),cheb[i].end(),ostream_iterator&lt;int&gt;(cout," "));
                cout &lt;&lt; endl;
            }
            cout &lt;&lt; endl;
        }
    }
    return 0;
}</pre>
<p> </p>
<h2 class="p0">线性时间选择</h2>
<p class="p0">给定线性序集中<span style="font-family: Courier New;">n</span><span style="font-family: 新宋体;">个元素和一个整数</span><span style="font-family: Courier New;">k</span><span style="font-family: 新宋体;">，</span><span style="font-family: Courier New;">1</span> ≤ k ≤ n<span style="font-family: 新宋体;">，要求找出这</span><span style="font-family: Courier New;">n</span><span style="font-family: 新宋体;">个元素中第</span><span style="font-family: Courier New;">k</span><span style="font-family: 新宋体;">小的元素。</span></p>
<h3 class="p0">思想</h3>
<p class="p0">// <span style="font-family: 新宋体;">在数组</span><span style="font-family: Courier New;">a</span><span style="font-family: 新宋体;">的</span><span style="font-family: Courier New;">p</span><span style="font-family: 新宋体;">到</span><span style="font-family: Courier New;">r</span><span style="font-family: 新宋体;">区间内找到第</span><span style="font-family: Courier New;">k</span><span style="font-family: 新宋体;">小的元素</span></p>
<p class="p0">template&lt;class Type&gt;</p>
<p class="p0">Type RandomizedSelect(Type a[],int p,int r,int k)</p>
<p class="p0">{</p>
<p class="p0">if (p == r)</p>
<p class="p0">return a[p]; // <span style="font-family: 新宋体;">如果</span><span style="font-family: Courier New;">p</span><span style="font-family: 新宋体;">，</span><span style="font-family: Courier New;">r</span><span style="font-family: 新宋体;">相等，第</span><span style="font-family: Courier New;">n</span><span style="font-family: 新宋体;">小都是</span><span style="font-family: Courier New;">a[p]</span></p>
<p class="p0"> </p>
<p class="p0">// <span style="font-family: 新宋体;">数组</span><span style="font-family: Courier New;">a[p:r]</span><span style="font-family: 新宋体;">被随机分成两个部分，</span><span style="font-family: Courier New;">a[p:i]</span><span style="font-family: 新宋体;">和</span><span style="font-family: Courier New;">a[i+1:r]</span><span style="font-family: 新宋体;">，</span></p>
<p class="p0">// <span style="font-family: 新宋体;">使得</span><span style="font-family: Courier New;">a[p:i]</span><span style="font-family: 新宋体;">中的元素都小于</span><span style="font-family: Courier New;">a[i+1:r]</span><span style="font-family: 新宋体;">中的元素。</span></p>
<p class="p0">int i = RandomizedPartition(a,p,r);</p>
<p class="p0">j = i - p + 1;</p>
<p class="p0">if (k &lt;= j)</p>
<p class="p0">return RandomizedSelect(a,p,i,k);</p>
<p class="p0">  else </p>
<p class="p0">return RandomizedSelect(a,i+1,r,k-j);</p>
<p class="p0">}</p>
<p class="p0">在最坏情况下，算法<span style="font-family: Courier New;">randomizedSelect</span><span style="font-family: 新宋体;">需要</span><span style="font-family: Courier New;">O(n^2)</span><span style="font-family: 新宋体;">计算时间</span><span style="font-family: Courier New;">(</span><span style="font-family: 新宋体;">在找最小元素的时候，总在最大元素处划分</span><span style="font-family: Courier New;">)</span><span style="font-family: 新宋体;">，但可以证明，算法</span><span style="font-family: Courier New;">randomizedSelect</span><span style="font-family: 新宋体;">可以在</span><span style="font-family: Courier New;">O(n)</span><span style="font-family: 新宋体;">平均时间内找出</span><span style="font-family: Courier New;">n</span><span style="font-family: 新宋体;">个输入元素中的第</span><span style="font-family: Courier New;">k</span><span style="font-family: 新宋体;">小元素。</span></p>
<p class="p0">如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的<span style="font-family: Courier New;">2</span><span style="font-family: 新宋体;">个子数组的长度都至多为原数组长度的ε倍</span><span style="font-family: Courier New;">(0&lt;</span><span style="font-family: 新宋体;">ε</span><span style="font-family: Courier New;">&lt;1</span><span style="font-family: 新宋体;">是某个正常数</span><span style="font-family: Courier New;">)</span><span style="font-family: 新宋体;">，那么就可以在最坏情况下用</span><span style="font-family: Courier New;">O(n)</span><span style="font-family: 新宋体;">时间完成选择任务。</span></p>
<p class="p0">例如，若ε<span style="font-family: Courier New;">=9/10</span><span style="font-family: 新宋体;">，算法递归调用所产生的子数组的长度至少缩短</span><span style="font-family: Courier New;">1/10</span><span style="font-family: 新宋体;">。所以，在最坏情况下，算法所需的计算时间</span><span style="font-family: Courier New;">T(n)</span><span style="font-family: 新宋体;">满足递归式</span><span style="font-family: Courier New;">T(n)</span><span style="font-family: 新宋体;">≤</span><span style="font-family: Courier New;">T(9n/10)+O(n) </span><span style="font-family: 新宋体;">。由此可得</span><span style="font-family: Courier New;">T(n)=O(n)</span><span style="font-family: 新宋体;">。</span></p>
<h3 class="p0">步骤</h3>
<p class="p0">第一步，将<span style="font-family: Courier New;">n</span><span style="font-family: 新宋体;">个输入元素划分成é</span><span style="font-family: Courier New;">n/5</span><span style="font-family: 新宋体;">ù个组，每组</span><span style="font-family: Courier New;">5</span><span style="font-family: 新宋体;">个元素，只可能有一个组不是</span><span style="font-family: Courier New;">5</span><span style="font-family: 新宋体;">个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共é</span><span style="font-family: Courier New;">n/5</span><span style="font-family: 新宋体;">ù个。</span></p>
<p class="p0">第二步，递归调用<span style="font-family: Courier New;">select</span><span style="font-family: 新宋体;">来找出这é</span><span style="font-family: Courier New;">n/5</span><span style="font-family: 新宋体;">ù个元素的中位数。如果é</span><span style="font-family: Courier New;">n/5</span><span style="font-family: 新宋体;">ù是偶数，就找它的</span><span style="font-family: Courier New;">2</span><span style="font-family: 新宋体;">个中位数中较大的一个。以这个元素作为划分基准。</span></p>
<h3 class="p0"><span style="font-family: 新宋体;">分析</span></h3>
<h3 class="p0"><span style="font-family: 新宋体;"><img alt="" height="276" src="http://cdn.acmerblog.com/img/1388062593026.jpg" width="671"/></span></h3>
<h3 class="p0">伪代码</h3>
<p class="p0">Type Select(Type a[], int p, int r, int k)</p>
<p class="p0">{</p>
<p class="p0">if (r - p &lt; 75) {</p>
<p class="p0">        // <span style="font-family: 新宋体;">问题的规模足够小，用某个简单排序算法对数组</span><span style="font-family: Courier New;">a[p:r]</span><span style="font-family: 新宋体;">排序</span><span style="font-family: Courier New;">;</span></p>
<p class="p0">        return a[p + k - 1];  </p>
<p class="p0">}</p>
<p class="p0">for (int i = 0; i &lt;= ( r - p - 4 ) / 5 ; i ++ ) {</p>
<p class="p0">         将<span style="font-family: Courier New;">a[p + 5 * i]</span><span style="font-family: 新宋体;">至</span><span style="font-family: Courier New;">a[p + 5 * i + 4]</span><span style="font-family: 新宋体;">的第</span><span style="font-family: Courier New;">3</span><span style="font-family: 新宋体;">小元素与</span><span style="font-family: Courier New;">a[p+i]</span><span style="font-family: 新宋体;">交换位置</span><span style="font-family: Courier New;">;</span></p>
<p class="p0">}</p>
<p class="p0">    // <span style="font-family: 新宋体;">找中位数的中位数，</span><span style="font-family: Courier New;">r - p - 4</span><span style="font-family: 新宋体;">即上面所说的</span><span style="font-family: Courier New;">n - 5</span></p>
<p class="p0">Type x = Select(a, p, p + (r - p - 4 ) / 5, (r - p - 4) / 10);</p>
<p class="p0">// <span style="font-family: 新宋体;">数据</span><span style="font-family: Courier New;">n</span><span style="font-family: 新宋体;">根据</span><span style="font-family: Courier New;">x</span><span style="font-family: 新宋体;">划分开来</span></p>
<p class="p0">int i = Partition(a,p,r,x); </p>
<p class="p0">j = i - p + 1;</p>
<p class="p0">if (k &lt;= j) </p>
<p class="p0">return Select(a,p,i,k);</p>
<p class="p0">else </p>
<p class="p0">return Select(a,i+1,r,k-j);</p>
<p class="p0">}</p>
<h3 class="p0">算法复杂度分析</h3>
<p class="p0"><img alt="" height="124" src="http://cdn.acmerblog.com/img/1388062593633.jpg" width="428"/></p>
<p class="p0">上述算法将每一组的大小定为<span style="font-family: Courier New;">5</span><span style="font-family: 新宋体;">，并选取</span><span style="font-family: Courier New;">75</span><span style="font-family: 新宋体;">作为是否作递归调用的分界点。这</span><span style="font-family: Courier New;">2</span><span style="font-family: 新宋体;">点保证了</span><span style="font-family: Courier New;">T(n)</span><span style="font-family: 新宋体;">的递归式中</span><span style="font-family: Courier New;">2</span><span style="font-family: 新宋体;">个自变量之和</span><span style="font-family: Courier New;">n/5+3n/4=19n/20=</span><span style="font-family: 新宋体;">ε</span><span style="font-family: Courier New;">n</span><span style="font-family: 新宋体;">，</span><span style="font-family: Courier New;">0&lt;</span><span style="font-family: 新宋体;">ε</span><span style="font-family: Courier New;">&lt;1</span><span style="font-family: 新宋体;">。这是使</span><span style="font-family: Courier New;">T(n)=O(n)</span><span style="font-family: 新宋体;">的关键之处。当然，除了</span><span style="font-family: Courier New;">5</span><span style="font-family: 新宋体;">和</span><span style="font-family: Courier New;">75</span><span style="font-family: 新宋体;">之外，还有其他选择。</span></p>
<h3 class="p0"><span style="font-family: 新宋体;">实现</span></h3>
<h3 class="p0"><span style="font-family: 新宋体;">
<div class="cnblogs_code">
<pre><div><span style="color: #008000;">/*</span><span style="color: #008000;"> 主题：线性时间查找问题<br/>* 作者：chinazhangjie<br/>* 邮箱：chinajiezhang@gmail.com<br/>* 开发语言：C++<br/>* 开发环境：Code::Blocks 10.05<br/>* 时间: 2010.10.13<br/></span><span style="color: #008000;">*/</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iostream</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">vector</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">algorithm</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iterator</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/></span><span style="color: #0000ff;">using</span><span style="color: #000000;"> </span><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;<br/><br/></span><span style="color: #008000;">/*</span><span style="color: #008000;"> 线性时间查找<br/>* arr: 数据存储数组<br/>* start:开始查找点<br/>* end: 结束查找点<br/>* n: 查找第n小(n = 1,2,3,...,end-start+1)<br/></span><span style="color: #008000;">*/</span><span style="color: #000000;"><br/>template </span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> T</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>T linear_time_select(vector</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">T</span><span style="color: #000000;">&gt;&amp;</span><span style="color: #000000;"> arr,</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> start,</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> end,</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n)<br/>{<br/>    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (end </span><span style="color: #000000;">-</span><span style="color: #000000;"> start </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> </span><span style="color: #800080;">75</span><span style="color: #000000;">) {<br/>        sort (arr.begin() </span><span style="color: #000000;">+</span><span style="color: #000000;"> start,arr.begin() </span><span style="color: #000000;">+</span><span style="color: #000000;"> end </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">);<br/>        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> arr[start </span><span style="color: #000000;">+</span><span style="color: #000000;"> n </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">];<br/>    }<br/><br/>    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> (end </span><span style="color: #000000;">-</span><span style="color: #000000;"> start </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">4</span><span style="color: #000000;">) </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #800080;">5</span><span style="color: #000000;">; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>        sort (arr.begin() </span><span style="color: #000000;">+</span><span style="color: #000000;"> start </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">5</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> i,arr.begin() </span><span style="color: #000000;">+</span><span style="color: #000000;"> start </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">5</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> i </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">5</span><span style="color: #000000;">);<br/>        swap (</span><span style="color: #000000;">*</span><span style="color: #000000;">(arr.begin() </span><span style="color: #000000;">+</span><span style="color: #000000;"> start </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">5</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;"> i </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">),</span><span style="color: #000000;">*</span><span style="color: #000000;">(arr.begin() </span><span style="color: #000000;">+</span><span style="color: #000000;"> start </span><span style="color: #000000;">+</span><span style="color: #000000;"> i));<br/>    }<br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 找到中位数的中位数</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    T median </span><span style="color: #000000;">=</span><span style="color: #000000;"> linear_time_select(arr,start,<br/>                                  start </span><span style="color: #000000;">+</span><span style="color: #000000;"> (end </span><span style="color: #000000;">-</span><span style="color: #000000;"> start </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">4</span><span style="color: #000000;">) </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #800080;">5</span><span style="color: #000000;"> </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">,<br/>                                  (end </span><span style="color: #000000;">-</span><span style="color: #000000;"> start </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">4</span><span style="color: #000000;">) </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #800080;">10</span><span style="color: #000000;"> </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">);<br/><br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 数据 arr 根据 median 划分开来</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> middle </span><span style="color: #000000;">=</span><span style="color: #000000;"> __partition_by_median(arr,start,end,median);<br/>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> distance </span><span style="color: #000000;">=</span><span style="color: #000000;"> middle </span><span style="color: #000000;">-</span><span style="color: #000000;"> start </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">; </span><span style="color: #008000;">//</span><span style="color: #008000;"> 中位数的位置与start的距离</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (n </span><span style="color: #000000;">&lt;=</span><span style="color: #000000;"> distance)<br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 在前半截</span><span style="color: #008000;"><br/></span><span style="color: #000000;">        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> linear_time_select(arr,start,middle,n);<br/>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br/>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 在后半截</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> linear_time_select(arr,middle </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">,end,n </span><span style="color: #000000;">-</span><span style="color: #000000;"> distance);<br/><br/>}<br/><br/></span><span style="color: #008000;">//</span><span style="color: #008000;"> 将arr按照值median划分开来，并返回界限的位置</span><span style="color: #008000;"><br/></span><span style="color: #000000;">template </span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> T</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> __partition_by_median(vector</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">T</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #000000;">&amp;</span><span style="color: #000000;">arr,</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> start,</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> end,T median)<br/>{<br/>    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">true</span><span style="color: #000000;">) {<br/>        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">true</span><span style="color: #000000;">) {<br/>            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (start </span><span style="color: #000000;">==</span><span style="color: #000000;"> end)<br/>                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> start;<br/>            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (arr[start] </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> median)<br/>                </span><span style="color: #000000;">++</span><span style="color: #000000;"> start;<br/>            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br/>                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;<br/>        }<br/>        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">true</span><span style="color: #000000;">) {<br/>            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (start </span><span style="color: #000000;">==</span><span style="color: #000000;"> end)<br/>                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> end;<br/>            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (arr[end] </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> median) {<br/>                </span><span style="color: #000000;">--</span><span style="color: #000000;"> end;<br/>            }<br/>            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br/>                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;<br/>        }<br/>        swap(arr[start],arr[end]);<br/>    }<br/>}<br/></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br/>{<br/>    vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> arr;<br/>    </span><span style="color: #0000ff;">const</span><span style="color: #000000;"> </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> c </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">2000</span><span style="color: #000000;">;<br/>    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> c; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>        arr.push_back(i);<br/>    }<br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 随机排列</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    random_shuffle(arr.begin(),arr.end());<br/><br/>    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> c</span><span style="color: #000000;">+</span><span style="color: #800080;">1</span><span style="color: #000000;">; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>        cout </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> </span><span style="color: #800000;">"</span><span style="color: #800000;">find the </span><span style="color: #800000;">"</span><span style="color: #000000;"> </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> i </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> </span><span style="color: #800000;">"</span><span style="color: #800000;"> element,position is </span><span style="color: #800000;">"</span><span style="color: #000000;"><br/>            </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> linear_time_select(arr,</span><span style="color: #800080;">0</span><span style="color: #000000;">,c</span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">,i) </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> endl;<br/>    }<br/>    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;<br/>}<br/></span></div></pre>
</div>
<p></p></span></h3>
<h2 class="p0">循环赛日程表</h2>
<p class="p0">题目表述：</p>
<p class="p0">设有n = 2 ^ k 个运动员要进行网球循环赛，设计一个满足以下要求的比赛日程表：</p>
<p class="p0">(1)每个选手必须与其他n-1个选手各赛一次；</p>
<p class="p0">(2)每个选手一天只能赛一次；</p>
<p class="p0">(3)循环赛一共进行n-1天。</p>
<p class="p0">按分治策略，将所有的选手分为两半，n个选手的比赛日程表就可以通过为n/2个选手设计的比赛日程表来决定。递归地用对选手进行分割，直到只剩下2个选手时，比赛日程表的制定就变得很简单。这时只要让这2个选手进行比赛就可以了。</p>
<p class="p0"><img alt="" height="327" src="http://cdn.acmerblog.com/img/1388062593907.jpg" width="389"/></p>
<h3 class="p0">实现</h3>
<p class="p0"> </p>
<pre class="brush:cpp ">/* 主题：循环赛日程表
* 作者：chinazhangjie
* 邮箱：chinajiezhang@gmail.com
* 开发语言：C++
* 开发环境：Code::Blocks 10.05
* 时间: 2010.10.13
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iterator&gt;
#include &lt;iomanip&gt;
using namespace std;
void __table(vector&lt;vector&lt;int&gt; &gt;&amp; arr,int start,int end);
void round_match_table(vector&lt;vector&lt;int&gt; &gt;&amp; arr)
{
    int count = arr.size();
    for (int i = 0;i &lt; count;++ i) {
        arr[0][i] = i + 1;
    }
    __table(arr,0,count-1);
}
void __table(vector&lt;vector&lt;int&gt; &gt;&amp; arr,int start,int end)
{
    if (end - start + 1 == 2) {
        arr[1][start] = arr[0][end];
        arr[1][end] = arr[0][start];
        return ;
    }
    int half = (end - start + 1) / 2;
    // 左上角
    __table(arr,start,start + half -1 );
    // 右上角
    __table(arr,start + half,end);
    // 左下角
    for (int i = 0;i &lt; half; ++ i) {
        for (int j = start; j &lt;= end; ++ j) {
            arr[i + half][j-half] = arr[i][j];
        }
    }
    // 右下角（其实左下角和右下角可以在上一个循环中实现的，
    // 但是为了算法结构清晰，因此分为两个循环）
    for (int i = 0;i &lt; half; ++ i) {
        for (int j = start; j &lt; end; ++j) {
            arr[i + half][j + half] = arr[i][j];
        }
    }
}
int main()
{
    int k = 4;
    int size = pow(2,k);
    vector&lt;vector&lt;int&gt; &gt; arr(size);
    for (int i = 0; i &lt; size; ++ i) {
        arr[i].resize(size);
    }

    round_match_table(arr);

    for (int i = 0;i &lt; size; ++ i) {
        for (int j = 0;j &lt; size; ++ j) {
            cout &lt;&lt; std::setw(3) &lt;&lt; arr[i][j];
        }
        cout &lt;&lt; endl;
    }
    return 0;
}</pre>
<pre><strong>Gray码问题</strong></pre>
<pre><strong>实现</strong></pre>
<h3>
<div class="cnblogs_code">
<pre><div>&lt;<br/><br/>Code highlighting produced by Actipro CodeHighlighter (freeware)<br/>http://www.CodeHighlighter.com/<br/><br/>&gt;<span style="color: #008000;">/*</span><span style="color: #008000;"> 主题：gray码<br/>* 作者：chinazhangjie<br/>* 邮箱：chinajiezhang@gmail.com<br/>* 开发语言：C++<br/>* 开发环境：Code::Blocks 10.05<br/>* 时间: 2010.10.15<br/></span><span style="color: #008000;">*/</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iostream</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">vector</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">iterator</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/>#include </span><span style="color: #000000;">&lt;</span><span style="color: #000000;">cmath</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br/></span><span style="color: #0000ff;">using</span><span style="color: #000000;"> </span><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;<br/><br/></span><span style="color: #008000;">/*</span><span style="color: #008000;"> gray code<br/>* rows: 行数(2^n)<br/>* cols: 列数(n)<br/>* arr: rows行，cols列的存储数组<br/></span><span style="color: #008000;">*/</span><span style="color: #000000;"><br/><br/></span><span style="color: #0000ff;">void</span><span style="color: #000000;"> gray_code(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> rows,</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cols,vector</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #000000;">&gt;&amp;</span><span style="color: #000000;"> arr)<br/>{<br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 第一行，递归结束</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (rows </span><span style="color: #000000;">==</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">)<br/>        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;<br/><br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 确定第一列，前半部分为0,后半部分为1</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> rows </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">; </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>        arr[i][cols </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;<br/>        arr[rows </span><span style="color: #000000;">-</span><span style="color: #000000;"> i </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">][cols </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">;<br/>    }<br/><br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 递归完成rows列数据第cols列</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    gray_code(rows </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">, cols </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">,arr);<br/><br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 对称复制</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> k </span><span style="color: #000000;">=</span><span style="color: #000000;"> rows </span><span style="color: #000000;">/</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">; k </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> rows; </span><span style="color: #000000;">++</span><span style="color: #000000;"> k) {<br/>        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> j </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;j </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> cols </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">; </span><span style="color: #000000;">++</span><span style="color: #000000;"> j) {<br/>            arr[k][j] </span><span style="color: #000000;">=</span><span style="color: #000000;"> arr[rows </span><span style="color: #000000;">-</span><span style="color: #000000;"> k </span><span style="color: #000000;">-</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">][j];<br/>        }<br/>    }<br/>}<br/><br/></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br/>{<br/>    </span><span style="color: #0000ff;">const</span><span style="color: #000000;"> </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cols </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">3</span><span style="color: #000000;">;<br/>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> rows </span><span style="color: #000000;">=</span><span style="color: #000000;"> pow(</span><span style="color: #800080;">2</span><span style="color: #000000;">,cols);<br/>    vector</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">vector</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> arr(rows);<br/>    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (size_t i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> arr.size(); </span><span style="color: #000000;">++</span><span style="color: #000000;"> i)  {<br/>        arr[i].resize(cols);<br/>    }<br/>    gray_code(rows,cols,arr);<br/><br/>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> output</span><span style="color: #008000;"><br/></span><span style="color: #000000;">    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (size_t i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> arr.size(); </span><span style="color: #000000;">++</span><span style="color: #000000;"> i) {<br/>        copy(arr[i].rbegin(),arr[i].rend(),ostream_iterator</span><span style="color: #000000;">&lt;</span><span style="color: #0000ff;">int</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">(cout,</span><span style="color: #800000;">"</span><span style="color: #800000;"> </span><span style="color: #800000;">"</span><span style="color: #000000;">));<br/>        cout </span><span style="color: #000000;">&lt;&lt;</span><span style="color: #000000;"> endl;<br/>    }<br/>    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;<br/>}<br/></span></div></pre>
</div>
</h3><p> </p>
<p>归并排序
</p><h3>实现</h3>
<p> </p>
<pre class="brush:cpp ">/* 主题：归并排序
* 作者：chinazhangjie
* 邮箱：chinajiezhang@gmail.com
* 开发语言：C++
* 开发环境：Code::Blocks 10.05
* 时间: 2010.10.15
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;


template &lt;class T&gt;
void merge(vector&lt;T&gt;&amp; arr,int start ,int middle,int end)
{
    int n1 = middle - start + 1;
    int n2 = end - middle;
    vector&lt;T&gt; left(n1);
    vector&lt;T&gt; right(n2);
    int i,j,k;

    for (i = 0;i &lt; n1; ++ i)
        left[i] = arr[start + i];
    for (j = 0;j &lt; n2; ++ j)
        right[j] = arr[middle + j + 1];

    i = j = 0;
    k = start;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (left[i] &lt; right[j])
            arr[k ++] = left[i ++];
        else
            arr[k ++] = right[j ++];
    }
    while (i &lt; n1)
        arr[k ++] = left[i ++ ];
    while (j &lt; n2)
        arr[k ++] = right[j ++];
}

template &lt;class T&gt;
void sort(vector&lt;T&gt;&amp; arr,int start,int end)
{
    // getchar();
    if (start &lt; end)
    {
        int middle = (start + end) / 2;
        sort(arr,start,middle);
        sort(arr,middle + 1,end);
        merge(arr,start,middle,end);
    }
}

int main()
{
    const int length = 20;
    vector&lt;int&gt; arr(length);
    for (size_t i = 0;i &lt; arr.size(); ++ i)
        arr[i] = i;
    random_shuffle(arr.begin(),arr.end());

    copy(arr.begin(),arr.end(),ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    sort(arr,0,length - 1);

    copy(arr.begin(),arr.end(),ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return 0;
}</pre>
<p> </p>
<p> </p>
<pre><strong>参考资料 《算法分析与设计（第二版）》王晓东编著</strong></pre>
<pre><strong>授课教师 张阳教授</strong></pre>
<p>转自：http://www.cnblogs.com/chinazhangjie/archive/2010/10/13/1850583.html</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-87481">
<article class="comment" id="comment-87481">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919456183" rel="external nofollow">新用户630872</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-87481" rel="nofollow"><time datetime="2017-04-13T06:42:36+00:00" pubdate="">2017年4月13日 at 上午6:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>哪一部神剧?</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-87480">
<article class="comment" id="comment-87480">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919456183" rel="external nofollow">新用户630872</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-87480" rel="nofollow"><time datetime="2017-04-13T06:42:36+00:00" pubdate="">2017年4月13日 at 上午6:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>哪一部神剧?</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-87479">
<article class="comment" id="comment-87479">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919456183" rel="external nofollow">新用户630872</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-87479" rel="nofollow"><time datetime="2017-04-13T06:42:36+00:00" pubdate="">2017年4月13日 at 上午6:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>哪一部神剧?</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-87478">
<article class="comment" id="comment-87478">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919456183" rel="external nofollow">新用户630872</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-87478" rel="nofollow"><time datetime="2017-04-13T06:42:36+00:00" pubdate="">2017年4月13日 at 上午6:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>哪一部神剧?</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-87477">
<article class="comment" id="comment-87477">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919456183" rel="external nofollow">新用户630872</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-87477" rel="nofollow"><time datetime="2017-04-13T06:42:36+00:00" pubdate="">2017年4月13日 at 上午6:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>哪一部神剧?</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-43816">
<article class="comment" id="comment-43816">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">gnipuohz</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43816" rel="nofollow"><time datetime="2015-06-24T10:12:04+00:00" pubdate="">2015年6月24日 at 上午10:12</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>正确</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-18829">
<article class="comment" id="comment-18829">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">bluesky</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-18829" rel="nofollow"><time datetime="2015-03-01T20:19:56+00:00" pubdate="">2015年3月1日 at 下午8:19</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>51行错了，改为：void Union(struct subset subsets[], int x, int y)</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-43813">
<article class="comment" id="comment-43813">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Klaus</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43813" rel="nofollow"><time datetime="2015-03-01T05:29:14+00:00" pubdate="">2015年3月1日 at 上午5:29</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>还真是，i7的cpu跑了3秒</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-43815">
<article class="comment" id="comment-43815">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">pascal</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43815" rel="nofollow"><time datetime="2015-02-10T19:06:33+00:00" pubdate="">2015年2月10日 at 下午7:06</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不错，再多来的CF上面的题</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-18828">
<article class="comment" id="comment-18828">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">haojunyu</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-18828" rel="nofollow"><time datetime="2015-02-04T08:34:21+00:00" pubdate="">2015年2月4日 at 上午8:34</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>L（X [0 .. M-1]，Y [0 .. N-1]）= 1 + L（X [0 .. M-2]，Y [0 .. N-1]）这个地方也也有笔误<br/>
应改为L（X [0 .. M-1]，Y [0 .. N-1]）= 1 + L（X [0 .. M-2]，Y [0 .. N-2]）</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-43814">
<article class="comment" id="comment-43814">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">xrjervis</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43814" rel="nofollow"><time datetime="2014-11-09T05:56:29+00:00" pubdate="">2014年11月9日 at 上午5:56</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不错，感谢分享。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-43812">
<article class="comment" id="comment-43812">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">943965021</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43812" rel="nofollow"><time datetime="2014-08-09T16:08:32+00:00" pubdate="">2014年8月9日 at 下午4:08</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>有一点问题。。后面动态规划的程序中<br/>
int dp[n+1][W+1];<br/>
会报错  提示表达式必须含有常量值。该怎么修改呢。。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-43809">
<article class="comment" id="comment-43809">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">1173954900</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43809" rel="nofollow"><time datetime="2014-07-21T05:06:07+00:00" pubdate="">2014年7月21日 at 上午5:06</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>妈呀！这个模板好长OwQ！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-43817">
<article class="comment" id="comment-43817">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">mcitdkj</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43817" rel="nofollow"><time datetime="2014-07-05T11:20:19+00:00" pubdate="">2014年7月5日 at 上午11:20</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>其实不需要用LCA，用DFS+vector更简单</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-43819">
<article class="comment" id="comment-43819">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">ForgetVay</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43819" rel="nofollow"><time datetime="2014-06-20T13:07:11+00:00" pubdate="">2014年6月20日 at 下午1:07</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>对，就是把这32位当成一个长度为32的数</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-43810">
<article class="comment" id="comment-43810">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Klaus</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43810" rel="nofollow"><time datetime="2014-06-17T01:23:48+00:00" pubdate="">2014年6月17日 at 上午1:23</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>0000</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-43811">
<article class="comment" id="comment-43811">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">rick</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43811" rel="nofollow"><time datetime="2014-05-24T20:22:43+00:00" pubdate="">2014年5月24日 at 下午8:22</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很给力啊，学习了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-43808">
<article class="comment" id="comment-43808">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">hsp_77_abc</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43808" rel="nofollow"><time datetime="2014-05-14T02:31:58+00:00" pubdate="">2014年5月14日 at 上午2:31</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p><strong>Gucci New Fall Arrivals</strong></p>
<p>This is really nice to know. I hope it will be successful in the future. Good job on this and keep up the good work.</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-43818">
<article class="comment" id="comment-43818">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Ding Qiangyuan</a></span> on <a href="http://www.acmerblog.com/divide-and-conquer-2-2932.html#comment-43818" rel="nofollow"><time datetime="2014-04-15T00:38:49+00:00" pubdate="">2014年4月15日 at 上午12:38</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>其实就是DFS搜索，数据量较小，穷举了所有情况</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>