<div class="c-top2" id="post-55">
<div class="datetime">2013<br/>12-11</div>
<div class="tit"><h1 class="entry-title">HDU 1480 钥匙计数之二-递推-[解题报告] C++</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a>, <a href="http://www.acmerblog.com/category/basis/enumeration" rel="category tag" title="查看枚举中的全部文章">枚举</a>, <a href="http://www.acmerblog.com/category/basis/recurrence" rel="category tag" title="查看递推中的全部文章">递推</a></span><span class="i4">围观1018次</span><span class="i3"><a class="ds-thread-count" data-thread-key="2024" href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comments" title="《HDU 1480 钥匙计数之二-递推-[解题报告] C++》上的评论">13 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">钥匙计数之二</h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
一把钥匙有N个槽，2&lt;N&lt;26槽深为1，2，3，4,5,6。每钥匙至少有3个不同的深度且相连的槽其深度之差不得为5。求这样的钥匙的总数。  </div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
本题无输入 </div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
对2&lt;N&lt;26，输出满足要求的钥匙的总数。</div>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
N=3: 104
N=4: 904
N=5: 5880
.
.
.
.
.
N=25: 8310566473196300280</pre>
<p> <!-- problem end --></p>
<p><span style="font-family:tahoma,helvetica,arial; line-height:21px; background-color:rgb(255,255,204)"></span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:24px">hdu 1438 <span style="font-family:tahoma,helvetica,'microsoft yahei',arial">钥匙计数之一</span></span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:18px">递推方程式如下<br/>
1：如果X是钥匙， 则X1/2/3/4也是， 所以a[I]=a[I-1]*4</span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:18px"><br/>
2: 如果X不是， X2/3是则X由1/4组成， 但要除去全1和全4， 所以a[I]+=(2^(I-1)-2)*2</span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:18px">后缀2或者3加上就成为钥匙的话，必然是没满足需要3个不同深度槽这一项，故X必然由1/4组成<br/>
</span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:18px"><br/>
3 <wbr>如果X不是 X1/4是。则X=Y（1/4） M=X1/4=Y（4/1）（1/4）</wbr></span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:18px"><br/>
前I-2位可以是1234，但要除去全为1/4的情况 还有就是X是钥匙且X是以1/4结尾<br/>
的情况。我们用b[I]数组表示i位时以1/4结尾的的数量</span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:18px"> <wbr> <wbr> temp<span style="word-wrap:normal; word-break:normal">=（4^(i-2)-2^(i-2)）* 2 – b[i-1];</span></wbr></wbr></span></p>
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun">
<span style="font-size:18px">则 b[i]=a<span style="word-wrap:normal; word-break:normal">[</span>i<span style="word-wrap:normal; word-break:normal">-</span><span style="word-wrap:normal; word-break:normal">1</span><span style="word-wrap:normal; word-break:normal">]*</span><span style="word-wrap:normal; word-break:normal">2</span><span style="word-wrap:normal; word-break:normal">+</span>temp<span style="word-wrap:normal; word-break:normal">;</span></span></p>
<pre class="brush:cpp ">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define N 35

__int64 a[N], b[N];

int main()
{
    a[2] = 0; b[2] = 0;
    a[3] = 8; b[3] = 4;
    for (int i = 4; i &lt; 32; i++)
    {
        a[i] = 4 * a[i-1];
        a[i] += (__int64)(pow(2.0, i-1) * 2) - 4;
        __int64 temp = (__int64)(pow(4.0, i-2) - pow(2.0, i-2)) * 2 - b[i-1];
        a[i] += temp;
        b[i] = 2 * a[i-1] + temp;
    }

    for (int i = 2; i &lt; 32; i++)
    {
        printf("N=%d: %I64d\n", i, a[i]);
    }
    return 0;
}</pre>
<p><span style="font-family:tahoma,helvetica,arial; line-height:21px; background-color:rgb(255,255,204)"><br/>
</span></p>
<p><span style="font-family:tahoma,helvetica,arial; font-size:14px; line-height:21px; background-color:rgb(255,255,204)"><br/>
</span></p>
<p><span style="font-family:tahoma,helvetica,arial; line-height:21px; background-color:rgb(255,255,204)"></span></p>
<h2 class="title content-title" style="margin:0px 0px 10px; padding:0px; font-family:tahoma,helvetica,'microsoft yahei',arial; font-weight:normal">
<span style="font-size:24px">hdu1480 钥匙计数之二</span></h2>
<p><span style="font-family:tahoma,helvetica,arial; line-height:21px; background-color:rgb(255,255,204)"><span style="font-size:18px">设lock[i]表示：有 i个槽的钥匙的个数</span></span></p>
<p><span style="background-color:rgb(255,255,204)"><span style="font-size:18px"><span style="font-family:tahoma,helvetica,arial; line-height:21px">设one[i]表示：有 i个槽且左边第一个槽深度为1的钥匙的个数</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">设two[i]表示：有 i个槽且左边第一个槽深度为2的钥匙的个数</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">..</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">..</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">设six[i]表示：有 i个槽且左边第一个槽深度为6的钥匙的个数</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">则显然：lock[i]=one[i]+two[i]+ three[i]+four[i]+five[i]+six[i] </span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">由于易知：one[i]=six[i],two[i]=three[i]=four[i]=five[i]</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">则可以得到：lock[i]=one[i]*2+two[i]*4 </span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">其中：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">one[i]=one[i-1]+two[i-1]+three[i-1]+four[i-1]+five[i-1]+a[i];</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">=one[i-1]+two[i-1]*4 +a[i]</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">two[i]=one[i-1]*2+two[i-1]*4 +b[i]</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">其中，a[i] 和b[i]的含义分别是：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">a[i]表示“有 i个槽且左边第一个槽深度为1，同时这种钥匙在除掉第一个槽后不再是钥匙”的钥匙的个数。</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">例如 123,124,125,134,135,145,126,136,146,156 就属于这种情况。</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">b[i]表示“有 i个槽且左边第一个槽深度为2，同时这种钥匙在除掉第一个槽后不再是钥匙” 的钥匙的个数。 </span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">分析到这里，可以知道，关键的是求a[i]和b[i]，我们可以得到如下表达式：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">a[i]=(2^(i-1)-2)*6+(2^(i-2)-1)*4</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">b[i]=(2^(i-1)-2)*9</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">其中，a[i] 的各部分的含义如下：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">(2^(i-1)-2)*6：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">当去掉第一位，后面i-1位只有 (2,3)或者 (2,4) 或者(2,5) 或者(3,4) 或者(3,5) 或者(4,5)两种数字的时候，显然是不合法的钥匙（不满足至少有3个不同的深度），加上第一位的1则显然是一个合格的钥匙。所以后面的数字可以为一个组合中两个数字的任意一个，根据乘法原理i-1位一共有2^(i-1)种组合，当然还需要去掉两种特殊情况，就是后面i-1位完全相同的情况。满足这种条件的一共有上面六种组合，所以得到(2^(i-1)-2)*6。</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">(2^(i-2)-1)*4：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">当去掉第一位，后面i-1位只有 (2,6)或者 (3,6) 或者(4,6) 或者(5，6)两种数字的时候，显然是不合法的钥匙（不满足至少有3个不同的深度），加上第一位的1则“可能”是一个合格的钥匙。因为要注意满足“相连的槽其深度之差不得为5”这个条件，所以，紧跟着1的绝对不能是6，这样，相对于上面的分析，后面i-2位可以是每组中的任意一个，所以有2^(i-2)，还要减去1是因为同样要排除后面全部是和第2位一样的数字这样的情况。满足这种条件的一共有上面的四种组合，所以得到(2^(i-2)-1)*4。</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">b[i] 的含义如下：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">(2^(i-1)-2)*9：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">当去掉第一位，后面i-1位只有 (1,3)或者 (1,4) 或者(1,5) 或者(3,4) 或者(3,5) 或者(3,6) 或者(4,5) 或者(4,6) 或者(5,6) 两种数字的时候，显然是不合法的钥匙（不满足至少有3个不同的深度），加上第一位的1则显然是一个合格的钥匙。所以后面的数字可以为一个组合中两个数字的任意一个，根据乘法原理i-1位一共有2^(i-1)种组合，当然还需要去掉两种特殊情况，就是后面i-1位完全相同的情况。满足这种条件的一共有上面9种组合，所以得到(2^(i-1)-2)*9。</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">目前为止，我们可以求出所有的a[i]和b[i]，而且知道了递推关系，只要再做一点简单的工作就可以了，那就是还需要初始值，当然，很容易枚举出最简单的情况</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">one[3]=16;</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">two[3]=18;</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">这样，整个问题就解决了。</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
<span style="font-family:tahoma,helvetica,arial; line-height:21px">特别说明：</span><br style="font-family:tahoma,helvetica,arial; line-height:21px"/><br/>
</span></span></p>
<p><span style="font-family:tahoma,helvetica,arial; line-height:21px; background-color:rgb(255,255,204)"><span style="font-size:18px">这种递推的题目，就是从f(i-1) 加一个元素，然后枚举出所有可能的情况，推导到f(i),当然这个题目有点麻烦，但是套路是一样的，大家也可以参考一下以前的special number课件,里面对于hdoj_1133 Buy the Ticket这个题目的分析，里面的思路和这个完全一样。</span></span></p>
<p><span style="font-family:tahoma,helvetica,arial; font-size:14px; line-height:21px; background-color:rgb(255,255,204)"><br/>
</span></p>
<p><span style="font-family:tahoma,helvetica,arial; font-size:14px; line-height:21px"></span></p>
<pre class="brush:cpp "><span style="background-color:rgb(255,255,204)">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define N 35

__int64 one[N], two[N], lock[N], a[N], b[N];

int main()
{
	one[3] = 16; two[3] = 18; lock[3] = 104;
	for (int i = 4; i &lt; 26; i++)
	{
		a[i] = ((__int64)(pow(2.0, i-1))-2) * 6 + 4 * ((__int64)(pow(2.0, i-2))-1);
		b[i] = 9 * ((__int64)(pow(2.0, i-1))-2);
		one[i] = one[i-1] + 4 * two[i-1] + a[i];
		two[i] = 2 * one[i-1] + 4 * two[i-1] + b[i];
		lock[i] = 2 * one[i] + 4 * two[i];
	}

	for (int i = 3; i &lt; 26; i++)
	{
		printf("N=%d: %I64d\n", i, lock[i]);
	}
	return 0;
}</span></pre>
<p><span style="background-color:rgb(255,255,204)"><br/>
</span></p>
<p>解题报告转自：http://blog.csdn.net/kk806601756/article/details/11764571</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-41158">
<article class="comment" id="comment-41158">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">OrangeGuy</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-41158" rel="nofollow"><time datetime="2015-07-12T07:48:46+00:00" pubdate="">2015年7月12日 at 上午7:48</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>如果两个序列的最后字符不匹配（即X [M-1]！= Y [N-1]）<br/>
L（X [0 .. M-1]，Y [0 .. N-1]）= MAX（L（X [0 .. M-2]，Y [0 .. N-1]），L（X [0 .. M-1]，Y [0 .. N-1]）<br/>
这里写错了吧。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-61626">
<article class="comment" id="comment-61626">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">haojunyu</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-61626" rel="nofollow"><time datetime="2015-05-19T20:26:40+00:00" pubdate="">2015年5月19日 at 下午8:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第15行代码，/n/n，应该改为\n\n</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-41156">
<article class="comment" id="comment-41156">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">missliuxin</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-41156" rel="nofollow"><time datetime="2015-04-26T19:13:43+00:00" pubdate="">2015年4月26日 at 下午7:13</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>#include &lt;cstdio&gt;<br/>
#include &lt;cstring&gt;</p>
<p>const int MAXSIZE=256;<br/>
//char store[MAXSIZE];<br/>
char str1[MAXSIZE];<br/>
/*<br/>
void init(char *store) {<br/>
    int i;<br/>
    store['A']=’V', store['B']=’W',store['C']=’X',store['D']=’Y',store['E']=’Z';<br/>
    for(i=’F';i&lt;=’Z';++i) store <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> =i-5;<br/>
}<br/>
*/<br/>
int main() {<br/>
    //freopen("input.txt","r",stdin);<br/>
    //init(store);<br/>
    char *p;<br/>
    while(fgets(str1,MAXSIZE,stdin) &amp;&amp; strcmp(str1,"STARTn")==0) {<br/>
        if(p=fgets(str1,MAXSIZE,stdin)) {<br/>
            for(;*p;++p) {<br/>
				//*p=store[*p]<br/>
                if(*p&lt;’A’ || *p&gt;’Z') continue;<br/>
                if(*p&gt;’E') *p=*p-5;<br/>
                else *p=*p+21;<br/>
            }<br/>
            printf("%s",str1);<br/>
        }<br/>
        fgets(str1,MAXSIZE,stdin);<br/>
    }<br/>
    return 0;<br/>
}</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-61624">
<article class="comment" id="comment-61624">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">calvert1991</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-61624" rel="nofollow"><time datetime="2015-03-12T22:57:20+00:00" pubdate="">2015年3月12日 at 下午10:57</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>看见的晚了，只能提交一次唉</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-61627">
<article class="comment" id="comment-61627">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">jixiangniao993</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-61627" rel="nofollow"><time datetime="2015-02-04T17:18:29+00:00" pubdate="">2015年2月4日 at 下午5:18</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的方法，学习了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-61625">
<article class="comment" id="comment-61625">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yunyang088</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-61625" rel="nofollow"><time datetime="2015-01-10T01:51:04+00:00" pubdate="">2015年1月10日 at 上午1:51</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>3，求得所有的为的总和sum—-&gt;所有数的总和<br/>
printf( "Not Possible" );—-&gt;printf("impossible");<br/>
对吗？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-41155">
<article class="comment" id="comment-41155">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yunyang088</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-41155" rel="nofollow"><time datetime="2014-08-13T09:40:49+00:00" pubdate="">2014年8月13日 at 上午9:40</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>a是根先忽略掉，递归子树。剩下前缀bejkcfghid和后缀jkebfghicd，分拆的原则的是每个子树前缀和后缀的节点个数是一样的，根节点出现在前缀的第一个，后缀的最后一个。根节点b出现后缀的第四个位置，则第一部分为四个节点，前缀bejk，后缀jkeb，剩下的c出现在后缀的倒数第2个，就划分为cfghi和 fghic，第3部分就为c、c</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-41157">
<article class="comment" id="comment-41157">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wall_</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-41157" rel="nofollow"><time datetime="2014-08-05T16:51:59+00:00" pubdate="">2014年8月5日 at 下午4:51</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>没错的，九度OJ也有此题</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-61623">
<article class="comment" id="comment-61623">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">digiworm</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-61623" rel="nofollow"><time datetime="2014-07-24T01:36:28+00:00" pubdate="">2014年7月24日 at 上午1:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>aha, welcome!</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-54872">
<article class="comment" id="comment-54872">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Silence.L</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-54872" rel="nofollow"><time datetime="2014-06-21T06:25:53+00:00" pubdate="">2014年6月21日 at 上午6:25</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>还是有些难度的！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-61622">
<article class="comment" id="comment-61622">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">ktcer</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-61622" rel="nofollow"><time datetime="2014-05-18T15:13:50+00:00" pubdate="">2014年5月18日 at 下午3:13</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>最长回文子串可以使用manacher算法，将时间复杂度降到O(n)。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-41159">
<article class="comment" id="comment-41159">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">0xc0de</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-41159" rel="nofollow"><time datetime="2014-05-15T09:40:49+00:00" pubdate="">2014年5月15日 at 上午9:40</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这个条件 “两个数的乘积最小”可以忽略</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-13653">
<article class="comment" id="comment-13653">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">jamoeba</a></span> on <a href="http://www.acmerblog.com/hdu-1480-%E9%92%A5%E5%8C%99%E8%AE%A1%E6%95%B0%E4%B9%8B%E4%BA%8C-2024.html#comment-13653" rel="nofollow"><time datetime="2014-04-27T02:00:18+00:00" pubdate="">2014年4月27日 at 上午2:00</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>给你一组数据吧：29 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 1000。此时的数据量还是很小的，耗时却不短。这种方法确实可以，当然或许还有其他的优化方案，但是优化只能针对某些数据，不太可能在所有情况下都能在可接受的时间内求解出答案。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>