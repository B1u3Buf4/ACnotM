<div class="c-top2" id="post-55">
<div class="datetime">2015<br/>05-23</div>
<div class="tit"><h1 class="entry-title">HDU 4266-The Worm in the Apple-计算几何-[解题报告]HOJ</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/spiderman" rel="author" title="由蜘蛛侠发布">蜘蛛侠</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a>, <a href="http://www.acmerblog.com/category/geometry/convex" rel="category tag" title="查看凸包问题中的全部文章">凸包问题</a>, <a href="http://www.acmerblog.com/category/geometry/solid-geometry" rel="category tag" title="查看立体几何中的全部文章">立体几何</a></span><span class="i4">围观150次</span><span class="i3"><a class="ds-thread-count" data-thread-key="7279" href="http://www.acmerblog.com/hdu-4266-the-worm-in-the-apple-7279.html#comments" title="《HDU 4266-The Worm in the Apple-计算几何-[解题报告]HOJ》上的评论">2 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">The Worm in the Apple</h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
Willy the Worm was living happily in an apple �C until some vile human picked the apple, and started to eat it! Now, Willy must escape!<br/>Given a description of the apple (defined as a convex shape in 3D space), and a list of possible positions in the apple for Willy (defined as 3D points), determine the minimum distance Willy must travel to get to the surface of the apple from each point. </div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
There will be several test cases in the input. Each test case will begin with a line with a single integer <strong>n</strong> (4≤<strong>n</strong>≤1,000), which tells the number of points describing the apple.<br/>On the next <strong>n</strong> lines will be three integers <strong>x</strong>, <strong>y</strong> and <strong>z</strong> (-10,000≤<strong>x</strong>,<strong>y</strong>,<strong>z</strong>≤10,000), where each point (<strong>x</strong>,<strong>y</strong>,<strong>z</strong>) is either on the surface of, or within, the apple. The apple is the convex hull of these points. No four points will be coplanar.<br/>Following the description of the apple, there will be a line with a single integer <strong>q</strong> (1≤<strong>q</strong>≤100,000), which is the number of queries �C that is, the number of points where Willy might be inside the apple. Each of the following <strong>q</strong> lines will contain three integers <strong>x</strong>, <strong>y</strong> and <strong>z</strong> (-10,000≤<strong>x</strong>,<strong>y</strong>,<strong>z</strong>≤10,000), representing a point (<strong>x</strong>,<strong>y</strong>,<strong>z</strong>) where Willy might be. All of Willy’s points are guaranteed to be inside the apple. The input will end with a line with a single 0. </div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
There will be several test cases in the input. Each test case will begin with a line with a single integer <strong>n</strong> (4≤<strong>n</strong>≤1,000), which tells the number of points describing the apple.<br/>On the next <strong>n</strong> lines will be three integers <strong>x</strong>, <strong>y</strong> and <strong>z</strong> (-10,000≤<strong>x</strong>,<strong>y</strong>,<strong>z</strong>≤10,000), where each point (<strong>x</strong>,<strong>y</strong>,<strong>z</strong>) is either on the surface of, or within, the apple. The apple is the convex hull of these points. No four points will be coplanar.<br/>Following the description of the apple, there will be a line with a single integer <strong>q</strong> (1≤<strong>q</strong>≤100,000), which is the number of queries �C that is, the number of points where Willy might be inside the apple. Each of the following <strong>q</strong> lines will contain three integers <strong>x</strong>, <strong>y</strong> and <strong>z</strong> (-10,000≤<strong>x</strong>,<strong>y</strong>,<strong>z</strong>≤10,000), representing a point (<strong>x</strong>,<strong>y</strong>,<strong>z</strong>) where Willy might be. All of Willy’s points are guaranteed to be inside the apple. The input will end with a line with a single 0.</div>
<div>
<p class="mytitle"> 样例输入:</p>
</div>
<pre class="mypanel iopanel">
6
0 0 0
100 0 0
0 100 0
0 0 100
20 20 20
30 20 10
4
1 1 1
30 30 35
7 8 9
90 2 2
0</pre>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
1.0000
2.8868
7.0000
2.0000</pre>
<p> <!-- problem end --></p>
<p><span style="font-family:Arial; font-size:18px; line-height:26px">转载请注明出处，谢谢</span><a style="color:rgb(202,0,0); text-decoration:none; font-family:Arial; font-size:18px; line-height:26px"></a><a style="color:rgb(202,0,0); text-decoration:none; font-family:Arial; font-size:18px; line-height:26px">http://blog.csdn.net/acm_cxlove/article/details/7854526</a><span style="font-family:Arial; font-size:18px; line-height:26px">      <br/>
 by—cxlove</span></p>
<p><span style="font-family:Arial; font-size:18px; line-height:26px">题目：求出一个点到三维凸包面的最短距离</span></p>
<p><span style="font-family:Arial; font-size:18px; line-height:26px"><a>http://acm.hdu.edu.cn/showproblem.php?pid=4266</a></span></p>
<p><span style="font-family:Arial; font-size:18px; line-height:26px">没啥好说的，只是发一下，保存个模板。。。<br/>
</span></p>
<p><span style="font-family:Arial; font-size:18px; line-height:26px">求出凸包后，暴力枚举每一个面，求出距离取最短</span></p>
<p><span style="font-family:Arial; font-size:18px; line-height:26px">到面的距离可以用体积除以面的面积</span></p>
<p><span style="font-family:Arial; font-size:18px; line-height:26px"></span></p>
<pre class="brush:cpp" name="code"> #include&lt;stdio.h&gt;
 #include&lt;string.h&gt;
 #include&lt;math.h&gt;
 #include&lt;algorithm&gt;
 #include &lt;iostream&gt;
 using namespace std;
 #define eps 1e-9
 #define N 1100
 #define inf 1&lt;&lt;30
 struct TPoint{
     double x,y,z;
     TPoint(){}
     TPoint(double _x,double _y,double _z):x(_x),y(_y),z(_z){}
     TPoint operator-(const TPoint p) {return TPoint(x-p.x,y-p.y,z-p.z);}
     TPoint operator*(const TPoint p) {return TPoint(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);}//叉积
     double operator^(const TPoint p) {return x*p.x+y*p.y+z*p.z;}//点积
 };
 TPoint dd;
 struct fac{//
     int a,b,c;//凸包一个面上的三个点的编号
     bool ok;//该面是否是最终凸包中的面
 };
 TPoint xmult(TPoint u,TPoint v){
     return TPoint(u.y*v.z-v.y*u.z,u.z*v.x-u.x*v.z,u.x*v.y-u.y*v.x);
 }
 double dmult(TPoint u,TPoint v){
     return u.x*v.x+u.y*v.y+u.z*v.z;
 }
 TPoint subt(TPoint u,TPoint v){
     return TPoint(u.x-v.x,u.y-v.y,u.z-v.z);
 }
 double vlen(TPoint u){
     return sqrt(u.x*u.x+u.y*u.y+u.z*u.z);
 }
 TPoint pvec(TPoint a,TPoint b,TPoint c){
     return xmult(subt(a,b),subt(b,c));
 }
 double Dis(TPoint a,TPoint b,TPoint c,TPoint d){
     return fabs(dmult(pvec(a,b,c),subt(d,a)))/vlen(pvec(a,b,c));
 }
 struct T3dhull{
     int n;//初始点数
     TPoint ply[N];//初始点
     int trianglecnt;//凸包上三角形数
     fac tri[N];//凸包三角形
     int vis[N][N];//点i到点j是属于哪个面
     double dist(TPoint a){return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);}//两点长度
     double area(TPoint a,TPoint b,TPoint c){return dist((b-a)*(c-a));}//三角形面积*2
     double volume(TPoint a,TPoint b,TPoint c,TPoint d){return (b-a)*(c-a)^(d-a);}//四面体有向体积*6
     double ptoplane(TPoint &amp;p,fac &amp;f){//正：点在面同向
          TPoint m=ply[f.b]-ply[f.a],n=ply[f.c]-ply[f.a],t=p-ply[f.a];
          return (m*n)^t;
     }
     void deal(int p,int a,int b){
         int f=vis[a][b];//与当前面(cnt)共边(ab)的那个面
         fac add;
         if(tri[f].ok){
             if((ptoplane(ply[p],tri[f]))&gt;eps) dfs(p,f);//如果p点能看到该面f，则继续深度探索f的3条边，以便更新新的凸包面
             else{//否则因为p点只看到cnt面，看不到f面，则p点和a、b点组成一个三角形。
                  add.a=b,add.b=a,add.c=p,add.ok=1;
                  vis[p][b]=vis[a][p]=vis[b][a]=trianglecnt;
                  tri[trianglecnt++]=add;
             }
         }
     }
     void dfs(int p,int cnt){//维护凸包，如果点p在凸包外更新凸包
         tri[cnt].ok=0;//当前面需要删除，因为它在更大的凸包里面
 //下面把边反过来(先b,后a)，以便在deal()中判断与当前面(cnt)共边(ab)的那个面。即判断与当头面(cnt)相邻的3个面(它们与当前面的共边是反向的，如下图中(1)的法线朝外(即逆时针)的面130和312,它们共边13，但一个方向是13,另一个方向是31)
         deal(p,tri[cnt].b,tri[cnt].a);
         deal(p,tri[cnt].c,tri[cnt].b);
         deal(p,tri[cnt].a,tri[cnt].c);
     }
     bool same(int s,int e){//判断两个面是否为同一面
         TPoint a=ply[tri[s].a],b=ply[tri[s].b],c=ply[tri[s].c];
         return fabs(volume(a,b,c,ply[tri[e].a]))&lt;eps
             &amp;&amp;fabs(volume(a,b,c,ply[tri[e].b]))&lt;eps
             &amp;&amp;fabs(volume(a,b,c,ply[tri[e].c]))&lt;eps;
     }
     void construct(){//构建凸包
         int i,j;
         trianglecnt=0;
         if(n&lt;4) return ;
         bool tmp=true;
         for(i=1;i&lt;n;i++)//前两点不共点
             if((dist(ply[0]-ply[i]))&gt;eps){
                 swap(ply[1],ply[i]); tmp=false; break;
             }
         if(tmp) return;
         tmp=true;
         for(i=2;i&lt;n;i++)//前三点不共线
             if((dist((ply[0]-ply[1])*(ply[1]-ply[i])))&gt;eps){
                 swap(ply[2],ply[i]); tmp=false; break;
             }
         if(tmp) return ;
         tmp=true;
         for(i=3;i&lt;n;i++)//前四点不共面
            if(fabs((ply[0]-ply[1])*(ply[1]-ply[2])^(ply[0]-ply[i]))&gt;eps){
                 swap(ply[3],ply[i]); tmp=false; break;
            }
         if(tmp) return ;
         fac add;
         for(i=0;i&lt;4;i++){//构建初始四面体(4个点为ply[0],ply[1],ply[2],ply[3])
             add.a=(i+1)%4,add.b=(i+2)%4,add.c=(i+3)%4,add.ok=1;
             if((ptoplane(ply[i],add))&gt;0) swap(add.b,add.c);//保证逆时针，即法向量朝外，这样新点才可看到。
             vis[add.a][add.b]=vis[add.b][add.c]=vis[add.c][add.a]=trianglecnt;//逆向的有向边保存
             tri[trianglecnt++]=add;
         }
         for(i=4;i&lt;n;i++)//构建更新凸包
             for(j=0;j&lt;trianglecnt;j++)//对每个点判断是否在当前3维凸包内或外(i表示当前点,j表示当前面)
                 if(tri[j].ok&amp;&amp;(ptoplane(ply[i],tri[j]))&gt;eps){//对当前凸包面进行判断，看是否点能否看到这个面
                     dfs(i,j); break;//点能看到当前面，更新凸包的面(递归，可能不止更新一个面)。当前点更新完成后break跳出循环
                 }
         int cnt=trianglecnt;//这些面中有一些tri[i].ok=0，它们属于开始建立但后来因为在更大凸包内故需删除的，所以下面几行代码的作用是只保存最外层的凸包
         trianglecnt=0;
         for(i=0;i&lt;cnt;i++)
             if(tri[i].ok)
                 tri[trianglecnt++]=tri[i];
     }
 }hull;
 int main(){
     double now,_min;
     while(scanf("%d",&amp;hull.n)!=EOF){
         if(hull.n==0) break;
         for(int i=0;i&lt;hull.n;i++)
             scanf("%lf%lf%lf",&amp;hull.ply[i].x,&amp;hull.ply[i].y,&amp;hull.ply[i].z);
         hull.construct();
         int q;
         scanf("%d",&amp;q);
         while(q--){
             scanf("%lf%lf%lf",&amp;dd.x,&amp;dd.y,&amp;dd.z);
             double ans=inf;
             for(int i=0;i&lt;hull.trianglecnt;i++){
                 fac tmp=hull.tri[i];
                 ans=min(ans,hull.volume(dd,hull.ply[tmp.a],hull.ply[tmp.b],hull.ply[tmp.c])/hull.area(hull.ply[tmp.a],hull.ply[tmp.b],hull.ply[tmp.c]));
             }
             printf("%.4f\n",ans);
         }
     }
     return 0;
 }
</pre>
<div style="padding-top:20px">
<p style="font-size:12px;">版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
</div>
<p>参考：http://blog.csdn.net/acm_cxlove/article/details/7909002</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-98945">
<article class="comment" id="comment-98945">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919526331" rel="external nofollow">新用户886710</a></span> on <a href="http://www.acmerblog.com/hdu-4266-the-worm-in-the-apple-7279.html#comment-98945" rel="nofollow"><time datetime="2017-04-20T14:27:53+00:00" pubdate="">2017年4月20日 at 下午2:27</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>你都戆7鸠…人地香港人系后英国殖民地人…根本就系英国人…土地也是英国的…人地高尚宁静的生活比你地班大陆灿打破……你仲好意思叫人港灿要人走？走的是你……别去香港骚扰别人！！！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-68649">
<article class="comment" id="comment-68649">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919528132" rel="external nofollow">新用户660499</a></span> on <a href="http://www.acmerblog.com/hdu-4266-the-worm-in-the-apple-7279.html#comment-68649" rel="nofollow"><time datetime="2017-04-11T07:10:17+00:00" pubdate="">2017年4月11日 at 上午7:10</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>粤语和客家话先掐吧，弄清楚谁是中原雅音，再来掐吴语、中原官话</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>