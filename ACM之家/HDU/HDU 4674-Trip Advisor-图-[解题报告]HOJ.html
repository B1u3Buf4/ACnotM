<div class="c-top2" id="post-55">
<div class="datetime">2015<br/>09-17</div>
<div class="tit"><h1 class="entry-title">HDU 4674-Trip Advisor-图-[解题报告]HOJ</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/spiderman" rel="author" title="由蜘蛛侠发布">蜘蛛侠</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a>, <a href="http://www.acmerblog.com/category/graph" rel="category tag" title="查看图论中的全部文章">图论</a>, <a href="http://www.acmerblog.com/category/graph/connectivity" rel="category tag" title="查看连通性问题中的全部文章">连通性问题</a></span><span class="i4">围观78次</span><span class="i3"><a class="ds-thread-count" data-thread-key="7719" href="http://www.acmerblog.com/hdu-4674-trip-advisor-7719.html#comments" title="《HDU 4674-Trip Advisor-图-[解题报告]HOJ》上的评论">一条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">Trip Advisor</h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
There is a strange country somewhere which its transportation network was built following some weird rules: Consider the transportation network as a connected undirected graph G with N nodes and M edges(nodes indicate cities,and people can travel from cities to cities by roads connecting them),the condition that every node in G is in at most one simple cycle holds.<br/>One day Q people of the country want to make a travel, i_th people is located at city U<sub>i</sub>, wants to move to city V<sub>i</sub>(U<sub>i</sub> can be equal to V<sub>i</sub>),and he especially loves city P<sub>i</sub>,so he wonders if there is a path that:
<p>1. starts at U<sub>i</sub>;<br/>2. ends at V<sub>i</sub>;<br/>3. for every pair of adjacent cities in path,there is a road connecting them.<br/>4. visits every city at most once.<br/>5. visits city P<sub>i</sub>;</p>
<p>As a trip advisor,your task is to tell everybody whether there is a path satsifying all his requirements. </p></div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
The input contains several test cases, terminated by EOF. Most of test cases are rather small.<br/>Each testcase contains M + Q + 2 lines. first line contains two integers N, M (1 &lt;= N &lt;= 100000, 1 &lt;= M &lt;= 150000), the number of cities and roads; next M lines each contains two integer b, e indicates that there is a bidirectional-road connecting city b and city e;next line an integer Q (1 ≤ Q ≤ 100000) indicating number of people in that country that want to make a travel, next Q lines each contains three integers U<sub>i</sub>, V<sub>i</sub>, P<sub>i</sub>, denotes the query as we mentioned above. </div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
The input contains several test cases, terminated by EOF. Most of test cases are rather small.<br/>Each testcase contains M + Q + 2 lines. first line contains two integers N, M (1 &lt;= N &lt;= 100000, 1 &lt;= M &lt;= 150000), the number of cities and roads; next M lines each contains two integer b, e indicates that there is a bidirectional-road connecting city b and city e;next line an integer Q (1 ≤ Q ≤ 100000) indicating number of people in that country that want to make a travel, next Q lines each contains three integers U<sub>i</sub>, V<sub>i</sub>, P<sub>i</sub>, denotes the query as we mentioned above.</div>
<div>
<p class="mytitle"> 样例输入:</p>
</div>
<pre class="mypanel iopanel">
6 7
1 2
1 2
3 4
2 4
5 6
5 6
4 5
5
1 6 3
1 6 4
1 2 5
2 2 2
2 2 3</pre>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
No
Yes
No
Yes
No</pre>
<p> <!-- problem end --></p>
<p><span style="font-size:18px; color:#3333ff">题意不用我说了吧，注意题目中说的图是没有环中套环的。</span></p>
<p><span style="font-size:18px; color:#3333ff">这题其实不难，就是烦了点，很容易少考虑情况。</span></p>
<p><span style="font-size:18px; color:#ff0000"><strong>我这里是a走到c要经过b的讨论：</strong></span></p>
<p><span style="font-size:18px; color:#3333ff"><br/>
</span></p>
<p><span style="font-size:18px; color:#3333ff">1.考虑有相同点的情况</span></p>
<p><span style="font-size:18px; color:#3333ff">2.考虑3个点在环内(必定Yes)</span></p>
<p><span style="font-size:18px; color:#3333ff">3.考虑2个点在环内</span></p>
<p><span style="font-size:18px; color:#3333ff">    a，b在环内：如果a是割点就是No，否则Yes</span></p>
<p><span style="font-size:18px; color:#3333ff">    (如何判割点，在缩点后的图的边中添加一个信息，然后用LCA就可以了，具体还要细分2种情况)。</span></p>
<p><span style="font-size:18px; color:#3333ff">    b，c在环内，类似a, b</span></p>
<p><span style="font-size:18px; color:#3333ff">    a，c在环内， 就是情况2</span></p>
<p><span style="font-size:18px; color:#3333ff">4.考虑任意两点都不在同一环内的点</span></p>
<p><span style="font-size:18px; color:#3333ff">   这里情况很多，我们考虑Yes的情况。</span></p>
<p><span style="font-size:18px; color:#3333ff">   一条链的有两种</span></p>
<p><span style="font-size:18px; color:#3333ff">   类似二叉树的有两种</span></p>
<p><span style="font-size:18px; color:#3333ff">   最后一种，很容易忘记：</span></p>
<p><span style="font-size:18px; color:#3333ff">    </span><span style="font-size:18px; color:#ff0000"><strong>b在一个环内，a到c的路径经过点b的联通分量，这条路径进出b的连通分量的只有一个点</strong></span><span style="color:rgb(255,0,0); font-size:18px"><strong>(设其为点x)， 假如    点b是点x，那么Yes，否则No。</strong></span></p>
<p><span style="font-size:18px; color:rgb(51,51,255)"><br/>
</span></p>
<p><span style="font-size:18px; color:#3333ff">代码有很详细的注释</span></p>
<p><span style="font-size:18px; color:#3333ff"></span></p>
<pre class="brush:cpp" code_snippet_id="227359" name="code" snippet_file_name="blog_20140310_1_4070728">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;
const int maxn = 100001;
#define pii pair&lt;int, int&gt;
#define mp make_pair
#define pb push_back
struct Edge {
    int v, next;
    bool vis;
} edge[150001 &lt;&lt; 1];
int head[maxn];
int E;
int x, y, n, m;
int Btype, Time;
int dfn[maxn], low[maxn], Belong[maxn];
int st[maxn], Top;
const int POW = 20;
int d[maxn], p[maxn][20];
int Log[maxn];
vector &lt;pii &gt; edges[maxn];
int a, b, c, aa, bb, cc, ab, ac, bc;
void add_edge(int s, int t) {
    edge[E].v = t;
    edge[E].vis = 0;
    edge[E].next = head[s];
    head[s] = E++;
}
int get_val() {
    int ret = 0;
    char c;
    while((c=getchar())==' '||c=='\n');
        ret=c-'0';
    while((c=getchar())!=' '&amp;&amp;c!='\n')
            ret=ret*10+c-'0';
    return ret;
}

void dfs(int s) {
    int i, t;
    st[++Top] = s;
    dfn[s] = low[s] = ++Time;
    for (i = head[s]; i != -1; i = edge[i].next) {
        if (edge[i].vis)
            continue;
        edge[i].vis = edge[i ^ 1].vis = 1;
        t = edge[i].v;
        if (!dfn[t]) {
            dfs(t);
            low[s] = min(low[s], low[t]);
        } else
            low[s] = min(low[s], dfn[t]);
    }
    if (dfn[s] == low[s]) {
        Btype++;
        do {
            t = st[Top--];
            Belong[t] = Btype;
        } while (t != s);
    }
}
void BCC(int n) {
    int i;
    Time = 0;
    Btype = 0;
    Top = 0;
    memset(dfn, 0, sizeof(int)*(n+1));
    for (i = 1; i &lt;= n; i++)
        if (!dfn[i])
            dfs(i);
}

void dfs(int u, int fa) {
    d[u] = d[fa] + 1;
    p[u][0] = fa;
    for (int i = 1; i &lt; POW; i++)
        p[u][i] = p[p[u][i - 1]][i - 1];
    for (int i = 0; i &lt; (int)edges[u].size(); i++) {
        if (edges[u][i].first == fa) continue;
        dfs(edges[u][i].first, u);
    }
}

int lca(int a, int b) {
    if (d[a] &gt; d[b])
        a ^= b, b ^= a, a ^= b;
    if (d[a] &lt; d[b]) {
        int del = d[b] - d[a];
        for (int i = 0; i &lt; POW; i++)
                if(del &amp; (1&lt;&lt;i))b = p[b][i];
    }
    if (a != b) {
        for (int i = POW - 1; i &gt;= 0; i--)
            if (p[a][i] != p[b][i])
                a = p[a][i], b = p[b][i];
        a = p[a][0], b = p[b][0];
    }
    return a;
}
inline int find(int a, int k) {  //需找第k个父亲
	for(int i = 0; i &lt; POW; i++)
        if(k&amp;(1&lt;&lt;i))a = p[a][i];
    return a;
}

inline bool inside(int u, pii x) {
     for(int i = 0; i &lt; (int)edges[u].size(); i++)
         if(edges[u][i] == x) return 1;
     return 0;
}
int main() {
    int i, j;
    while (~scanf("%d%d", &amp;n, &amp;m)) {
        E = 0;
        memset(head, -1, sizeof(int)*(n+1));
        while (m--) {
            x = get_val(); y = get_val();
            add_edge(x, y);
            add_edge(y, x);
        }
        BCC(n);//边双连通

        for (i = 0; i &lt;= n; i++)
            edges[i].clear();
        //用edges建缩点后的图
        for (i = 1; i &lt;= n; i++)
            for (j = head[i]; ~j; j = edge[j].next) {
                int v = edge[j].v;
                if (Belong[i] != Belong[v])
                    edges[Belong[i]].pb(mp(Belong[v], v));
            }

        dfs(1, 0);
        scanf("%d", &amp;m);
        while (m--) {
            a = get_val(); c = get_val(); b = get_val();

            //1.相同点
            if (a == c) {
                if (a == b)
                    puts("Yes");
                else
                    puts("No");
                continue;
            }
            if (a == b || c == b) {
                puts("Yes");
                continue;
            }

            int aa = Belong[a], bb = Belong[b], cc = Belong[c];  // 缩点后的联通分量编号

            //2.三点在同一环内
            if(aa == bb &amp;&amp; bb == cc) {
                puts("Yes");
                continue;
            }

            int ab = lca(aa, bb), ac = lca(aa, cc), bc = lca(bb, cc);
            //3.两点在同一环内
            if (aa == bb) {     //   a，b在环内
                if (ac == aa) {			//cc是联通分量bb的儿子一侧
                    int t = find(cc, d[cc] - d[aa] - 1);	//t为联通分量cc的第一个儿子
                    if (inside(t, mp(aa, a)))
                        puts("No");
                    else
                        puts("Yes");
                    continue;
                } else {			//cc是在联通分量bb的另一侧
                    if (inside(p[aa][0],mp(aa, a)))  //p[aa][0] 为联通分量cc的第一个父亲
                        puts("No");
                    else
                        puts("Yes");
                    continue;
                }
            }
            if (bb == cc) {   //b，c在环内 类似    a，b在环内
                if (ac == cc) {
                    int t = find(aa, d[aa] - d[cc] - 1);
                    if (inside(t, mp(cc, c)))
                        puts("No");
                    else
                        puts("Yes");
                    continue;
                } else {
                    if (inside(p[cc][0],mp(cc, c)))
                        puts("No");
                    else
                        puts("Yes");
                    continue;
                }

            }

            //考虑博客中说的最后一种，最会忘记的情况
            //找到连通分量bb的最近的两个点x,y
            if (ab == bb)
                x = find(aa, d[aa] - d[bb] - 1);
            else
                x = p[bb][0];
            if (bc == bb)
                y = find(cc, d[cc] - d[bb] - 1);
            else
                y = p[bb][0];
            bool flag = 0;
            int pos;
            for (i = 0; i &lt; (int)edges[x].size(); i++) {
                if(inside(y, edges[x][i])) {
                    flag = 1;  //有相同的交点，那么连通分量一定只有一个出口
                    pos = edges[x][i].second;   //记录出口
                    break;
                }
            }
            if (flag &amp;&amp; pos != b) {    //出口为b Yes 否则No
                puts("No");
                continue;
            }
            //两种链的情况
            if (ab == aa &amp;&amp; bc == bb &amp;&amp; ac == aa) { // a...b...c
                puts("Yes");
                continue;
            }
            if (bc == cc &amp;&amp; ab == bb &amp;&amp; ac == cc) { // c...b...a
                puts("Yes");
                continue;
            }
            //类似二叉树的两种情况
            if (ab == bb &amp;&amp; ac == bc) {
                puts("Yes");
                continue;
            }
            if (ac == ab &amp;&amp; bc == bb) {
                puts("Yes");
                continue;
            }
            puts("No");
        }

    }
    return 0;
}
</pre>
<div style="padding-top:20px">
<p style="font-size:12px;">版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
</div>
<p>参考：http://blog.csdn.net/auto_ac/article/details/10008019</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-97173">
<article class="comment" id="comment-97173">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919456837" rel="external nofollow">新用户246172</a></span> on <a href="http://www.acmerblog.com/hdu-4674-trip-advisor-7719.html#comment-97173" rel="nofollow"><time datetime="2017-04-20T00:52:33+00:00" pubdate="">2017年4月20日 at 上午12:52</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>楼主应 该 为 多 了 两个  弟弟  而感到高兴啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>