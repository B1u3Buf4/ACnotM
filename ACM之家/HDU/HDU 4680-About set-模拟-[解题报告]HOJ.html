<div class="c-top2" id="post-55">
<div class="datetime">2015<br/>09-17</div>
<div class="tit"><h1 class="entry-title">HDU 4680-About set-模拟-[解题报告]HOJ</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/spiderman" rel="author" title="由蜘蛛侠发布">蜘蛛侠</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a>, <a href="http://www.acmerblog.com/category/data-struct" rel="category tag" title="查看数据结构中的全部文章">数据结构</a>, <a href="http://www.acmerblog.com/category/basis/simulate" rel="category tag" title="查看模拟法中的全部文章">模拟法</a></span><span class="i4">围观67次</span><span class="i3"><a class="ds-thread-count" data-thread-key="7725" href="http://www.acmerblog.com/hdu-4680-about-set-7725.html#comments" title="《HDU 4680-About set-模拟-[解题报告]HOJ》上的评论">一条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div align="left" class="panel_title" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Today Zhanyl (sister Zhan as you know) receives a task about set operation. Although she is very good at this task, <br/>
but you know she is very lazy so that she wants you to help her write a program to complete this task. Surly<br/>
Zhanyl is able to solve this question, but you know, she is just lazy …<br/>
Here is the problem, you are given n numbers, each number i has a value A<sub>i</sub>, initially they are in different set. <br/>
Following there are m operations/querys.<br/>
The following is 5 possible kinds of oprations/querys:<br/>
1 u v: Union the set u belongs to and the set v belongs to.<br/>
2 u v: Delete u from its original set and add it to the set v belongs to.<br/>
3 u x: change the value of u to x.  1&lt;=x&lt;=10<sup>9</sup><br/>
4 u: query how many numbers you can choose most in set which u belongs to, so no three numbers can form a triangle.<br/>
5 u l r: query the gcd of the numbers between [l,r] in the set u belongs to, if there is no number between [l,r],you can suppose the answer is -1.  <strong>1&lt;=l&lt;=r&lt;=10<sup>9</sup></strong><br/>
Because Zhanyl is a good person, so she guarantee 1&lt;=u,v&lt;=n above.<br/>
You need to tell Zhanyl the answer to each query.</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
 </div>
<p><br style="font-family:'Times New Roman'; font-size:14px"/></p>
<div align="left" class="panel_title" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
The first line of the input is a single integer T which is the number of test cases.Then comes the T test cases .<br/>
For each test case, the first line contains two integer n and m, n is the number of set initially, m is the number <br/>
of operations/querys.<br/>
Following line contains n integers, A<sub>1</sub>, A<sub>2</sub>, … , A<sub>n</sub>, the value of i-th number.<br/>
Following m lines, each line is a operation or query.
<p>Note that 1&lt;=n,m&lt;=10<sup>5</sup>, 1&lt;=A<sub>i</sub>&lt;=10<sup>9</sup></p></div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
 </div>
<p><br style="font-family:'Times New Roman'; font-size:14px"/></p>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
<br/>
 </div>
<div>
</div>
<div><span style="font-size:24px">各种操作如上。</span></div>
<div><span style="font-size:24px">大裸数据结构啊，比赛的时候想敲的，不过很长时间没写这种多</span></div>
<div><span style="font-size:24px">颗树合并的题，而且有一个最关键的启发式合并的地方想歪了，认为复杂度不行，就没敲，现在想想还真是后悔，只怪自己的思维还不够严谨，要是在比赛中敲，不管能不能AC，都会比赛后敲来的激情啊。</span></div>
<div><span style="font-size:24px">好歹花了一天时间，第一次全部手写splay树的所有函数，debug的时候过于自信就没去看那几个函数，而且还过了自己出的很多数据，后来看到了，就一点点改，一直到所有的bug都找到了（我认为的），交上去还是TLE，比较庆幸的是这次写没有像写<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3726" target="_blank">10天津那个题</a>一样，RE了好长一排（那是第一次写指针splay），很多结构调试起来还是轻松的，但是由于种种细节过多，导致我一开始就看出来的错误有一个地方没有修改好，然后就一直T。。</span></div>
<div><span style="font-size:32px">一些花絮：：</span></div>
<div><span style="font-size:32px; color:#ff0000"><em>TLE持续中。。。。。</em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">TLE持续中。。。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">实在是好忧桑啊。。。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">这日子没法过了。。。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">怎么办怎么办。。。。。。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">继续埋头看代码。。。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">找到了！！！！</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">再来一发，还是TLE。。。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">MD，爆粗口了。。。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">好吧，先去赚点钱吧！！！！都是正事啊。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">教别人游泳的时候一直无法专心，，，，，明明没错啊，，，</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">晚上回到寝室，杰哥帮忙跑了一发100000的数据，竟然跑不出来。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">这不科学</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">然后仔细一看，有个地方写傻了，，，，</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">233333333333333333333333333333</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">我乃绝世大sb，不能直视啊。。。</span></em></span></div>
<div><span style="color:rgb(255,0,0)"><em><span style="font-size:24px">然后怒交一发，AC了！！！！！！</span></em></span></div>
<div>
</div>
<div><img alt="About set" src="http://cdn.acmerblog.com/img/1447886306511.jpg"/>
</div>
<div><span style="font-size:24px">这个题思路很简单的，就按照题目告诉的模拟就好了，真正好的数据结构题不该是这种大裸的题吧，，，</span></div>
<div><span style="font-size:24px">还是贴个代码吧。。。不过代码略微有些含蓄+混乱。。。切勿随意模仿</span></div>
<div><span style="font-size:24px"></span>
<pre class="brush:cpp" name="code">/* ********************************************** 
Author      : wuyiqi 
Created Time: 2013-8-16 8:24:44 
File Name   : hdu 4680.cpp 
 *********************************************** */  
#pragma comment(linker,"/STACK:100000000,100000000")  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;string&gt;  
#include &lt;iostream&gt;  
using namespace std;  
#define L x-&gt;c[0]  
#define R x-&gt;c[1]  
#define KT  root-&gt;c[1]-&gt;c[0]  
const int  maxn = 300010;  
const int lim = 1000000000;  
int GCD(int a,int b) {  
    if(a&lt;0||a&gt;lim) return b;  
    if(b&lt;0||b&gt;lim) return a;  
    return !b ? a : GCD(b,a%b);  
}  
struct node {  
    struct node *c[2] , *fa;  
    int id;  
    int sz;  
    int gcd;  
    int val;  
    int who;  
    bool d() {  
        return fa-&gt;c[0] == this;  
    }  
    void setc(int d,node *s) {  
        c[d] = s;  
        s-&gt;fa = this;  
    }  
    void up() {  
        sz = c[0]-&gt;sz + c[1]-&gt;sz + 1;  
        gcd = GCD(c[0]-&gt;gcd,c[1]-&gt;gcd);  
        gcd = GCD(gcd,val);  
    }  
    void clear(node *null) {  
        c[0] = c[1] = null;  
    }  
}NODE[maxn] , *null = &amp;NODE[0];  
node* Q[maxn];  
node* ID[maxn];  
int Type;  
int n;  
int top;  
struct _x_x_{  
    int type;  
    node* root;  
    void Rotate(node *x,int f){  
        node *y = x-&gt;fa;  
        y-&gt;setc(!f,x-&gt;c[f]);  
        x-&gt;fa = y-&gt;fa;  
        if(y-&gt;fa != null) y-&gt;fa-&gt;setc(!y-&gt;d(),x);  
        x-&gt;setc(f,y);  
        y-&gt;up();  
    }  
    void Splay(node *x,node *goal) {  
        while(x-&gt;fa!=goal) {  
            if(x-&gt;fa-&gt;fa == goal) Rotate(x,x-&gt;d());  
            else {  
                int f = x-&gt;fa-&gt;d();  
                x-&gt;d() == f ? Rotate(x-&gt;fa,f) : Rotate(x,!f);  
                Rotate(x,f);  
            }  
        }  
        x-&gt;up();  
        if(goal == null)  {  
            root = x;  
        }  
    }  
    void RTO(int k,node *goal) {  
        node *x = root;  
        while(L-&gt;sz + 1 != k) {  
            if(k &lt; L-&gt;sz + 1) x = L;  
            else {  
                k -= L-&gt;sz + 1;  
                x = R;  
            }  
        }  
        Splay(x,goal);  
    }  
    node* new_node(node *fa,int v) {  
        node *x = &amp;NODE[++top];  
        x-&gt;id = top;  
        x-&gt;c[0] = x-&gt;c[1] = null;  
        x-&gt;sz = 1;  
        x-&gt;val = v;  
        x-&gt;gcd = v;  
        x-&gt;fa = fa;  
        ID[top] = x;  
        return x;  
    }  
    void init(int v) {  
        root = new_node(null,v);  
        type = ++Type;  
        root-&gt;who = type;  
    }  
    void Del_root() {  
        node *t = root;  
        if(t-&gt;c[1] != null) {  
            root = t-&gt;c[1];  
            RTO(1,null);  
            root-&gt;c[0] = t-&gt;c[0];  
            if(root-&gt;c[0] != null)   
                root-&gt;c[0]-&gt;fa = root;  
        } else  {  
            root = root-&gt;c[0];  
        }  
        root-&gt;fa = null;  
        if(root != null) root-&gt;up();  
    }  
    void Delete(node *x) {  
        Splay(x,null);  
        Del_root();  
    }  
    void Insert(node *x) {  
        x-&gt;clear(null);     //插入一个节点前不能忘记清空它的左右儿子  
        insert(root,x);  
        Splay(x,null);  
        x-&gt;who  = type;  
    }  
    void insert(node* &amp;x,node *y) {  
        if(x == null) {  
            x = y;  
            return ;  
        }  
        if(y-&gt;val &lt;= x-&gt;val) {  
            insert(x-&gt;c[0],y);  
            x-&gt;c[0]-&gt;fa = x;  
        } else {  
            insert(x-&gt;c[1],y);  
            x-&gt;c[1]-&gt;fa = x;  
        }  
        x-&gt;up();  
    }  
    void Change(int u,int v) {  
        node *tmp = ID[u+2*n];  
        Splay(tmp,null);  
        Del_root();  
        tmp-&gt;val = v;  
        Insert(tmp);  
    }  
    node *find_succ(node *x,int v) {  // equal or bigger than v
        if(x == null) return x;  
        if(x-&gt;val == v) return x;  
        else if(x-&gt;val &gt; v) {  
            node *tmp = find_succ(x-&gt;c[0],v);  
            return tmp == null ? x : tmp;  
        }else {  
            return find_succ(x-&gt;c[1],v);  
        }  
    }  
    node *find_pre(node *x,int v) {  // strictly less than v
        if(x == null) return x;  
        if(x-&gt;val &lt; v) {  
            node *tmp = find_pre(x-&gt;c[1],v);  
            return tmp == null ? x : tmp;  
        } else {  
            return find_pre(x-&gt;c[0],v);  
        }  
    }  
    int Gao() {  
        if(root-&gt;sz &lt;= 4)  return root-&gt;sz - 2;  
        RTO(2,null);  
        int a = root-&gt;val;  
        RTO(3,null);  
        int b = root-&gt;val;  
        int ans = 2;  
        while(true){  
            if(a + b &gt; lim) break;  
            int c = find_succ(root,a+b)-&gt;val;  
            if(c &gt; lim || c == -1) break;  
            a = b; b = c;  
            ans++;  
        }  
        return ans;  
    }  
    int Solve(int l,int r) {  
        node *pre = find_pre(root,l);  
        node *succ = find_succ(root,r+1);  
        Splay(pre,null);  
        Splay(succ,root);  
        return KT-&gt;gcd;  
    }  
    void Merge(_x_x_ &amp;tree) {  
        int head = 0, tail = 0;  
        tree.RTO(1,null);  
        tree.RTO(tree.root-&gt;sz,tree.root);  
        Q[++tail] = tree.KT;  
        while(head &lt; tail) {  
            node *fr = Q[++head];  
            if(fr-&gt;c[0] != null) Q[++tail] = fr-&gt;c[0];  
            if(fr-&gt;c[1] != null) Q[++tail] = fr-&gt;c[1];  
            Insert(fr);//此处吐血了一整天，上面的改回来了，这里却没改insert(root,fr);  
            fr-&gt;who = type;  
        }  
        tree.KT = null;  
        tree.root-&gt;c[1]-&gt;up();  
        tree.root-&gt;up();  
    }  
}spt[maxn];  
void prepare() {  
    null-&gt;id = 0;  
    null-&gt;c[0] = null-&gt;c[1] = null-&gt;fa = NULL;  
    null-&gt;sz = null-&gt;val = 0;  
    null-&gt;gcd = -1;  
    Type = 0;  
    top = 0;  
}  
int main()  
{  
    int t,m,ca=1,op,u,v,l,r,x;  
    scanf("%d",&amp;t);  
    while(t--) {  
        prepare();  
        scanf("%d%d",&amp;n,&amp;m);  
        for(int i = 1; i &lt;= n; i++){  
            spt[i].init(-1);  
            node *tmp =  spt[i].new_node(null,lim+1);
            spt[i].Insert(tmp);  
        }  
        for(int i = 1,a; i &lt;= n; i++) {  
            scanf("%d",&amp;a);  
            node *tmp = spt[i].new_node(null,a);
            spt[i].Insert(tmp);  
        }  
        int tot = 0;  
        printf("Case #%d:\n",ca++);  
        while(m--) {  
            scanf("%d",&amp;op);  
            if(op == 1) {  
                scanf("%d%d",&amp;u,&amp;v);   
                node *tmp1 = ID[u+2*n] , *tmp2 = ID[v+2*n];  
                int tree1 = tmp1-&gt;who;  
                int tree2 = tmp2-&gt;who;  
                if(tree1 == tree2) continue;  
                int sz1 = spt[tree1].root-&gt;sz;  
                int sz2 = spt[tree2].root-&gt;sz;  
                if(sz1 &gt; sz2) {  
                    spt[tree1].Merge(spt[tree2]);  
                } else {  
                    spt[tree2].Merge(spt[tree1]);  
                }  
            } else if(op == 2) {  
                scanf("%d%d",&amp;u,&amp;v);  
                node *tmp1 = ID[u+2*n] , *tmp2 = ID[v+2*n];  
                int tree1 = tmp1-&gt;who;  
                int tree2 = tmp2-&gt;who;  
                spt[tree1].Delete(tmp1);  
                spt[tree2].Insert(tmp1);  
            } else if(op == 3) {  
                scanf("%d%d",&amp;u,&amp;x);  
                node *tmp = ID[u+2*n];  
                int tree = tmp-&gt;who;  
                spt[tree].Change(u,x);  
            }  else if(op == 4) {  
                scanf("%d",&amp;u);  
                node *tmp = ID[u+2*n];  
                int tree = tmp-&gt;who;  
                printf("%d\n",spt[tree].Gao());  
            } else {  
                scanf("%d%d%d",&amp;u,&amp;l,&amp;r);  
                node *tmp = ID[u+2*n];  
                int tree = tmp-&gt;who;  
                printf("%d\n",spt[tree].Solve(l,r));  
            }  
        }  
    }  
    return 0;  
}  
</pre>
</div>
<div style="padding-top:20px">
<p style="font-size:12px;">版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
</div>
<p>参考：http://blog.csdn.net/crazy_ac/article/details/10013975</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-97165">
<article class="comment" id="comment-97165">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919528607" rel="external nofollow">新用户171706</a></span> on <a href="http://www.acmerblog.com/hdu-4680-about-set-7725.html#comment-97165" rel="nofollow"><time datetime="2017-04-20T00:52:32+00:00" pubdate="">2017年4月20日 at 上午12:52</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>万 部 A 片高清 国产日韩 <a href="http://uVU.cc/iiMs" rel="nofollow">http://uVU.cc/iiMs</a></p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>