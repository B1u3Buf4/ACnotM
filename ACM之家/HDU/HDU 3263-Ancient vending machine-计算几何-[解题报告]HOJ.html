<div class="c-top2" id="post-55">
<div class="datetime">2014<br/>03-13</div>
<div class="tit"><h1 class="entry-title">HDU 3263-Ancient vending machine-计算几何-[解题报告]HOJ</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/spiderman" rel="author" title="由蜘蛛侠发布">蜘蛛侠</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a>, <a href="http://www.acmerblog.com/category/geometry/convex" rel="category tag" title="查看凸包问题中的全部文章">凸包问题</a>, <a href="http://www.acmerblog.com/category/geometry/analytic-geometry" rel="category tag" title="查看解析几何中的全部文章">解析几何</a></span><span class="i4">围观451次</span><span class="i3"><a class="ds-thread-count" data-thread-key="5158" href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comments" title="《HDU 3263-Ancient vending machine-计算几何-[解题报告]HOJ》上的评论">17 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">Ancient vending machine</h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
Though the story of Shaolong Xiang, the great time-traveler, is not recorded in the history, some recent discoveries show the possibility that the ancient mystery visitor might really exist. Several months ago, a strange machine was found together with some newly unearthed terra-cotta warriors. That machine looks like a modern machine and even has some electronic parts ― that’s why people take Mr. Xiang into consideration when guessing the origin of the strange machine. 
<p>After careful examinations, scientists finally figured out what the machine is — it actually is a vending machine in Qin dynasty! There is a hole on a panel of the machine, and scientists are pretty sure that Qin people put their coins into the machine through that hole to buy things. As you know, there were too many different types of coins before Qin dynasty and Emperor Qin Shihuang didn’t like that. But scientists found an announcement made by Qin Shihuang carved on the machine, saying that any coins which can go through the hole is still legal to use. Now your task is to determine whether a certain type of coin can be put into the hole―from these results we might find some clues about the mystery time-traveler.</p>
<p>The hole on the panel is a polygon and all coins also have a shape of polygon. THEY ALL MAYBE CONCAVE. Scientist found out that ancient people use the vending machine this way: The panel with the hole was positioned horizontally, and the customer chose a best position above the hole to hold a coin. Then the customer dropped the coin. During the process of felling down, the coin WOULD NOT ROTATE in any direction. If the coin could go through the hole, the coin is considered “legal”. Otherwise, the coin is judged “illegal”. If the coin just merely touched the edges of the hole but was not blocked, it was considered as legal. For example, as shown in the sample input, a square coin with side length 5 can go through a triangle hole with sides of length 3, 4 and 5 , so it’s legal. <br/></p><center><img alt="Seat taking up is tough" src="/img/1395043298733.jpg"/></center><br/>Please note that coins and the panel are all considered as no thickness. </div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
The first line contains an integer T representing the number of test cases( 0 &lt; T &lt;= 20).<br/>For each test case, the first line contains an integer N (3&lt;=N&lt;=20), representing the number of vertexes of the hole-polygon. <br/>Next N lines describe the shape of the hole-polygon by listing positions of all vertexes in counterclockwise order. Each line contains two real numbers r1 and r2 ( -100 &lt;= r1,r2 &lt;=100), describing the position of a vertex.
<p>The next line contains an integer M (3&lt;=M&lt;=20), representing the number of vertexes of the coin-polygon. </p>
<p>Next M lines describe the shape of the coin-polygon by listing positions of all vertexes in counterclockwise order. Each line contains two real numbers r1 and r2 ( -100 &lt;= r1,r2 &lt;=100), describing the position of a vertex.</p>
<p>The positions mentioned above are relative coordinates but not absolute values.  </p></div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
The first line contains an integer T representing the number of test cases( 0 &lt; T &lt;= 20).<br/>For each test case, the first line contains an integer N (3&lt;=N&lt;=20), representing the number of vertexes of the hole-polygon. <br/>Next N lines describe the shape of the hole-polygon by listing positions of all vertexes in counterclockwise order. Each line contains two real numbers r1 and r2 ( -100 &lt;= r1,r2 &lt;=100), describing the position of a vertex.
<p>The next line contains an integer M (3&lt;=M&lt;=20), representing the number of vertexes of the coin-polygon. </p>
<p>Next M lines describe the shape of the coin-polygon by listing positions of all vertexes in counterclockwise order. Each line contains two real numbers r1 and r2 ( -100 &lt;= r1,r2 &lt;=100), describing the position of a vertex.</p>
<p>The positions mentioned above are relative coordinates but not absolute values. </p></div>
<div>
<p class="mytitle"> 样例输入:</p>
</div>
<pre class="mypanel iopanel">
2
4
0 0
4 0
4 1
0 1
3
0 4
1 4
1 0
3
0 0
4 0
0 3
4
0 0
5 0
5 5
0 5</pre>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
legal
legal</pre>
<p> <!-- problem end --></p>
<p>题目：给定一个多边形A，问能否穿过多边形的洞B。</p>
<p>分析：计算几何、凸包、旋转卡壳、点与多边形关系。问题实际是在求多边形A的最小宽度和多边形B能容纳的最常线段长度。</p>
<p>                                                   <img alt="Ancient vending machine" src="/img/1395043320617.jpg"/>                                                   </p>
<p>1.对于多边形A，构造凸包利用，旋转卡壳求出对踵点对，然后求出最小的高。</p>
<p>   </p>
<p>                                 <img alt="Ancient vending machine" src="/img/1395043320734.jpg"/></p>
<p>2. 对于多边形B，所求的最长线段，一定经过多边形上的至少两个点，枚举所有点对，计算被截取的最长部分即可。</p>
<pre class="brush:cpp ">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

typedef struct pnode
{
    double x,y,d;
    pnode( double a, double b ) {x = a;y = b;}
    pnode(){};
}point;
point H[ 21 ];
point C[ 21 ];
point P0,Pn;

typedef struct lnode
{
    double x,y,dx,dy,d;
    int    id,hit,sign;
    lnode( point a, point b ) {x = a.x;y = a.y;dx = b.x-a.x;dy = b.y-a.y;}
    lnode(){};
}line;

//两点间距离 
double dist( point a, point b )
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

//点到直线距离 
double dist( point a, line l )
{
    return fabs(l.dx*(a.y-l.y)-l.dy*(a.x-l.x))/sqrt(l.dx*l.dx+l.dy*l.dy);
}

//叉乘 ab*ac 
double crossproduct( point a, point b, point c )
{
    return (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);
}

//坐标排序 
bool cmp1( point a, point b )
{
    if ( a.x == b.x ) return a.y &lt; b.y;
    else return a.x &lt; b.x;
}

//级角排序 
bool cmp2( point a, point b )
{
    double cp = crossproduct( P0, a, b );
    if ( cp == 0 ) return a.d &lt; b.d;
    else return cp &gt; 0;
}

//凸包扫描算法 
double Graham( int N )
{
	sort( C+0, C+N, cmp1 );
	P0 = C[0];
    for ( int i = 1 ; i &lt; N ; ++ i )
        C[i].d = dist( P0, C[i] );
    sort( C+1, C+N, cmp2 );
        
    //计算凸包 
    int top = 2;
    for ( int i = 3 ; i &lt; N ; ++ i ) {
        while ( top &gt; 0 &amp;&amp; crossproduct( C[top-1], C[top], C[i] ) &lt;= 0 ) -- top;
        C[++ top] = C[i];
    }
	C[++ top] = C[0];
    
    //旋转卡壳，求对踵点对 
   	int    L = 0,R = 1;
   	double D = 500.000;
   	do{
		while ( crossproduct( C[R], C[L], C[(L+1)%top] ) &lt;= crossproduct( C[(R+1)%top], C[L], C[(L+1)%top] ) )
			R = (R+1)%top;
		
		D = min( D, dist( C[R], line( C[L], C[(L+1)%top] ) ) );
		L = (L+1)%top;
	}while ( L );
	
	return D;
}

//直线与线段相交判断 
bool l_cross_s( line b, line a )
{
    double t1 = b.dx*(a.y-b.y)-b.dy*(a.x-b.x);
    double t2 = b.dx*(a.y+a.dy-b.y)-b.dy*(a.x+a.dx-b.x);
    return t1*t2 &lt; 0;
}

//线段相交   
bool s_cross_s( line a, line b )  
{  
	double t1 = 0.0+a.dx*(b.y-a.y)-a.dy*(b.x-a.x);  
	double t2 = 0.0+a.dx*(b.y+b.dy-a.y)-a.dy*(b.x+b.dx-a.x);  
	double t3 = 0.0+b.dx*(a.y-b.y)-b.dy*(a.x-b.x);  
	double t4 = 0.0+b.dx*(a.y+a.dy-b.y)-b.dy*(a.x+a.dx-b.x);  
	return (t1*t2 &lt; 0)&amp;&amp;(t3*t4 &lt; 0);  
}

//点在线段上   
bool on( point p, line l )  
{  
    if ( l.dx*(p.y-l.y)-l.dy*(p.x-l.x) == 0 )  
    if ( (p.x-l.x)*(p.x-l.x-l.dx) &lt;= 0 )  
    if ( (p.y-l.y)*(p.y-l.y-l.dy) &lt;= 0 )  
        return true;  
    return false;  
}  
  
//点在多边形内  
bool in( point p, point* P, int n )  
{  
    double d[4][2] = {-101,-103,-103,101,101,-103,101,103};  
    for ( int t = 0 ; t &lt; 4 ; ++ t ) {  
        line s1 = line( p, point( d[t][0], d[t][1] ) );  
        int  count = 0;  
        for ( int i = 0 ; i &lt; n ; ++ i ) {  
            line s2 = line( P[i], P[i+1] );  
            if ( on( p, s2 ) ) return true;  
            if ( s_cross_s( s1, s2 ) ) count ++;  
            if ( on( P[i], s1 ) &amp;&amp; l_cross_s( s1, line( P[i+1], P[(i-1+n)%n] ) ) ) count ++;  
        }
        if ( count%2 == 0 ) return false;   
    }  
    return true;  
}  

//两直线交点 
point crosspoint( line l, line m )
{
    point a = point( m.x, m.y );
    point b = point( m.x+m.dx, m.y+m.dy );
    if ( m.dx*l.dy == m.dy*l.dx ) {
        if ( dist( point( l.x, l.y ), a ) &lt; dist( point( l.x, l.y ), b ) )
            return a;
        else return b;
    }else {
        double a1 = -l.dy,b1 = l.dx,c1 = l.dx*l.y-l.dy*l.x;
        double a2 = -m.dy,b2 = m.dx,c2 = m.dx*m.y-m.dy*m.x;
        double x = (c1*b2-c2*b1)/(a1*b2-a2*b1);
        double y = (c1*a2-c2*a1)/(b1*a2-b2*a1);
        return point( x, y );
    } 
}

//计算空的最大长度 
double Calcul( int N )
{
	H[N] = H[0];
	
	point  X[ 21 ];
	double D = 0.0;
	for ( int i = 0 ; i &lt; N ; ++ i )
	for ( int j = i+1 ; j &lt; N ; ++ j ) {
		line l = line( H[i], H[j] );
			
		int S = 0;
		for ( int k = 0 ; k &lt; N ; ++ k ) {
			line m = line( H[k], H[k+1] );
			if ( l_cross_s( l, m ) )
				X[S ++] = crosspoint( l, m );
		}
		X[S ++] = H[i];
		X[S ++] = H[j];
		
		P0 = point( -101, -103 );
		for ( int k = 0 ; k &lt; S ; ++ k )
			X[k].d = dist( P0, X[k] );
		sort( X, X+S, cmp2 );
		
		double sum = 0.0;
		int    fla = 0;
		for ( int i = 1 ; i &lt; S ; ++ i ) {
			if ( in( point( (X[i-1].x+X[i].x)/2, (X[i-1].y+X[i].y)/2 ), H, N ) ) {
				if ( fla ) sum += dist( X[i-1], X[i] );
				else sum = dist( X[i-1], X[i] );
				D = max( D, sum );
				fla = 1;
			}
		}
	}
	
	return D;
}

int main()
{
    int T,N,M;
    while ( scanf("%d",&amp;T) != EOF ) 
    while ( T -- ) {
        scanf("%d",&amp;N);
        for ( int i = 0 ; i &lt; N ; ++ i )
            scanf("%lf%lf",&amp;H[i].x,&amp;H[i].y);
        scanf("%d",&amp;M);
        for ( int i = 0 ; i &lt; M ; ++ i )
            scanf("%lf%lf",&amp;C[i].x,&amp;C[i].y);
        
        //计算硬币最小宽度 
		double d = Graham( M );
        
        //计算空的最大长度 
        double D = Calcul( N );
        
        if ( d &lt;= D ) printf("legal\n");
        else printf("illegal\n");
    }
    return 0;
}</pre>
<p></p>
<p>
</p>
<p>参考：http://blog.csdn.net/mobius_strip/article/details/8605377</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-78254">
<article class="comment" id="comment-78254">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919459153" rel="external nofollow">新用户373339</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-78254" rel="nofollow"><time datetime="2017-04-12T10:53:29+00:00" pubdate="">2017年4月12日 at 上午10:53</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>威力真牛啊，建国以来第一。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-78253">
<article class="comment" id="comment-78253">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919459153" rel="external nofollow">新用户373339</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-78253" rel="nofollow"><time datetime="2017-04-12T10:53:29+00:00" pubdate="">2017年4月12日 at 上午10:53</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>威力真牛啊，建国以来第一。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-78252">
<article class="comment" id="comment-78252">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919459153" rel="external nofollow">新用户373339</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-78252" rel="nofollow"><time datetime="2017-04-12T10:53:29+00:00" pubdate="">2017年4月12日 at 上午10:53</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>威力真牛啊，建国以来第一。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-78251">
<article class="comment" id="comment-78251">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919459153" rel="external nofollow">新用户373339</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-78251" rel="nofollow"><time datetime="2017-04-12T10:53:29+00:00" pubdate="">2017年4月12日 at 上午10:53</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>威力真牛啊，建国以来第一。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-58206">
<article class="comment" id="comment-58206">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">HDC</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-58206" rel="nofollow"><time datetime="2015-07-09T23:36:54+00:00" pubdate="">2015年7月9日 at 下午11:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>老实说，这种方法就是穷举，复杂度是2^n，之所以能够AC是应为题目的测试数据有问题，要么数据量很小，要么能够得到k == t，否则即使n = 30，也要很久才能得出结果，本人亲测</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-58204">
<article class="comment" id="comment-58204">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">zhiqiang</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-58204" rel="nofollow"><time datetime="2015-05-14T16:26:36+00:00" pubdate="">2015年5月14日 at 下午4:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好，解决了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-28362">
<article class="comment" id="comment-28362">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">tangxiansheng</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-28362" rel="nofollow"><time datetime="2015-05-07T22:09:06+00:00" pubdate="">2015年5月7日 at 下午10:09</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第二个方法挺不错。NewHead代表新的头节点，通过递归找到最后一个节点之后，就把这个节点赋给NewHead，然后一直返回返回，中途这个值是没有变化的，一边返回一边把相应的指针方向颠倒，最后结束时返回新的头节点到主函数。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-28363">
<article class="comment" id="comment-28363">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">20134055016</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-28363" rel="nofollow"><time datetime="2015-01-03T04:52:20+00:00" pubdate="">2015年1月3日 at 上午4:52</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>以了解 想問為甚麼 Tbl[6001] = {1} 初始化都是1<br/>
為何不是Tbl[0]=1 其他為0</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-48235">
<article class="comment" id="comment-48235">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">tufei</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-48235" rel="nofollow"><time datetime="2014-10-31T18:22:16+00:00" pubdate="">2014年10月31日 at 下午6:22</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>感觉我好像很多都不会做。。。。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-28364">
<article class="comment" id="comment-28364">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">nwling</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-28364" rel="nofollow"><time datetime="2014-09-02T00:21:29+00:00" pubdate="">2014年9月2日 at 上午12:21</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>顺利测试通过了，多谢</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-28359">
<article class="comment" id="comment-28359">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">becool456</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-28359" rel="nofollow"><time datetime="2014-08-17T16:33:21+00:00" pubdate="">2014年8月17日 at 下午4:33</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第15行代码，/n/n，应该改为\n\n</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-28361">
<article class="comment" id="comment-28361">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">vintion</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-28361" rel="nofollow"><time datetime="2014-08-11T14:46:25+00:00" pubdate="">2014年8月11日 at 下午2:46</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>嗯   分析得很到位，确实用模板编程能让面试官对你的印象更好。在设置辅助栈的时候可以这样：push时，比较要push的elem和辅助栈的栈顶，elem&lt;=min.top()，则min.push(elem).否则只要push（elem）就好。在pop的时候，比较stack.top()与min.top(),if(stack.top()&lt;=min.top()),则{stack.pop();min.pop();}，否则{stack.pop();}.</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-28360">
<article class="comment" id="comment-28360">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">pascal</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-28360" rel="nofollow"><time datetime="2014-08-11T07:11:39+00:00" pubdate="">2014年8月11日 at 上午7:11</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第二个方法挺不错。NewHead代表新的头节点，通过递归找到最后一个节点之后，就把这个节点赋给NewHead，然后一直返回返回，中途这个值是没有变化的，一边返回一边把相应的指针方向颠倒，最后结束时返回新的头节点到主函数。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-48233">
<article class="comment" id="comment-48233">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">sharp</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-48233" rel="nofollow"><time datetime="2014-08-03T01:43:14+00:00" pubdate="">2014年8月3日 at 上午1:43</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>21行中，j&lt;10可改为j&lt;10-i，减少比较次数</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-48236">
<article class="comment" id="comment-48236">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">super157</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-48236" rel="nofollow"><time datetime="2014-07-28T15:04:11+00:00" pubdate="">2014年7月28日 at 下午3:04</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>We do not harbor that I couldn’t remove other individuals’ problems whenever this arrived at.</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-48234">
<article class="comment" id="comment-48234">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">jupiterhyun</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-48234" rel="nofollow"><time datetime="2014-06-21T14:00:38+00:00" pubdate="">2014年6月21日 at 下午2:00</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的方法，学习了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-58205">
<article class="comment" id="comment-58205">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Sacomplex</a></span> on <a href="http://www.acmerblog.com/hdu-3263-ancient-vending-machine-5158.html#comment-58205" rel="nofollow"><time datetime="2014-04-13T23:12:48+00:00" pubdate="">2014年4月13日 at 下午11:12</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第2题，TCP不支持多播，多播和广播仅应用于UDP。所以B选项是不对的。第2题，TCP不支持多播，多播和广播仅应用于UDP。所以B选项是不对的。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>