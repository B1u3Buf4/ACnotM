<div class="c-top2" id="post-55">
<div class="datetime">2013<br/>12-12</div>
<div class="tit"><h1 class="entry-title">HDU 1553 Library-二分图-[解题报告] C++</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/search/dfs" rel="category tag" title="查看DFS搜索中的全部文章">DFS搜索</a>, <a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a>, <a href="http://www.acmerblog.com/category/graph/bipartite-graph" rel="category tag" title="查看二分图中的全部文章">二分图</a>, <a href="http://www.acmerblog.com/category/graph/shortest-path" rel="category tag" title="查看最短路径中的全部文章">最短路径</a>, <a href="http://www.acmerblog.com/category/graph/flow" rel="category tag" title="查看网络流中的全部文章">网络流</a>, <a href="http://www.acmerblog.com/category/basis/recursion" rel="category tag" title="查看递归和分治中的全部文章">递归和分治</a></span><span class="i4">围观779次</span><span class="i3"><a class="ds-thread-count" data-thread-key="2107" href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comments" title="《HDU 1553 Library-二分图-[解题报告] C++》上的评论">13 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">Library</h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
Castaway Robinson Crusoe is living alone on a remote island. One day a ship carrying a royal library has wrecked nearby. Usually Robinson brings any useful stuff from the shipwreck to his island, and this time he has brought a big chest with books.
<p> Robinson has decided to build a bookcase for these books to create his own library. He cut a rectangular niche in the rock for that purpose, hammered in wooden pegs, and placed wooden planks on every pair of pegs that have the same height, so that all planks are situated horizontally and suit to act as shelves.</p>
<p>Unfortunately, Robinson has discovered that one especially old and big tome does not fit in his bookcase. He measured the height and width of this tome and has decided to redesign his bookcase in such a way, as to completely fit the tome on one of the shelves, taking into account locations of other shelves and the dimensions of the niche. With each shelf in the bookcase, one of the following operations should be made:</p>
<p>Leave the shelf on its original place. <br/>Move the shelf to the left or to the right. <br/>Shorten the shelf by cutting off a part of the plank and optionally move it to the left or to the right. <br/>Move one of the pegs to a different place at the same height and move the shelf to the left or to the right. <br/>Shorten the shelf by cutting off a part of the plank, move one of the pegs to a different place at the same height, and optionally move the shortened shelf to the left or to the right. <br/>Remove the shelf from the bookcase along with both supporting pegs. <br/>We say that the shelf is properly supported by its pegs, if exactly two distinct pegs support the shelf and the center of the shelf is between its pegs or coincides with one of the pegs. The original design of Robinson’s library has all the shelves properly supported by their pegs and lengths of all shelves are integer number of inches. The Robinson may only cut an integer number of inches from the planks, because he has no tools for more precise measurements. All remaining shelves after the redesign must be properly supported by their pegs.</p>
<p>You are to find the way to redesign Robinson’s library to fit the special old tome without changing original design too much. You have to minimize the number of pegs that are to be removed from their original places during the redesign (operations 4 and 5 remove one peg, and operation 6 removes two pegs). If there are different ways to solve the problem, then you are to find the one that minimizes the total length of planks that are to be cut off (operations 3 and 5 involve cutting something from the planks, and operation 6 counts as if cutting off the whole plank). Width of planks and diameter of pegs shall be considered zero.</p>
<p>The tome may not be rotated. The tome should completely (to all its width) stand on one of the shelves and may only touch other shelves, their pegs or niche’s edge. </p></div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
The input consists of several test cases.
<p>The first line of each test case contains four integer numbers XN, YN, XT, and YT, separated by single spaces. They are, correspondingly, width and height of the niche, and width and height of the old tome in inches (1 ≤ XN, YN, XT, YT ≤ 1000).</p>
<p>The second line contains a single integer number N (1 ≤ N ≤ 100) that represents the number of the shelves. Then N lines follow. Each line represents a single shelf along with its two supporting pegs, and contains five integer numbers yi, xi, li, x1i, x2i, separated by spaces, where:</p>
<p>yi (0 &lt; yi &lt; YN) – the height of the ith shelf above the bottom of the niche in inches. <br/>xi (0 ≤ xi &lt; XN) – the distance between the left end of the ith shelf and the left edge of the niche in inches. <br/>li (0 &lt; li ≤ XN – xi) – the length of the ith shelf in inches. <br/>x1i (0 ≤ x1i ≤ li/2) – the distance between the left end of the ith shelf and its leftmost supporting peg in inches. <br/>x2i (li/2 ≤ x2i ≤ li; x1i &lt; x2i) – the distance between the left end of the ith shelf and its rightmost supporting peg in inches. <br/>All shelves are situated on different heights and are properly supported by their pegs. The problem is guaranteed to have a solution for the input data. </p></div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
The output shall, for each test case, contain two integer numbers separated by a space. The first one is the minimal number of pegs that are to be removed by Robinson from their original locations to place the tome. The second one is the minimal total length of planks in inches that are to be cut off during the redesign that removes the least number of pegs.</div>
<div>
<p class="mytitle"> 样例输入:</p>
</div>
<pre class="mypanel iopanel">
11 8 3 4
4
1 1 7 1 4
4 3 7 1 6
7 2 6 3 4
2 0 3 0 3
11 8 4 6
4
1 1 7 1 4
4 3 7 1 6
7 2 6 3 4
2 0 3 0 3</pre>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
0 0
1 3</pre>
<p> <!-- problem end --></p>
<p>题目大意：</p>
<p>给你一个N行M列的矩阵，其中“.”代表空地，“H”代表房子，“m”代表人，其中有n个房子和n个人。现在要求每个人进入一间房子，且人走一步需要支付1美元。</p>
<p>求最小需要花费多少美元才能让所有人都进入到房子中（每个人只能进入一间房子，每个房子只能容纳一个人）。</p>
<p>解题思路：</p>
<p>这道题其实就是二分图最优匹配的变形而已。</p>
<p>因为要求的其实是最小权值之和。而KM算法求的是最大权值之和。把权值改为负数，结果再转换为正的就好了；</p>
<p>1.在建图的时候，将每条边的权值变为负数。结果输出-ans，就可以得到最小权值。</p>
<p> </p>
<p>最小费用最大流：</p>
<p>加源点汇点，n个人连源点，容量为1，花费为0 ；每个人和n个房子连边，容量为1，花费为坐标的距离 ；n个房子连汇点，容量1，花费0；</p>
<p>之后跑一边费用流； 记住是有向边；</p>
<p> KM_match:</p>
<pre class="brush:cpp "><span style="background-color:rgb(255,255,255)">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#include &lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std ;
const int M=110 ;
struct node
{
	int  x,y ;
}men[M],house[M];
int lx[M],ly[M],fx[M],fy[M],w[M][M],match[M];
char mm[M][M];
int n , m ;

int dfs(int x)
{
	fx[x]=1;
   for(int i = 1 ; i &lt;= n ; i++)
   {
   	   if(!fy[i] &amp;&amp; lx[x]+ly[i]==w[x][i])
   	   {
   	   	    fy[i]=1;
   	   	    if(match[i]==-1 || dfs(match[i]))
   	   	    {
   	   	    	   match[i]=x;
   	   	    	   return 1;
   	   	    }
   	   }
   }	
	 return 0;
}

void KM_match()
{
     int  Min ;
	  for(int i = 1 ; i &lt;= n ; i++)
	  {
	  	   lx[i]=w[i][1];
	  	   for(int j = 2 ; j &lt;= n ; j++)
	  	      lx[i]=max(lx[i],w[i][j]);
	  }	
	  memset(ly,0,sizeof(ly));
	  memset(match,-1,sizeof(match));
	 for(int k = 1 ; k &lt;= n ; k++)
	 { 
	      while(1)
		  {
		  	   memset(fx,0,sizeof(fx));
		  	   memset(fy,0,sizeof(fy));
		  	   if(dfs(k)) break ;
		  	   Min=2147483647;
		  	   for(int i = 1 ; i &lt;= n ;i++)
		  	     if(fx[i])
		  	     	   for(int j = 1 ; j &lt;= n ; j++)
		  	     	      if(!fy[j])
		  	     	          Min=min(Min,lx[i]+ly[j]-w[i][j]);
		  	     	
		  	    for(int i = 1 ; i&lt;= n ;i++)  if(fx[i]) lx[i]-=Min;
				for(int i = 1 ; i&lt;= n ; i++) if(fy[i]) ly[i]+=Min;   	
		  }	
	 }
} 

int main()
{
	 int  sum , f1,f2 ;
	 while(~scanf("%d%d",&amp;n,&amp;m))
	 {
	 	   if(m+n==0) break;
	 	   f1=f2=0;
	 	   for(int i = 0 ; i &lt; n ; i++)
	 	   {
	 	   	     scanf("%s",mm[i]);
	 	   	     for(int j = 0 ; mm[i][j] ; j++)
	 	   	     {
	 	   	     	   if(mm[i][j]=='m') {  f1++ ; men[f1].x=i ; men[f1].y=j ;}
	 	   	     	   if(mm[i][j]=='H') {  f2++ ; house[f2].x=i ; house[f2].y=j;}
	 	   	     }
	 	   }
	 	   for(int i = 1 ; i &lt;= f1 ; i++)
			 for(int j = 1 ; j &lt;= f2 ; j++)
			      w[i][j] = -(abs(men[i].x-house[j].x)+abs(men[i].y-house[j].y)) ;  
	 	   n=f1 ; sum=0 ;
	 	   KM_match();
	 	   for(int i = 1 ; i &lt;= n ; i++)    sum += w[match[i]][i]  ;
	 	   printf("%d\n",-sum) ;
	 }
	  return 0;
}

</span>	
<span style="font-size:14px; background-color:rgb(255,255,255)"> </span></pre>
<p><span style="font-size:14px; color:#ff0000; background-color:rgb(255,255,255)">最小费用最大流：</span></p>
<p> </p>
<pre class="brush:cpp ">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#include &lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std ;
const int N=1010;
const int maxM=1000200;
const int inf = 1&lt;&lt;30 ;
struct node
{
	int u,v,c,cost ,next;
}edge[maxM];
struct node1
{
	int x,y;
}H[300],M[300];
 int dist[N],head[N],vist[N],pre[N];
 char mm[N][N];
 int top,sumflow ;
 
 void add(int u,int v, int c,int cost)
 {
     edge[top].u=u;	edge[top].v=v; edge[top].c=c; edge[top].cost=cost ;
	 edge[top].next=head[u];head[u]=top++;
     edge[top].u=v;	edge[top].v=u; edge[top].c=0; edge[top].cost=-cost ;
	 edge[top].next=head[v];head[v]=top++;
 }
 
 int SPFA(int s,int t ,int n)
 {
 	 memset(vist,0,sizeof(vist));
 	 memset(pre,-1,sizeof(pre));
 	 int i,u,v;
 	 for(int i = 0 ; i &lt;= n ; i++)  dist[i]=inf;
 	 vist[s]=1;dist[s]=0;
 	 queue&lt;int&gt;q ;
 	 q.push(s);
 	 while(!q.empty())
 	 {
 	 	    u=q.front();
 	 	    q.pop();
 	 	    vist[u]=0;
 	 	    for( i = head[u] ; i!=-1 ; i=edge[i].next)
 	 	    {
 	 	    	  v=edge[i].v;
 	 	    	  if(edge[i].c &amp;&amp; dist[v] &gt; dist[u]+edge[i].cost)
 	 	    	  {
 	 	    	  	    dist[v]=dist[u]+edge[i].cost ;
 	 	    	  	    pre[v]=i;
 	 	    	  	    if(!vist[v])
 	 	    	  	    {
 	 	    	  	    	  vist[v]=1;
 	 	    	  	    	  q.push(v);
 	 	    	  	    }
 	 	    	  }
 	 	    	
 	 	    }
 	 }
 	 if(dist[t]==inf) return 0 ;
 	 return 1;
 }
 
 int MCMF(int s,int t, int n)
 {
 	  int minflow ,flow=0 ,mincost=0,i ;
 	  while(SPFA(s,t,n))
 	  {
 	  	    minflow=inf+1;
 	  	    for(i = pre[t];i!=-1 ;i=pre[edge[i].u])
 	  	          minflow = min(minflow,edge[i].c) ;
 	  	    for(i = pre[t];i!=-1 ;i=pre[edge[i].u])
 	  	    {
 	  	    	 edge[i].c -=minflow ;
 	  	    	 edge[i^1].c +=minflow ;
 	  	    }  
 	  	    mincost += dist[t]*minflow ; //有minflow条路存在最短路，每条路的总花费为dist[t] ;
 	  	    flow+=minflow ;
 	  }
 	  sumflow=flow ;   //最大流 
 	  return mincost ;
 }
 
 int main()
 {
 	  int n,m,u,v,c;
 	  while(~scanf("%d%d",&amp;n,&amp;m))
 	  {
 	  	  if(n+m==0)  break ;
 	  	   top=0;
	       memset(head,-1,sizeof(head));
		   int f1=0,f2=0;
		   for(int i = 0 ; i&lt; n  ; i++)
		   {
		   	      scanf("%s",mm[i]);
				 for(int j = 0 ; mm[i][j] ; j++)	      
		   	     { 
		   	           if(mm[i][j]=='m')  {  f1++ ; M[f1].x=i ; M[f1].y=j ;}
		   	           if(mm[i][j]=='H')  { f2++ ;H[f2].x=i ; H[f2].y= j ; }
		   	     }      
		   }	    
		   int s=0,t=2*f1+1 ;
		   for(int i = 1 ; i &lt;= f1 ; i++)
		   {
		   	   add(s,i,1,0);    //连源点 
		   	   for( int j = 1 ; j &lt;= f2 ;j++)
		   	   {
		   	   	    int temp=fabs(H[i].x-M[j].x)+fabs(H[i].y-M[j].y);
					add(i,f2+j,1,temp);	    //人连房子 
		   	   }
		   	   add(i+f2,t,1,0);   //连汇点； 
		   }
		   int ans=MCMF(s,t,t+1);
		   printf("%d\n",ans);
 	  }
 	  return 0;
 }</pre>
<p>
 </p>
<p> </p>
<p> </p>
<p>解题报告转自：http://blog.csdn.net/u010126535/article/details/13019755</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-54992">
<article class="comment" id="comment-54992">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">ygxqqx</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54992" rel="nofollow"><time datetime="2015-07-08T12:12:10+00:00" pubdate="">2015年7月8日 at 下午12:12</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>多谢提醒。代码又编辑了一下</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-54989">
<article class="comment" id="comment-54989">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yesMan</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54989" rel="nofollow"><time datetime="2015-04-14T18:48:59+00:00" pubdate="">2015年4月14日 at 下午6:48</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>已更新</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-54993">
<article class="comment" id="comment-54993">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">a997930294</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54993" rel="nofollow"><time datetime="2015-02-04T22:57:06+00:00" pubdate="">2015年2月4日 at 下午10:57</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>正在学习搜索，很好</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-54983">
<article class="comment" id="comment-54983">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">zwj0571</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54983" rel="nofollow"><time datetime="2014-11-24T20:40:32+00:00" pubdate="">2014年11月24日 at 下午8:40</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第二种想法，我想来好久，为啥需要一个newhead，发现是把最后一个节点一直返回到嘴上面这层函数。厉害，这道题之前没样子想过。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-54986">
<article class="comment" id="comment-54986">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">ktcer</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54986" rel="nofollow"><time datetime="2014-10-09T12:21:52+00:00" pubdate="">2014年10月9日 at 下午12:21</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>失误失误，转载错了。已经改正，抱歉。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-54987">
<article class="comment" id="comment-54987">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">CHEATBEATER</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54987" rel="nofollow"><time datetime="2014-09-03T08:01:58+00:00" pubdate="">2014年9月3日 at 上午8:01</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>3，求得所有的为的总和sum—-&gt;所有数的总和<br/>
printf( "Not Possible" );—-&gt;printf("impossible");<br/>
对吗？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-54991">
<article class="comment" id="comment-54991">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">kate19930802</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54991" rel="nofollow"><time datetime="2014-08-31T05:29:58+00:00" pubdate="">2014年8月31日 at 上午5:29</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这是研发的在线笔试题吗?发现很多C啊，阿里不是JAVA多么？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-54995">
<article class="comment" id="comment-54995">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Baifern</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54995" rel="nofollow"><time datetime="2014-08-01T17:14:30+00:00" pubdate="">2014年8月1日 at 下午5:14</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>示例程序中的代码不够稳健，没有考虑到输入了非法字符或者不合理输入的情况。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-54994">
<article class="comment" id="comment-54994">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">bcys</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54994" rel="nofollow"><time datetime="2014-05-17T04:00:47+00:00" pubdate="">2014年5月17日 at 上午4:00</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>说的就是无向图啊，有向图的算法也是类似的</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-54990">
<article class="comment" id="comment-54990">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">haojunyu</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54990" rel="nofollow"><time datetime="2014-03-19T06:11:29+00:00" pubdate="">2014年3月19日 at 上午6:11</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>非常好，初学者就应该先理解递归</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-54988">
<article class="comment" id="comment-54988">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">piaoyi</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54988" rel="nofollow"><time datetime="2014-02-10T12:53:20+00:00" pubdate="">2014年2月10日 at 下午12:53</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>代码过于复杂了吧</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-54984">
<article class="comment" id="comment-54984">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">dongxi</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54984" rel="nofollow"><time datetime="2014-01-01T08:41:24+00:00" pubdate="">2014年1月1日 at 上午8:41</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>博主的C++功底真是好</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-54985">
<article class="comment" id="comment-54985">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Sacomplex</a></span> on <a href="http://www.acmerblog.com/hdu-1553-Library-2107.html#comment-54985" rel="nofollow"><time datetime="2013-12-16T01:46:23+00:00" pubdate="">2013年12月16日 at 上午1:46</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的思路，可以借鉴</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>