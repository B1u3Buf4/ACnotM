<div class="c-top2" id="post-55">
<div class="datetime">2013<br/>12-09</div>
<div class="tit"><h1 class="entry-title">hdu 1377 A Well-Formed Problem-字符串-[解题报告]</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/admin" rel="author" title="由coder发布">coder</a></span><span class="i1"><a href="http://www.acmerblog.com/category/basis/string" rel="category tag" title="查看字符串处理中的全部文章">字符串处理</a>, <a href="http://www.acmerblog.com/category/data-struct/linear" rel="category tag" title="查看线性结构中的全部文章">线性结构</a></span><span class="i4">围观1024次</span><span class="i3"><a class="ds-thread-count" data-thread-key="1809" href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comments" title="《hdu 1377 A Well-Formed Problem-字符串-[解题报告]》上的评论">14 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">A Well-Formed Problem</h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
XML, eXtensible Markup Language, is poised to become the lingua franca of structured data communication for the foreseeable future, due in part to its strict formatting requirements. XML parsers must report anything that violates the rules of a well-formed XML document. An XML document is said to be well-formed if it meets all of the wellformedness constraints as defined by the World Wide Web Consortium (W3C) XML specification.
<p>XML documents are composed of units called elements, that contain either character data and/or other elements.</p>
<p>Elements may also contain within their declaration values called attributes. Consider the following XML document: </p>
<p>&lt;?xml version="1.0"?&gt;<br/>&lt;customer&gt;<br/>       &lt;name&gt;<br/>               &lt;first&gt;John&lt;/first&gt;<br/>               &lt;last&gt;Doe&lt;/last&gt;<br/>       &lt;/name&gt;<br/>       &lt;address&gt;<br/>               &lt;street&gt;<br/>                       &lt;number&gt;15&lt;/number&gt;<br/>                       &lt;direction&gt;West&lt;/direction&gt;<br/>                       &lt;name&gt;34th&lt;/name&gt;<br/>               &lt;/street&gt;<br/>               &lt;city&gt;New York&lt;/city&gt;<br/>               &lt;state-code&gt;NY&lt;/state-code&gt;<br/>               &lt;zip-code format="PLUS4"&gt;10001-0001&lt;/zip-code&gt;<br/>               &lt;country-code&gt;USA&lt;/country-code&gt;<br/>       &lt;/address&gt;<br/>       &lt;orders/&gt;<br/>&lt;/customer&gt;</p>
<p>The bold identifiers contained within angle brackets are the elements of the document. The italicized identifier "format" within the "zip-code" element is an attribute of that element. All elements, with the exception of "orders", have a start and an end declaration, also called a tags. The "orders" element is an empty element, as indicated by the "/&gt;" sequence that closes the element, and does not require a separate end-tag. The first line is a processing instruction for an XML parser and is not considered an element of the document.</p>
<p>The rules for a well-formed document are:</p>
<p>1. There is exactly one element that is not contained within any other element. This element is identified as the "root" or "document" element. In the example above, "customer" is the document element.</p>
<p>2. The structure of an XML document must nest properly. An element’s start-tag must be paired with a closing end-tag if it is a non-empty element.</p>
<p>3. The name in an element~{!/~}s end-tag must match the element type in the start-tag. For example, an element opened with &lt;address&gt; must be closed by &lt;/address&gt;.</p>
<p>4. No attribute may appear more than once in the same start-tag or empty-element tag.</p>
<p>5. A parsed element must not contain a recursive reference to itself. For example, it is improper to include another address element within an address element.</p>
<p>6. A named attribute must have an associated value. </p></div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
The input file will contain a series of XML documents. The start of each document is identified by a line containing only the processing instruction "&lt;?xml version="1.0"?&gt;". The end of the input is identified by a line containing only the text "&lt;?end?&gt;" (this is not a true XML processing instruction, just a sentinel used to mark the end of the input for this problem). As with all XML documents, white space between elements and attributes should be ignored. You may make the following assuptions with regard to the input.
<p>The only processing instruction that will be present is the XML version rocessing instruction, and it will always appear only at the beginning of each document in the input.</p>
<p>Element and attribute names are case-sensitive. For example, &lt;Address&gt; and &lt;address&gt; are considered to be different.</p>
<p>Element and attribute names will use only alpha-numeric characters and the dash "-" character.</p>
<p>XML comments will not appear in the input.</p>
<p>Values for attributes will always be properly enclosed in double quotes.</p></div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
For each input XML document, output a line containing the text ~{!0~}well-formed~{!1~} if the document is well-formed, ~{!0~}non well-formed~{!1~} otherwise.</div>
<div>
<p class="mytitle"> 样例输入:</p>
</div>
<pre class="mypanel iopanel">
&lt;?xml version="1.0"?&gt;
&lt;acm-contest-problem&gt;
        &lt;title&gt;A Well-Formed Problem&lt;/title&gt;
        &lt;text&gt;XML, eXtensible Markup Language, is poised to become the lingua franca of
structured data communication for the foreseeable future. [...]&lt;/text&gt;
        &lt;input&gt;probleme.in&lt;/input&gt;
        &lt;output&gt;probleme.out&lt;/output&gt;
&lt;/acm-contest-problem&gt;
&lt;?xml version="1.0"?&gt;
&lt;shopping-list&gt;
        &lt;items&gt;
                &lt;item quantity="1" quantity="1"&gt;Gallon of milk&lt;/item&gt;
                &lt;item&gt;Frozen pizza
        &lt;/items&gt;
&lt;/Shopping-list&gt;
&lt;errand-list&gt;
        &lt;errand&gt;Get some cash at the ATM
                &lt;errand&gt;Pick up dry cleaning&lt;/errand&gt;
        &lt;/errand&gt;
&lt;/errand-list&gt;
&lt;?end?&gt;</pre>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
well-formed
non well-formed</pre>
<p> <!-- problem end --></p>
<p>ZOJ:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1116">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1116</a></p>
<p>题目大意：</p>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>（对XML没有了解，只是按照字面意思理解了一下题意）</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>&lt;name&gt;与&lt;/name&gt;这样有起始结束声明的，name称为tag</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>&lt;order/&gt;是empty element, 不需要end-tag</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>第一行&lt;?xml version="1.0"?&gt;不算文档的element</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>&lt;zip-code format="PLUS4"&gt;10001-0001&lt;/zip-code&gt;这里的format是zip-code的属性</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>一个well-formed document要满足下面几条：</p>
</blockquote>
<p>1、只有一个element不嵌套在别的element里，例如例子中的"customer" <br/>2、嵌套正确，不是&lt;order/&gt;那样的，如&lt;name&gt;与&lt;/name&gt;要完整配对嵌套<br/>3、如&lt;name&gt;与&lt;/name&gt;这样的声明名字要配对<br/>4、一个tag最多一个属性<br/>5、不递归调用，如address element里不能调用address<br/>6、有名字的属性，比如上面的format，要有对应的值</p>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>注意大小写不同，如&lt;Address&gt;和&lt;address&gt;应该认为是不同的</p>
</blockquote>
<p>输入：</p>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>每组数据第一行是 "&lt;?xml version="1.0"?&gt;"。</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>"&lt;?end?&gt;" 表示全部输入的结束（只是在本题中用来标记输入结束）</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>输入保证：</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p> "&lt;?xml version="1.0"?&gt;"会且仅会在第一行出现</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>element和属性只用数字、字母和短线"-"表示</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>XML注释不出现</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>属性的值一定会放在“”里</p>
</blockquote>
</blockquote>
<p>输出</p>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>"well-formed"或者"non well-formed"</p>
</blockquote>
<p>解题思路：</p>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>字符串处理，主要用到栈和集合。</p>
<p>每次读入到”&lt;“的时候，开始读取tag和attribute，同时判断&lt;&gt;里头的内容有没有问题，比如"/"出现的位置和次数有没有问题，属性的表达有没有问题等。之后就只要进行一些判断即可。下面是针对well-formed document的各条件的解决方法：</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>1、针对“只有一个element不嵌套在别的element里，例如例子中的"customer" ”</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>设置bool root=false; 当栈空且有入栈操作时root=true；当root=true且在栈空情况下有入栈操作时返回non well-formed</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>2、针对“嵌套正确，不是&lt;order/&gt;那样的，如&lt;name&gt;与&lt;/name&gt;要完整配对嵌套”</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>栈，非类似&lt;order/&gt;时入栈，入栈忽略属性，出栈时与栈顶元素</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>3、针对“如&lt;name&gt;与&lt;/name&gt;这样的声明名字要配对”</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>同上</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>4、针对“一个tag最多一个属性”</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>若在&lt;&gt;里读到""（输入保证如果有属性，其值一定包括在""里）， 则之后如果再出现非空字符，返回non well-formed</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>5、针对“不递归调用，如address element里不能调用address”</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>设置set&lt;string&gt;类型，存放栈内元素，入栈前判断set里是否有相同tag，如果是，返回non well-formed</p>
</blockquote>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>6、针对“有名字的属性，比如上面的format，要有对应的值”</p>
</blockquote>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<p>在&lt;&gt;内如果读到空格，空格后面有字符，则必须有紧跟的="XXX"</p>
<p></p>
</blockquote>
</blockquote>
<p>源代码：</p>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>又吐血了……”狗狗搞完40题“里的代码又好短，泪奔了，为什么每次写蘑菇题我都要写得很长╮(╯▽╰)╭</p>
</blockquote>
<pre class="brush:cpp ">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;stack&gt; 
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define ERROR non=true;return

set&lt;string&gt; used;
stack&lt;string&gt; s;
bool non, root;

bool gettag(char* &amp;ch, string &amp;tag, bool &amp;end, bool &amp;empty)
// 读到"&lt;"触发gettag, 函数结束后"&gt;"已读过 
{
    int p1, p2, p3, p4;
    string attribute;
    
    end=false, empty=false;
    tag=attribute="";
    
    ch++;                                   //get tag
    if (*ch=='/'){end=true;ch++;}
    while (isalnum(*ch) || *ch=='-')      
    {
        tag+=*ch;
        ch++;
    }
    while (isspace(*ch)) ch++;
    if (*ch=='&gt;')                            //end of tag?
        return 1;
    if (*ch=='/')
    {
        int cal=0;
        ch++;
        while (*ch!='&gt;'){cal++;ch++;}
        if (cal&gt;0) return -2;
        if (end) return -1;
        else empty=true;
    }
    while (isalnum(*ch) || *ch=='-' || *ch=='.' || *ch=='\"' || *ch=='=')        //get attribute
    {
        attribute+=*ch;
        ch++;
    }
    if (attribute.length()&gt;0)
    {
        p1=attribute.find("=", 0);      if (p1==-1) return -3;
        p2=attribute.find("\"", 0);     if (p2&lt;p1) return -4;
        p2=attribute.find("\"", p1+1);  if (p2==-1) return -5;
        p3=attribute.find("\"", p2+1);  if (p3==-1 || p3==p2+1) return -6;   //empty value
        p4=attribute.find("\"", p3+1);  if (p4!=-1) return -7;               //extra "
        p4=attribute.find("=", p1+1);   if (p4!=-1) return -8;               //extra =
    }
    while (isspace(*ch)) ch++;
    if (*ch=='&gt;') return 1;
    if (*ch=='/')
    {
        int cal=0;
        ch++;
        while (*ch!='&gt;'){cal++;ch++;}
        if (cal&gt;0) return -10;
        if (end) return -9;
        else empty=true;
    }
    while (*ch!='&gt;'){
        ch++;
        if (!isspace(*ch) &amp;&amp; *ch!='&gt;') return -11;
    }
    return 1;
}

void solve(char *ch)
{
    bool end, empty;
    string tag;
    int tmp;
    while (!non &amp;&amp; *ch!='\0')
    {
        if (*ch=='&lt;')
        {
            tmp=gettag(ch, tag, end, empty);
            if (tmp==1)
            {
                if (end &amp;&amp; empty){
                    ERROR;
                }
                if (empty &amp;&amp; used.count(tag)&gt;0){
                    ERROR;
                }
                else if (!empty &amp;&amp; !end)
                {
                    if (used.count(tag)&gt;0){
                        ERROR;
                    }
                    if (s.empty())
                    {
                        if (root){ERROR;}
                        else root=true;
                    }
                    used.insert(tag);
                    s.push(tag);
                }
                else if (!empty &amp;&amp; end)
                {
                    if (s.empty() || s.top()!=tag){
                    ERROR;
                }
                    used.erase(tag);
                    s.pop();
                }
            }
            else{ERROR;}
        }
        else ch++;
    }
}

int main()
{
    string tag, attribute;
    bool firstdata=true;
    bool end, empty;
    char buf[65536];
    do{
        while (gets(buf)!=NULL &amp;&amp; strcmp(buf, "&lt;?xml version=\"1.0\"?&gt;")!=0
                &amp;&amp; strcmp(buf, "&lt;?end?&gt;\n")!=0)
        {
            solve(buf);
        }
        if (strcmp(buf, "&lt;?xml version=\"1.0\"?&gt;")==0)
        {
            if (!firstdata)
            {
                if (non || !s.empty()) printf("non well-formed\n");
                else printf("well-formed\n");
            }
            else firstdata=false;
            non=false;
            root=false;
            used.clear();
            while (!s.empty()) s.pop();
        }
    }while (strcmp(buf, "&lt;?end?&gt;")!=0);
    if (non || !s.empty()) printf("non well-formed\n");
    else printf("well-formed\n");
    return 0;
}</pre>
<p>解题转自：http://blog.csdn.net/program_shun/article/details/6581798</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-12892">
<article class="comment" id="comment-12892">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">usx13123</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12892" rel="nofollow"><time datetime="2015-06-14T22:28:08+00:00" pubdate="">2015年6月14日 at 下午10:28</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>算法，他认识我，我不认识他，后来有人告诉我你写的这段代码就是XXX算法。。。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12887">
<article class="comment" id="comment-12887">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Yaunxi</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12887" rel="nofollow"><time datetime="2015-05-16T18:45:27+00:00" pubdate="">2015年5月16日 at 下午6:45</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好，注释很详细啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-54676">
<article class="comment" id="comment-54676">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Lanifer</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-54676" rel="nofollow"><time datetime="2015-05-07T17:58:13+00:00" pubdate="">2015年5月7日 at 下午5:58</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>算法是程序的灵魂，算法分简单和复杂，如果不搞大数据类，程序员了解一下简单点的算法也是可以的，但是会算法的一定要会编程才行，程序员不一定要会算法，利于自己项目需要的可以简单了解。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12885">
<article class="comment" id="comment-12885">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wangzhenvs123</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12885" rel="nofollow"><time datetime="2015-05-04T06:29:55+00:00" pubdate="">2015年5月4日 at 上午6:29</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>分三种情况讨论。Not Possible就是impossible</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-12884">
<article class="comment" id="comment-12884">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">MCIT</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12884" rel="nofollow"><time datetime="2015-04-03T14:32:52+00:00" pubdate="">2015年4月3日 at 下午2:32</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>学习了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12886">
<article class="comment" id="comment-12886">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">1173954900</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12886" rel="nofollow"><time datetime="2014-09-24T12:00:50+00:00" pubdate="">2014年9月24日 at 下午12:00</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好，注释很详细啊</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-12891">
<article class="comment" id="comment-12891">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yelawolf</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12891" rel="nofollow"><time datetime="2014-09-21T06:04:33+00:00" pubdate="">2014年9月21日 at 上午6:04</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>请不要灌水，多谢！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12888">
<article class="comment" id="comment-12888">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">gnipuohz</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12888" rel="nofollow"><time datetime="2014-06-15T17:51:30+00:00" pubdate="">2014年6月15日 at 下午5:51</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>第二种想法，我想来好久，为啥需要一个newhead，发现是把最后一个节点一直返回到嘴上面这层函数。厉害，这道题之前没样子想过。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-12890">
<article class="comment" id="comment-12890">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">1173954900</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12890" rel="nofollow"><time datetime="2014-04-16T12:48:08+00:00" pubdate="">2014年4月16日 at 下午12:48</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的思路，可以借鉴</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12889">
<article class="comment" id="comment-12889">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">NiKaWaLi2015</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12889" rel="nofollow"><time datetime="2014-04-07T09:16:16+00:00" pubdate="">2014年4月7日 at 上午9:16</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>终于找到一篇能看懂的，mark</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-12881">
<article class="comment" id="comment-12881">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">AC_Grazy</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12881" rel="nofollow"><time datetime="2014-03-16T15:31:08+00:00" pubdate="">2014年3月16日 at 下午3:31</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这个也是算法导论的习题</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12880">
<article class="comment" id="comment-12880">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">vincent_ynh</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12880" rel="nofollow"><time datetime="2014-03-06T01:36:53+00:00" pubdate="">2014年3月6日 at 上午1:36</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这配图…..</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-12883">
<article class="comment" id="comment-12883">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">xiaoliubuer</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12883" rel="nofollow"><time datetime="2014-03-05T21:02:15+00:00" pubdate="">2014年3月5日 at 下午9:02</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>map[nodes <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> .index][nodes <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/af/newj_org.gif"/> .index] == 0 就是判断不相邻的。这个是可以证明的。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-12882">
<article class="comment" id="comment-12882">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">xuelanghu</a></span> on <a href="http://www.acmerblog.com/hdu-1377-A-Well-Formed-Problem-1809.html#comment-12882" rel="nofollow"><time datetime="2014-01-12T22:44:27+00:00" pubdate="">2014年1月12日 at 下午10:44</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>神奇的网站</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>