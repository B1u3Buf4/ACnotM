<div class="c-top2" id="post-55">
<div class="datetime">2013<br/>12-21</div>
<div class="tit"><h1 class="entry-title">HDU 1661 Amphiphilic Carbon Molecules -计算几何-[解题报告] C++</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/spiderman" rel="author" title="由蜘蛛侠发布">蜘蛛侠</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a>, <a href="http://www.acmerblog.com/category/basis/sort" rel="category tag" title="查看排序中的全部文章">排序</a>, <a href="http://www.acmerblog.com/category/basis/enumeration" rel="category tag" title="查看枚举中的全部文章">枚举</a>, <a href="http://www.acmerblog.com/category/geometry/analytic-geometry" rel="category tag" title="查看解析几何中的全部文章">解析几何</a></span><span class="i4">围观1081次</span><span class="i3"><a class="ds-thread-count" data-thread-key="2606" href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comments" title="《HDU 1661 Amphiphilic Carbon Molecules -计算几何-[解题报告] C++》上的评论">14 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">Amphiphilic Carbon Molecules </h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
Shanghai Hypercomputers, the world’s largest computer chip manufacturer, has invented a new class of nanoparticles called Amphiphilic Carbon Molecules (ACMs). ACMs are semiconductors. It means that they can be either conductors or insulators of electrons, and thus possess a property that is very important for the computer chip industry. They are also amphiphilic molecules, which means parts of them are hydrophilic while other parts of them are hydrophobic. Hydrophilic ACMs are soluble in polar solvents (for example, water) but are insoluble in nonpolar solvents (for example, acetone). Hydrophobic ACMs, on the contrary, are soluble in acetone but insoluble in water. Semiconductor ACMs dissolved in either water or acetone can be used in the computer chip manufacturing process. 
<p>As a materials engineer at Shanghai Hypercomputers, your job is to prepare ACM solutions from ACM particles. You go to your factory everyday at 8 am and find a batch of ACM particles on your workbench. You prepare the ACM solutions by dripping some water, as well as some acetone, into those particles and watch the ACMs dissolve in the solvents. You always want to prepare unmixed solutions, so you first separate the ACM particles by placing an Insulating Carbon Partition Card (ICPC) perpendicular to your workbench. The ICPC is long enough to completely separate the particles. You then drip water on one side of the ICPC and acetone on the other side. The ICPC helps you obtain hydrophilic ACMs dissolved in water on one side and hydrophobic ACMs dissolved in acetone on the other side. If you happen to put the ICPC on top of some ACM particles, those ACMs will be right at the border between the water solution and the acetone solution, and they will be dissolved. Fig.1 shows your working situation. </p>
<p></p><center><img src="http://acm.hdu.edu.cn/data/images/1661-1.jpg"/></center>
<p>Your daily job is very easy and boring, so your supervisor makes it a little bit more challenging by asking you to dissolve as much ACMs into solution as possible. You know you have to be very careful about where to put the ICPC since hydrophilic ACMs on the acetone side, or hydrophobic ACMs on the water side, will not dissolve. As an experienced engineer, you also know that sometimes it can be very difficult to find the best position for the ICPC, so you decide to write a program to help you. You have asked your supervisor to buy a special digital camera and have it installed above your workbench, so that your program can obtain the exact positions and species (hydrophilic or hydrophobic) of each ACM particle in a 2D pictures taken by the camera. The ICPC you put on your workbench will appear as a line in the 2D pictures. </p>
<p></p><center><img src="http://acm.hdu.edu.cn/data/images/1661-2.jpg"/></center> </div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
There will be no more than 10 test cases. Each case starts with a line containing an integer N, which is the number of ACM particles in the test case. N lines then follow. Each line contains three integers x, y, r, where (x, y) is the position of the ACM particle in the 2D picture and r can be 0 or 1, standing for the hydrophilic or hydrophobic type ACM respectively. The absolute value of x, y will be no larger than 10000. You may assume that N is no more than 1000. N = 0 signifies the end of the input and need not be processed. Fig.2 shows the positions of ACM particles and the best ICPC position for the last test case in the sample input. </div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
For each test case, output a line containing a single integer, which is the maximum number of dissolved ACM particles.</div>
<div>
<p class="mytitle"> 样例输入:</p>
</div>
<pre class="mypanel iopanel">
3
0 0 0
0 1 0
2 2 1
4
0 0 0
0 4 0
4 0 0
1 2 1
7
-1 0 0
1 2 1
2 3 0
2 1 1
0 3 1
1 4 0
-1 2 0
0</pre>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
3
3
6</pre>
<p> <!-- problem end --></p>
<p><span style="white-space:pre"></span>从TLE的暴力枚举 到 13313MS的扫描线  再到 1297MS的简化后的扫描线，简直感觉要爽翻啦。然后满怀欣喜的去HDU交了一下，直接又回到了TLE…..泪流满面</p>
<p><span style="white-space:pre"></span>虽说HDU的时限是2000MS 可是数据也忒强了点吧，真心给HDU跪了。</p>
<p><span style="white-space:pre"></span>题意：给定平面上的N个点，属性分别标记为0和1，然后找一条直线，直线上的点全部溶解，一侧的1溶解，另一侧的0溶解。求出最多能溶解的点的个数。</p>
<p><span style="white-space:pre"></span>思路：最直接的思路就是O(N^3)的暴力枚举，Discuss里面貌似有大牛过了，肯能是我太过暴力了吧，果断Tle了，然后换成了枚举单个点，然后极角排序+扫描线，</p>
<p><span style="white-space:pre"></span>跑了13313MS。然后优化了一下跑了1297MS。下面说一下扫描线的思路。</p>
<p>
</p>
<p> <img alt="" height="300" src="http://img.blog.csdn.net/20131114144600015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvem14MzU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="300"/></p>
<p><span style="white-space:pre"></span></p>
<p>首先，确定射线v1，v2与X轴正方向的角度，一个为0，一个为PI，然后同时旋转，每碰到一个点就计算一次v1，v2之间的及在两条射线上的点。</p>
<p>直到v1与X轴的方向 &gt;= PI ,当前这一次计算结束，继续枚举下一个点。</p>
<p>这就是13313MS那份代码的思路，显然扫描线是没错的，但是有一些点被重复计算了，其实我们只需要计算α角区域内的点的个数，通过它来维</p>
<p>护v1，v2区域内的点的个数，优化后用时就减少到了1297MS，但是在HDU依然过不了……</p>
<p>
</p>
<p>
</p>
<p>POJ AC_Code 1297MS</p>
<pre class="brush:cpp ">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

#define LL long long
#define EPS (1e-8)

using namespace std;

const double PI = acos(-1.0);

struct P
{
    double a;
    int x,y,mark;
} pa[1010],p[1010];

double Cal_Angle(P p1,P p2)
{
    if(p1.x == p2.x &amp;&amp; p1.y == p2.y)
        return -100.0;
    P v;
    v.x = p2.x - p1.x;
    v.y = p2.y - p1.y;
    if(p1.y &lt;= p2.y)
        return acos(v.x/sqrt(v.x*v.x + v.y*v.y));
    return 2.0*PI - acos(v.x/sqrt(v.x*v.x + v.y*v.y));
}

void Cal_Angle(P p,P *pa,int n)
{
    for(int i = 0; i &lt; n; ++i)
    {
        pa[i].a = Cal_Angle(p,pa[i]);
    }
}

bool cmp_angle(P p1,P p2)
{
    return p1.a &lt; p2.a;
}

int main()
{
    int n,i,j,k,l,d;
    int Max,tl,tr,b,w,s1,s0,s2,s3;
    double xm,pil,pir;
    P vec;
    while(scanf("%d",&amp;n) &amp;&amp; n)
    {
        b = 0;
        w = 0;
        for(i = 0; i &lt; n; ++i)
        {
            scanf("%d %d %d",&amp;p[i].x,&amp;p[i].y,&amp;p[i].mark);
            pa[i] = p[i];
            if(pa[i].mark)
                b++;
            else
                w++;
        }

        Max = -1;

        for(i = 0; i &lt; n; ++i)
        {
            Cal_Angle(p[i],pa,n);
            sort(pa,pa+n,cmp_angle);

            pir = pa[1].a;
            pil = pir + PI;

            s1 = s0 = s2 = s3 = 0;

            for(j = 1; j &lt; n &amp;&amp; pa[j].a &lt; pil; ++j)
            {
                if(pa[j].a == pir)
                {
                    if(pa[j].mark)
                        s3++;
                    else
                        s2++;
                }
                else
                {
                    if(pa[j].mark)
                        s1++;
                    else
                        s0++;
                }
            }

            for(d = j; d &lt; n &amp;&amp; pa[d].a == pil; ++d)
            {
                if(pa[d].mark)
                    s3++;
                else
                    s2++;
            }

            if(pa[0].mark)
                s3++;
            else
                s2++;

            tr = s0 + (b-s1)+s2;
            tl = s1 + (w-s0)+s3;
            
            if(tr &gt; Max || tl &gt; Max)
            Max = tr &gt; tl ? tr : tl;

            k = 1;

            while(pir &lt; PI &amp;&amp; j &lt; n)
            {
                for(; k &lt; n &amp;&amp; pir == pa[k].a; ++k)
                {
                    if(pa[k].mark)
                        --s3;
                    else
                        --s2;
                }
                pir = pa[k].a;
                if(pir &gt; PI)
                    break;
                for(l = k; l &lt; n &amp;&amp; pir == pa[l].a; ++l)
                {
                    if(pa[l].mark)
                    {
                        ++s3;
                        --s1;
                    }
                    else
                    {
                        ++s2;
                        --s0;
                    }
                }
                for(; j &lt; n &amp;&amp; pa[j].a == pil; ++j)
                {
                    if(pa[j].mark)
                    {
                        --s3;
                        ++s1;
                    }
                    else
                    {
                        --s2;
                        ++s0;
                    }
                }

                pil = pir+PI;

                for(; j &lt; n &amp;&amp; pa[j].a &lt; pil; ++j)
                {
                    if(pa[j].mark)
                    {
                        ++s1;
                    }
                    else
                    {
                        ++s0;
                    }
                }

                for(d = j; d &lt; n &amp;&amp; pa[d].a == pil ; ++d)
                {
                    if(pa[d].mark)
                        ++s3;
                    else
                        ++s2;
                }
                tr = s0 + (b-s1)+s2;
                tl = s1 + (w-s0)+s3;
                if(tr &gt; Max || tl &gt; Max)
                {
                    Max = tr &gt; tl ? tr : tl;
                }
            }
        }
        printf("%d\n",Max);
    }
    return 0 ;
}</pre>
<p>
</p>
<p>POJ AC_Code 13313MS </p>
<p><span style="white-space:pre"></span>
</p><pre class="brush:cpp ">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

#define LL long long
#define EPS (1e-8)

using namespace std;

const double PI = acos(-1);

struct P
{
    double x,y,a;
    int mark;
}pa[1010],p[1010];

double Cal_Angle(P p1,P p2)
{
    if(p1.x == p2.x &amp;&amp; p1.y == p2.y)
        return -100.0;
    P v;
    v.x = p2.x - p1.x;
    v.y = p2.y - p1.y;
    if(p1.y &lt;= p2.y)
        return acos(v.x/sqrt(v.x*v.x + v.y*v.y));
    return 2.0*PI - acos(v.x/sqrt(v.x*v.x + v.y*v.y));
}

void Cal_Angle(P p,P *pa,int n)
{
    for(int i = 0;i &lt; n; ++i)
    {
        pa[i].a = Cal_Angle(p,pa[i]);
    }
}

bool cmp_angle(P p1,P p2)
{
    return p1.a &lt; p2.a;
}

int main()
{
    int n,i,j,k;
    int tm1,tm0,tm2,tm3,Max,t1,t2,b,w;
    double xm,pil,pir;
    P vec;
    while(scanf("%d",&amp;n) &amp;&amp; n)
    {
        b = 0;
        w = 0;
        for(i = 0;i &lt; n; ++i)
        {
            scanf("%lf %lf %d",&amp;p[i].x,&amp;p[i].y,&amp;p[i].mark);
            pa[i] = p[i];
            if(pa[i].mark)
                b++;
            else
                w++;
        }

        Max = -1;

        for(i = 0;i &lt; n; ++i)
        {
            Cal_Angle(p[i],pa,n);
            sort(pa,pa+n,cmp_angle);
            pir = pa[0].a;
            j = 1;
            while(pir &lt;= PI &amp;&amp; j &lt; n)
            {
                for(;j &lt; n &amp;&amp; pa[j].a == pir; ++j)
                ;
                pir = pa[j].a;

                tm3 = 0;
                tm2 = 0;
                tm1 = 0;
                tm0 = 0;

                for(pil = pir+PI,k = j;pa[k].a &lt; pil &amp;&amp; k &lt; n; ++k)
                {
                    if(pa[j].a == pa[k].a)
                    {
                        if(pa[k].mark == 1)
                        {
                            tm3 ++;
                        }
                        else
                        {
                            tm2 ++;
                        }
                    }
                    else if(pa[k].mark == 0)
                    {
                        tm0++;
                    }
                    else
                    {
                        tm1++;
                    }
                }
                if(pa[0].mark)
                    tm3++;
                else
                    tm2++;
                t1 = tm1+tm2+tm3 + (w-tm0-tm2);
                t2 = tm0+tm2+tm3 + (b-tm1-tm3);
                if(Max &lt; t1 || Max &lt; t2)
                {
                    Max = t1 &gt; t2 ? t1 : t2;
                }
            }
        }
        printf("%d\n",Max);
    }
    return 0 ;
}</pre>
<p></p>
<p>解题报告转自：http://blog.csdn.net/zmx354/article/details/15810263</p>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-42524">
<article class="comment" id="comment-42524">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">TimeFight</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42524" rel="nofollow"><time datetime="2015-05-08T06:18:27+00:00" pubdate="">2015年5月8日 at 上午6:18</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>嗯   分析得很到位，确实用模板编程能让面试官对你的印象更好。在设置辅助栈的时候可以这样：push时，比较要push的elem和辅助栈的栈顶，elem&lt;=min.top()，则min.push(elem).否则只要push（elem）就好。在pop的时候，比较stack.top()与min.top(),if(stack.top()&lt;=min.top()),则{stack.pop();min.pop();}，否则{stack.pop();}.</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-55550">
<article class="comment" id="comment-55550">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">sheyty</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-55550" rel="nofollow"><time datetime="2014-12-08T03:26:15+00:00" pubdate="">2014年12月8日 at 上午3:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>程序输出是对的，呈三角型。原程序是按C++写的，已经改成了C的</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-16452">
<article class="comment" id="comment-16452">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Yaunxi</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-16452" rel="nofollow"><time datetime="2014-11-16T22:05:09+00:00" pubdate="">2014年11月16日 at 下午10:05</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不错的代码！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-55549">
<article class="comment" id="comment-55549">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">gaotong2055</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-55549" rel="nofollow"><time datetime="2014-11-08T19:56:36+00:00" pubdate="">2014年11月8日 at 下午7:56</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>Dijkstra 不适合有负权值的边吧</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-42525">
<article class="comment" id="comment-42525">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">mechine</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42525" rel="nofollow"><time datetime="2014-11-06T01:37:33+00:00" pubdate="">2014年11月6日 at 上午1:37</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>在方法1里面：</p>
<p>    //遍历所有的边，计算入度<br/>
    for(int i=0; i&lt;V; i++)<br/>
  {<br/>
        degree <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/>  = 0;<br/>
        for (j = adj <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> .begin(); j != adj <img src="http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/e6/weiboi_org.gif"/> .end(); ++j)<br/>
       {<br/>
            degree[*j]++;<br/>
        }<br/>
    }</p>
<p>为什么每遍历一条链表，要首先将每个链表头的顶点的入度置为0呢？<br/>
比如顶点5，若在顶点1、2、3、4的链表中出现过顶点5，那么要增加顶点5的入度，但是在遍历顶点5的链表时，又将顶点5的入度置为0了，那之前的从顶点1234到顶点5的边不是都没了吗？</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-42522">
<article class="comment" id="comment-42522">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">HDC</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42522" rel="nofollow"><time datetime="2014-09-17T12:59:54+00:00" pubdate="">2014年9月17日 at 下午12:59</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>Often We don’t set up on weblogs, but I would like to condition that this established up really forced me individually to do this! considerably outstanding publish</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-42518">
<article class="comment" id="comment-42518">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">pascal</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42518" rel="nofollow"><time datetime="2014-08-13T23:35:45+00:00" pubdate="">2014年8月13日 at 下午11:35</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的模板</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-61939">
<article class="comment" id="comment-61939">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">jinxiang23</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-61939" rel="nofollow"><time datetime="2014-07-28T01:20:13+00:00" pubdate="">2014年7月28日 at 上午1:20</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的思路，可以借鉴</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-42521">
<article class="comment" id="comment-42521">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">asdass</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42521" rel="nofollow"><time datetime="2014-06-10T03:12:45+00:00" pubdate="">2014年6月10日 at 上午3:12</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>可以根据二叉排序树的定义进行严格的排序树创建和后序遍历操作。如果形成的排序树相同，其树的前、中、后序遍历是相同的，但在此处不能使用中序遍历，因为，中序遍历的结果就是排序的结果。经在九度测试，运行时间90ms，比楼主的要快。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-42526">
<article class="comment" id="comment-42526">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">gaoriqiang</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42526" rel="nofollow"><time datetime="2014-06-08T02:38:08+00:00" pubdate="">2014年6月8日 at 上午2:38</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>可以用公式。主要为了说明动态规划，如果要打表的话，这种方法也是较简单和高效的</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-42523">
<article class="comment" id="comment-42523">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">2013283119</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42523" rel="nofollow"><time datetime="2014-05-22T21:32:01+00:00" pubdate="">2014年5月22日 at 下午9:32</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>不错的网站，建议添加些比赛信息</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-42519">
<article class="comment" id="comment-42519">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">woweizhineng</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42519" rel="nofollow"><time datetime="2014-04-28T23:54:20+00:00" pubdate="">2014年4月28日 at 下午11:54</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>好厉害～</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-42520">
<article class="comment" id="comment-42520">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">Miracle-cc</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-42520" rel="nofollow"><time datetime="2014-01-09T17:58:02+00:00" pubdate="">2014年1月9日 at 下午5:58</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>很好的思路，可以借鉴</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-16453">
<article class="comment" id="comment-16453">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">zcmu_sls</a></span> on <a href="http://www.acmerblog.com/hdu-1661-Amphiphilic-Carbon-Molecules-2606.html#comment-16453" rel="nofollow"><time datetime="2014-01-04T18:10:39+00:00" pubdate="">2014年1月4日 at 下午6:10</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>感觉第二种方法其实也不是很好，不过的确要比第一种方法要好一点。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>