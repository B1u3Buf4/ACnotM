<div class="c-top2" id="post-55">
<div class="datetime">2015<br/>04-14</div>
<div class="tit"><h1 class="entry-title">HDU 3961-Crisis[解题报告]HOJ</h1>
<div class="entry-meta iititle2">
<span class="i2"><a href="http://www.acmerblog.com/author/spiderman" rel="author" title="由蜘蛛侠发布">蜘蛛侠</a></span><span class="i1"><a href="http://www.acmerblog.com/category/problemset/hdu" rel="category tag" title="查看HDU-杭电中的全部文章">HDU-杭电</a></span><span class="i4">围观217次</span><span class="i3"><a class="ds-thread-count" data-thread-key="6964" href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comments" title="《HDU 3961-Crisis[解题报告]HOJ》上的评论">14 条评论</a></span>
</div>
</div>
<div class="cls"></div>
</div><div class="entry-content">
<div>
<h1 class="mytitle mybigtile">Crisis</h1>
</div>
<div>
<p class="mytitle"> 问题描述 :</p>
</div>
<div class="mypanel">
Warning! Warning! The new round of sunspot radiation is now coming and that put the life of all creatures on the earth in great danger. In order to protect our mother earth, the Association of Cosmos Monitoring(ACM) has decided to build a huge barrier floating in the sky to block the radiation. Since the earth is extremely large and the barrier may not be able to cover the whole planet, the ACM wants to know how many areas will still be under the radiation so that they could evacuate the people in those areas. <br/><center><img alt="Board Game Dice" src="http://www.acmerblog.com/img/1436213176774.jpg"/></center> <br/>To simplify the problem, you may assume the earth, the barrier and the sun are in the same 2D plane. The sun is considered as a point radiation source. The barrier is a simple polygon which has N endpoints and the earth is a circle. As we all know, to keep a huge barrier on the sky against the gravity, the barrier has to do uniform circular motion surround the earth. Also the barrier itself rotates surround its gravity center at a certain speed. <br/><center><img alt="Board Game Dice" src="http://www.acmerblog.com/img/1436213176888.jpg"/></center> <br/>You need pay attention to the next points:
<p>The revolution and rotation are both anticlockwise.</p>
<p>There is always a line dividing the plane into two half-plane, making the barrier in one, and the earth in the other.</p>
<p>The sun is exactly out of the barrier and the earth at any time.</p>
<p>The revolution is translational motion.</p>
<p>To calculate the movement of the huge barrier is very difficult, so the ACM needs you to write a program to calculate this problem and heal the world. Given the current location of the sun, the earth and the barrier, the periods of the barrier traveling around the earth and its rotation, and the time when the radiation outbreak from now, the ACM wants you to tell them the arc length of the areas which are under radiation. </p></div>
<div>
<p class="mytitle"> 输入:</p>
</div>
<div class="mypanel">
Input contains several test cases (≤1000). The first line of each case contains 5 integer numbers Xs, Ys, Xe, Ye, Re. (Xs, Ys) is the coordinate of the sun (-10000 ≤ x, y, r ≤ 10000, similarly hereinafter), (Xe, Ye) is the coordinate of the earth’s core, Re indicate the radius of the earth.
<p>The second line of the input contains 4 integer numbers N (≤100), T1, T2, T. N indicate the number of the barrier’s endpoints, T1 is the barrier’s period of revolution, T2 is the barrier’s rotation period, T is the time when the radiation outbreak from now. The next N lines, each line consists of two integers xi and yi indicate the coordinate of the i-th endpoint of the barrier, and the endpoints will be given by the clockwise or anticlockwise order. </p></div>
<div>
<p class="mytitle"> 输出:</p>
</div>
<div class="mypanel">
Input contains several test cases (≤1000). The first line of each case contains 5 integer numbers Xs, Ys, Xe, Ye, Re. (Xs, Ys) is the coordinate of the sun (-10000 ≤ x, y, r ≤ 10000, similarly hereinafter), (Xe, Ye) is the coordinate of the earth’s core, Re indicate the radius of the earth.
<p>The second line of the input contains 4 integer numbers N (≤100), T1, T2, T. N indicate the number of the barrier’s endpoints, T1 is the barrier’s period of revolution, T2 is the barrier’s rotation period, T is the time when the radiation outbreak from now. The next N lines, each line consists of two integers xi and yi indicate the coordinate of the i-th endpoint of the barrier, and the endpoints will be given by the clockwise or anticlockwise order.</p></div>
<div>
<p class="mytitle"> 样例输入:</p>
</div>
<pre class="mypanel iopanel">
-11 -6 9 7 9
7 100 120 0
-5 -3
-3 -4
-1 -3
-1 -2
-2 -1
-3 0
-4 -1
-11 -6 9 7 9
7 100 120 95
-5 -3
-3 -4
-1 -3
-1 -2
-2 -1
-3 0
-4 -1</pre>
<div>
<p class="mytitle"> 样例输出:</p>
</div>
<pre class="mypanel iopanel">
13.93
13.45</pre>
<p> <!-- problem end --></p>
<pre class="brush:cpp ">/** Micro Mezzo Macro Flation -- Overheated Economy ., Last Update: Dec. 20th 2012 **/ //{

/** Header .. **/ //{
#define LOCAL

#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;numeric&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;map&gt;

using namespace std;

#define REP(i, n) for (int i=0;i&lt;int(n);++i)
#define FOR(i, a, b) for (int i=int(a);i&lt;int(b);++i)
#define DWN(i, b, a) for (int i=int(b-1);i&gt;=int(a);--i)
#define REP_1(i, n) for (int i=1;i&lt;=int(n);++i)
#define FOR_1(i, a, b) for (int i=int(a);i&lt;=int(b);++i)
#define DWN_1(i, b, a) for (int i=int(b);i&gt;=int(a);--i)
#define REP_C(i, n) for (int n____=int(n),i=0;i&lt;n____;++i)
#define FOR_C(i, a, b) for (int b____=int(b),i=a;i&lt;b____;++i)
#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i&gt;=a____;--i)
#define REP_N(i, n) for (i=0;i&lt;int(n);++i)
#define FOR_N(i, a, b) for (i=int(a);i&lt;int(b);++i)
#define DWN_N(i, b, a) for (i=int(b-1);i&gt;=int(a);--i)
#define REP_1_C(i, n) for (int n____=int(n),i=1;i&lt;=n____;++i)
#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i&lt;=b____;++i)
#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i&gt;=a____;--i)
#define REP_1_N(i, n) for (i=1;i&lt;=int(n);++i)
#define FOR_1_N(i, a, b) for (i=int(a);i&lt;=int(b);++i)
#define DWN_1_N(i, b, a) for (i=int(b);i&gt;=int(a);--i)
#define REP_C_N(i, n) for (int n____=(i=0,int(n));i&lt;n____;++i)
#define FOR_C_N(i, a, b) for (int b____=(i=0,int(b);i&lt;b____;++i)
#define DWN_C_N(i, b, a) for (int a____=(i=b-1,int(a));i&gt;=a____;--i)
#define REP_1_C_N(i, n) for (int n____=(i=1,int(n));i&lt;=n____;++i)
#define FOR_1_C_N(i, a, b) for (int b____=(i=1,int(b);i&lt;=b____;++i)
#define DWN_1_C_N(i, b, a) for (int a____=(i=b,int(a));i&gt;=a____;--i)

#define ECH(it, A) for (__typeof(A.begin()) it=A.begin(); it != A.end(); ++it)
#define REP_S(i, str) for (char*i=str;*i;++i)
#define REP_L(i, hd, nxt) for (int i=hd;i;i=nxt[i])
#define REP_G(i, u) REP_L(i,hd[u],suc)
#define DO(n) for ( int ____n ## __line__ = n; ____n ## __line__ -- ; )
#define REP_2(i, j, n, m) REP(i, n) REP(j, m)
#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)
#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)
#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)

#define ALL(A) A.begin(), A.end()
#define LLA(A) A.rbegin(), A.rend()
#define CPY(A, B) memcpy(A, B, sizeof(A))
#define INS(A, P, B) A.insert(A.begin() + P, B)
#define ERS(A, P) A.erase(A.begin() + P)
#define BSC(A, x) (lower_bound(ALL(A), x) - A.begin())
#define CTN(T, x) (T.find(x) != T.end())
#define SZ(A) int(A.size())
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define PTT pair&lt;T, T&gt;
#define fi first
#define se second

#define Rush for(int ____T=RD(); ____T--;)

#define Display(A, n, m) { \
	REP(i, n){		 \
 REP(j, m) cout &lt;&lt; A[i][j] &lt;&lt; " "; \
 cout &lt;&lt; endl;				 \
	}						 \
}

#define Display_1(A, n, m) {				 \
	REP_1(i, n){		 \
 REP_1(j, m) cout &lt;&lt; A[i][j] &lt;&lt; " "; \
		cout &lt;&lt; endl;		 		\
	}						 \
}

#pragma comment(linker, "/STACK:36777216")
//#pragma GCC optimize ("O2")
#define Ruby system("ruby main.rb")
#define Haskell system("runghc main.hs")
#define Python system("python main.py")
#define Pascal system("fpc main.pas")

typedef long long LL;
//typedef long double DB;
typedef double DB;
typedef unsigned UINT;
typedef unsigned long long ULL;

typedef vector&lt;int&gt; VI;
typedef vector&lt;char&gt; VC;
typedef vector&lt;string&gt; VS;
typedef vector&lt;LL&gt; VL;
typedef vector&lt;DB&gt; VF;
typedef set&lt;int&gt; SI;
typedef set&lt;string&gt; SS;
typedef map&lt;int, int&gt; MII;
typedef map&lt;string, int&gt; MSI;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;LL, LL&gt; PLL;
typedef vector&lt;PII&gt; VII;
typedef vector&lt;VI&gt; VVI;
typedef vector&lt;VII&gt; VVII;

template&lt;class T&gt; inline T&amp; RD(T &amp;);
template&lt;class T&gt; inline void OT(const T &amp;);
inline LL RD(){LL x; return RD(x);}
inline DB&amp; RF(DB &amp;x){scanf("%lf", &amp;x); return x;}
inline DB RF(){DB x; return RF(x);}
inline char* RS(char *s);
inline char&amp; RC(char &amp;c);
inline char RC();
inline char&amp; RC(char &amp;c){scanf(" %c", &amp;c); return c;}
inline char RC(){char c; return RC(c);}
//inline char&amp; RC(char &amp;c){c = getchar(); return c;}
//inline char RC(){return getchar();}

template&lt;class T0, class T1&gt; inline T0&amp; RD(T0 &amp;x0, T1 &amp;x1){RD(x0), RD(x1); return x0;}
template&lt;class T0, class T1, class T2&gt; inline T0&amp; RD(T0 &amp;x0, T1 &amp;x1, T2 &amp;x2){RD(x0), RD(x1), RD(x2); return x0;}
template&lt;class T0, class T1, class T2, class T3&gt; inline T0&amp; RD(T0 &amp;x0, T1 &amp;x1, T2 &amp;x2, T3 &amp;x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}
template&lt;class T0, class T1, class T2, class T3, class T4&gt; inline T0&amp; RD(T0 &amp;x0, T1 &amp;x1, T2 &amp;x2, T3 &amp;x3, T4 &amp;x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5&gt; inline T0&amp; RD(T0 &amp;x0, T1 &amp;x1, T2 &amp;x2, T3 &amp;x3, T4 &amp;x4, T5 &amp;x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6&gt; inline T0&amp; RD(T0 &amp;x0, T1 &amp;x1, T2 &amp;x2, T3 &amp;x3, T4 &amp;x4, T5 &amp;x5, T6 &amp;x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}
template&lt;class T0, class T1&gt; inline void OT(const T0 &amp;x0, const T1 &amp;x1){OT(x0), OT(x1);}
template&lt;class T0, class T1, class T2&gt; inline void OT(const T0 &amp;x0, const T1 &amp;x1, const T2 &amp;x2){OT(x0), OT(x1), OT(x2);}
template&lt;class T0, class T1, class T2, class T3&gt; inline void OT(const T0 &amp;x0, const T1 &amp;x1, const T2 &amp;x2, const T3 &amp;x3){OT(x0), OT(x1), OT(x2), OT(x3);}
template&lt;class T0, class T1, class T2, class T3, class T4&gt; inline void OT(const T0 &amp;x0, const T1 &amp;x1, const T2 &amp;x2, const T3 &amp;x3, const T4 &amp;x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5&gt; inline void OT(const T0 &amp;x0, const T1 &amp;x1, const T2 &amp;x2, const T3 &amp;x3, const T4 &amp;x4, const T5 &amp;x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6&gt; inline void OT(const T0 &amp;x0, const T1 &amp;x1, const T2 &amp;x2, const T3 &amp;x3, const T4 &amp;x4, const T5 &amp;x5, const T6 &amp;x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}
inline char&amp; RC(char &amp;a, char &amp;b){RC(a), RC(b); return a;}
inline char&amp; RC(char &amp;a, char &amp;b, char &amp;c){RC(a), RC(b), RC(c); return a;}
inline char&amp; RC(char &amp;a, char &amp;b, char &amp;c, char &amp;d){RC(a), RC(b), RC(c), RC(d); return a;}
inline char&amp; RC(char &amp;a, char &amp;b, char &amp;c, char &amp;d, char &amp;e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}
inline char&amp; RC(char &amp;a, char &amp;b, char &amp;c, char &amp;d, char &amp;e, char &amp;f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}
inline char&amp; RC(char &amp;a, char &amp;b, char &amp;c, char &amp;d, char &amp;e, char &amp;f, char &amp;g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}
inline DB&amp; RF(DB &amp;a, DB &amp;b){RF(a), RF(b); return a;}
inline DB&amp; RF(DB &amp;a, DB &amp;b, DB &amp;c){RF(a), RF(b), RF(c); return a;}
inline DB&amp; RF(DB &amp;a, DB &amp;b, DB &amp;c, DB &amp;d){RF(a), RF(b), RF(c), RF(d); return a;}
inline DB&amp; RF(DB &amp;a, DB &amp;b, DB &amp;c, DB &amp;d, DB &amp;e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}
inline DB&amp; RF(DB &amp;a, DB &amp;b, DB &amp;c, DB &amp;d, DB &amp;e, DB &amp;f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}
inline DB&amp; RF(DB &amp;a, DB &amp;b, DB &amp;c, DB &amp;d, DB &amp;e, DB &amp;f, DB &amp;g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}
inline void RS(char *s1, char *s2){RS(s1), RS(s2);}
inline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}

template&lt;class T&gt; inline void RST(T &amp;A){memset(A, 0, sizeof(A));}
template&lt;class T0, class T1&gt; inline void RST(T0 &amp;A0, T1 &amp;A1){RST(A0), RST(A1);}
template&lt;class T0, class T1, class T2&gt; inline void RST(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2){RST(A0), RST(A1), RST(A2);}
template&lt;class T0, class T1, class T2, class T3&gt; inline void RST(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3){RST(A0), RST(A1), RST(A2), RST(A3);}
template&lt;class T0, class T1, class T2, class T3, class T4&gt; inline void RST(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5&gt; inline void RST(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6&gt; inline void RST(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5, T6 &amp;A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}
template&lt;class T&gt; inline void FLC(T &amp;A, int x){memset(A, x, sizeof(A));}
template&lt;class T0, class T1&gt; inline void FLC(T0 &amp;A0, T1 &amp;A1, int x){FLC(A0, x), FLC(A1, x);}
template&lt;class T0, class T1, class T2&gt; inline void FLC(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}
template&lt;class T0, class T1, class T2, class T3&gt; inline void FLC(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}
template&lt;class T0, class T1, class T2, class T3, class T4&gt; inline void FLC(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5&gt; inline void FLC(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6&gt; inline void FLC(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5, T6 &amp;A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}
template&lt;class T&gt; inline void CLR(priority_queue&lt;T, vector&lt;T&gt;, less&lt;T&gt; &gt; &amp;Q){while (!Q.empty()) Q.pop();}
template&lt;class T&gt; inline void CLR(priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt; &amp;Q){while (!Q.empty()) Q.pop();}
template&lt;class T&gt; inline void CLR(T &amp;A){A.clear();}
template&lt;class T0, class T1&gt; inline void CLR(T0 &amp;A0, T1 &amp;A1){CLR(A0), CLR(A1);}
template&lt;class T0, class T1, class T2&gt; inline void CLR(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2){CLR(A0), CLR(A1), CLR(A2);}
template&lt;class T0, class T1, class T2, class T3&gt; inline void CLR(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}
template&lt;class T0, class T1, class T2, class T3, class T4&gt; inline void CLR(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5&gt; inline void CLR(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}
template&lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6&gt; inline void CLR(T0 &amp;A0, T1 &amp;A1, T2 &amp;A2, T3 &amp;A3, T4 &amp;A4, T5 &amp;A5, T6 &amp;A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}
template&lt;class T&gt; inline void CLR(T &amp;A, int n){REP(i, n) CLR(A[i]);}

template&lt;class T&gt; inline T&amp; SRT(T &amp;A){sort(ALL(A)); return A;}
template&lt;class T, class C&gt; inline T&amp; SRT(T &amp;A, C B){sort(ALL(A), B); return A;}
template&lt;class T&gt; inline T&amp; UNQ(T &amp;A){A.resize(unique(ALL(SRT(A))) - A.begin());return A;}

//}

/** Constant List .. **/ //{

const int MOD = 1000000007;
//int MOD = 99990001;
const int INF = 0x3f3f3f3f;
const LL INFF = 1LL &lt;&lt; 60;
const DB EPS = 1e-9;
const DB OO = 1e15;
const DB PI = acos(-1.0); //M_PI;

const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

//}

/** Add On .. **/ //{
// &lt;&lt;= '0. Nichi Joo ., //{
template&lt;class T&gt; inline void checkMin(T &amp;a,const T b){if (b&lt;a) a=b;}
template&lt;class T&gt; inline void checkMax(T &amp;a,const T b){if (a&lt;b) a=b;}
template&lt;class T&gt; inline void checkMin(T &amp;a, T &amp;b, const T x){checkMin(a, x), checkMin(b, x);}
template&lt;class T&gt; inline void checkMax(T &amp;a, T &amp;b, const T x){checkMax(a, x), checkMax(b, x);}
template &lt;class T, class C&gt; inline void checkMin(T&amp; a, const T b, C c){if (c(b,a)) a = b;}
template &lt;class T, class C&gt; inline void checkMax(T&amp; a, const T b, C c){if (c(a,b)) a = b;}
template&lt;class T&gt; inline T min(T a, T b, T c){return min(min(a, b), c);}
template&lt;class T&gt; inline T max(T a, T b, T c){return max(max(a, b), c);}
template&lt;class T&gt; inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}
template&lt;class T&gt; inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}
template&lt;class T&gt; inline T sqr(T a){return a*a;}
template&lt;class T&gt; inline T cub(T a){return a*a*a;}
inline int Ceil(int x, int y){return (x - 1) / y + 1;}
//}
// &lt;&lt;= '1. Bitwise Operation ., //{
namespace BO{

inline bool _1(int x, int i){return bool(x&amp;1&lt;&lt;i);}
inline bool _1(LL x, int i){return bool(x&amp;1LL&lt;&lt;i);}
inline LL _1(int i){return 1LL&lt;&lt;i;}
inline LL _U(int i){return _1(i) - 1;};

inline int reverse_bits(int x){
 x = ((x &gt;&gt; 1) &amp; 0x55555555) | ((x &lt;&lt; 1) &amp; 0xaaaaaaaa);
 x = ((x &gt;&gt; 2) &amp; 0x33333333) | ((x &lt;&lt; 2) &amp; 0xcccccccc);
 x = ((x &gt;&gt; 4) &amp; 0x0f0f0f0f) | ((x &lt;&lt; 4) &amp; 0xf0f0f0f0);
 x = ((x &gt;&gt; 8) &amp; 0x00ff00ff) | ((x &lt;&lt; 8) &amp; 0xff00ff00);
 x = ((x &gt;&gt;16) &amp; 0x0000ffff) | ((x &lt;&lt;16) &amp; 0xffff0000);
 return x;
}

inline LL reverse_bits(LL x){
 x = ((x &gt;&gt; 1) &amp; 0x5555555555555555LL) | ((x &lt;&lt; 1) &amp; 0xaaaaaaaaaaaaaaaaLL);
 x = ((x &gt;&gt; 2) &amp; 0x3333333333333333LL) | ((x &lt;&lt; 2) &amp; 0xccccccccccccccccLL);
 x = ((x &gt;&gt; 4) &amp; 0x0f0f0f0f0f0f0f0fLL) | ((x &lt;&lt; 4) &amp; 0xf0f0f0f0f0f0f0f0LL);
 x = ((x &gt;&gt; 8) &amp; 0x00ff00ff00ff00ffLL) | ((x &lt;&lt; 8) &amp; 0xff00ff00ff00ff00LL);
 x = ((x &gt;&gt;16) &amp; 0x0000ffff0000ffffLL) | ((x &lt;&lt;16) &amp; 0xffff0000ffff0000LL);
 x = ((x &gt;&gt;32) &amp; 0x00000000ffffffffLL) | ((x &lt;&lt;32) &amp; 0xffffffff00000000LL);
 return x;
}

template&lt;class T&gt; inline bool odd(T x){return x&amp;1;}
template&lt;class T&gt; inline bool even(T x){return !odd(x);}
template&lt;class T&gt; inline T low_bit(T x) {return x &amp; -x;}
template&lt;class T&gt; inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}
template&lt;class T&gt; inline T cover_bit(T x){T p = 1; while (p &lt; x) p &lt;&lt;= 1;return p;}

inline int low_idx(int x){return __builtin_ffs(x);}
inline int low_idx(LL x){return __builtin_ffsll(x);}
inline int high_idx(int x){return low_idx(reverse_bits(x));}
inline int high_idx(LL x){return low_idx(reverse_bits(x));}
inline int clz(int x){return __builtin_clz(x);}
inline int clz(LL x){return __builtin_clzll(x);}
inline int ctz(int x){return __builtin_ctz(x);}
inline int ctz(LL x){return __builtin_ctzll(x);}
inline int parity(int x){return __builtin_parity(x);}
inline int parity(LL x){return __builtin_parityll(x);}
inline int lg2(int a){return 31 - clz(a);}
inline int lg2(LL a){return 63 - clz(a);}
inline int count_bits(int x){return __builtin_popcount(x);}
inline int count_bits(LL x){return __builtin_popcountll(x);}

} using namespace BO;//}
namespace SL{
 namespace KMP{

 void calc_pi(const char *P, int n, int *pi){
 for (int i = 1, j = pi[0] = -1; i &lt; n; ++i){
 while (j &gt;= 0 &amp;&amp; P[i] != P[j+1]) j = pi[j];
 if (P[i] == P[j+1]) ++j;
 pi[i] = j;
 }
 //REP(i, n) cout &lt;&lt; pi[i] &lt;&lt; " "; cout &lt;&lt; endl;
 }

 bool run(const char *T, int n, const char *P, int m, const int *pi){
 for (int i = 0, j = -1; i &lt; n; ++i){
 while (j &gt;= 0 &amp;&amp; T[i] != P[j+1]) j = pi[j];
 if (T[i] == P[j+1]) ++j;
 if (j == m - 1) return true;
 }
 return false;
 }

 } //using namespace KMP;

 namespace Z{
 void calc_z(const char *P, int n, int *z){

 z[0] = n;

 for (int i = 1, l = 0, r = 0; i &lt; n; ++i){
 if (i &gt; r){
 for(l = r = i; r &lt; n &amp;&amp; P[r] == P[r - l];) ++r;
 z[i] = r - l, --r;
 }
 else {
 if (z[i - l] &lt; r - i + 1) z[i] = z[i - l];
 else {
 for (l = i;r &lt; n &amp;&amp; P[r] == P[r - l];) ++r;
 z[i] = r - l, --r;
 }
 }
 }

 //REP(i, n) cout &lt;&lt; z[i] &lt;&lt; " "; cout &lt;&lt; endl;
 }

 int run(const char *T, int n, const char *P, int m, const int *z){

 int ex; REP_C_N(ex, min(n, m)) if (T[ex] != P[ex]) break;

 int res = ex == m;

 for (int i = 1, l = 0, r = 0; i &lt; n; ++i){
 if (i &gt; r){
 for (l = r = i; r &lt; n &amp;&amp; T[r] == P[r - l];) ++r;
 ex = r - l, --r;
 }
 else {
 if (z[i - l] &lt; r - i + 1) ex = z[i - l];
 else {
 for (l = i; r &lt; n &amp;&amp; T[r] == P[r - l];) ++r;
 ex = r - l, --r;
 }
 }
 if (ex == m) ++res;
 }

 return res;
 }
 } //using namespace Z;

 void Manacher(char s[], int n, int p[]){
 const int NN = 0;
 static char ss[NN*2+2]; int nn = 2*n+2;
 ss[0] = '$', ss[nn-1] = '#', ss[nn] = 0;
 REP(i, n) ss[i*2+1] ='#', ss[i*2+2] = s[i];
 int mx = 0, id = 0; FOR(i, 1, nn){
 p[i] = mx &gt; i ? min(p[2*id-i], mx - i) : 1;
 while (ss[i+p[i]] == ss[i-p[i]]) ++p[i];
 if (i + p[i] &gt; mx) mx = i + p[i], id = i;
 }
 }

} //using namespace SL;//}
// &lt;&lt;= '9. Comutational Geometry .,//{
namespace CG{

struct Po; struct Line; struct Seg;

inline int sgn(DB x){return x &lt; -EPS ? -1 : x &gt; EPS;}
inline int sgn(DB x, DB y){return sgn(x - y);}

struct Po{
 DB x, y; Po(DB _x=0, DB _y=0):x(_x), y(_y){}
 friend istream&amp; operator &gt;&gt;(istream&amp; in, Po &amp;p){return in &gt;&gt; p.x &gt;&gt; p.y;}
 friend ostream&amp; operator &lt;&lt;(ostream&amp; out, Po p){return out &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")";}
 bool operator ==(const Po&amp; r)const{return !sgn(x-r.x) &amp;&amp; !sgn(y-r.y);};
 bool operator !=(const Po&amp; r)const{return sgn(x-r.x) || sgn(y-r.y);}
 Po operator +(const Po&amp; r)const{return Po(x+r.x, y+r.y);}
 Po operator -(const Po&amp; r)const{return Po(x-r.x, y-r.y);}
 Po operator *(DB k)const{return Po(x*k,y*k);}
 Po operator /(DB k)const{return Po(x/k,y/k);}
 DB operator *(const Po&amp;) const;
 DB operator ^(const Po&amp;) const;

 bool operator &lt;(const Po &amp;r) const{return sgn(x,r.x)&lt;0||!sgn(x,r.x)&amp;&amp;sgn(y,r.y)&lt;0;}
 Po operator -()const{return Po(-x,-y);}
 Po&amp; operator +=(const Po &amp;r){x+=r.x,y+=r.y;return *this;}
 Po&amp; operator -=(const Po &amp;r){x-=r.x,y-=r.y;return *this;}
 Po&amp; operator *=(DB k){x*=k,y*=k;return*this;}
 Po&amp; operator /=(DB k){x/=k,y/=k;return*this;}

 DB length_sqr()const{return sqr(x)+sqr(y);}
 DB length()const{return sqrt(length_sqr());}
 Po unit()const{return *this/length();}
 bool dgt()const{return !sgn(x)&amp;&amp;!sgn(y);}
 DB atan()const{return atan2(y,x);}
 void input(){RF(x,y);}

 void rotate(DB alpha, const Po&amp; o = Po()){
 x -= o.x, y -= o.y;
 (*this) = Po(x * cos(alpha) - y * sin(alpha), y * cos(alpha) + x * sin(alpha)) + o;
 }

};

Po operator *(DB k, Po a){return a * k;}

struct Line{
 Po a, b;
 Line(DB x0=0, DB y0=0, DB x1=0, DB y1=0):a(Po(x0, y0)), b(Po(x1, y1)){}
 Line(const Po &amp;a, const Po &amp;b):a(a), b(b){}
 Line(const Line &amp;l):a(l.a), b(l.b){}

 friend ostream&amp; operator &lt;&lt;(ostream&amp; out, Line p){return out &lt;&lt; p.a &lt;&lt; "-" &lt;&lt; p.b;}
 Line operator +(Po x)const{return Line(a + x, b + x);}
 DB length()const{return (b-a).length();}
 bool dgt()const{return (b-a).dgt();}
 void input(){a.input(), b.input();}
 void getequation(DB, DB, DB) const;
};

struct Seg: Line{
};

#define innerProduct dot
#define scalarProduct dot
#define dotProduct dot
#define outerProduct det
#define crossProduct det

inline DB dot(const DB &amp;x1, const DB &amp;y1, const DB &amp;x2, const DB &amp;y2){return x1 * x2 + y1 * y2;}
inline DB dot(const Po &amp;a, const Po &amp;b){return dot(a.x, a.y, b.x, b.y);}
inline DB dot(const Po &amp;p0, const Po &amp;p1, const Po &amp;p2){return dot(p1 - p0, p2 - p0);}
inline DB dot(const Po &amp;o, const Line &amp;l){return dot(o, l.a, l.b);}
inline DB dot(const Line &amp;l, const Po &amp;o){return dot(o, l.a, l.b);}
inline DB dot(const Line &amp;l1, const Line &amp;l2){return dot(l1.b - l1.a, l2.b - l2.a);}

inline DB det(const DB &amp;x1, const DB &amp;y1, const DB &amp;x2, const DB &amp;y2){return x1 * y2 - x2 * y1;}
inline DB det(const Po &amp;a, const Po &amp;b){return det(a.x, a.y, b.x, b.y);}
inline DB det(const Po &amp;p0, const Po &amp;p1, const Po &amp;p2){return det(p1 - p0, p2 - p0);}
inline DB det(const Po &amp;o, const Line &amp;l){return det(o, l.a, l.b);}
inline DB det(const Line &amp;l, const Po &amp;o){return det(o, l.a, l.b);}
inline DB det(const Line &amp;l1, const Line &amp;l2){return det(l1.b - l1.a, l2.b - l2.a);}

DB Po::operator *(const Po &amp;r)const{return dot(*this, r);}
DB Po::operator ^(const Po &amp;r)const{return det(*this, r);}

void Line::getequation(DB A, DB B, DB C) const{
 A = a.y - b.y, B = b.x - a.x, C = det(a, b);
}

template&lt;class T1, class T2&gt; inline DB dist(const T1 &amp;x, const T2 &amp;y){return sqrt(dist_sqr(x, y));}
template&lt;class T1, class T2, class T3&gt; inline DB dist(const T1 &amp;x, const T2 &amp;y, const T3 &amp;z){return sqrt(dist_sqr(x, y, z));}
template&lt;class T1, class T2&gt; inline int dett(const T1 &amp;x, const T2 &amp;y){return sgn(det(x, y));}
template&lt;class T1, class T2&gt; inline int dott(const T1 &amp;x, const T2 &amp;y){return sgn(dot(x, y));}
template&lt;class T1, class T2, class T3&gt; inline int dett(const T1 &amp;x, const T2 &amp;y, const T3 &amp;z){return sgn(det(x, y, z));}
template&lt;class T1, class T2, class T3&gt; inline int dott(const T1 &amp;x, const T2 &amp;y, const T3 &amp;z){return sgn(dot(x, y, z));}
template&lt;class T1, class T2, class T3, class T4&gt; inline int dett(const T1 &amp;x, const T2 &amp;y, const T3 &amp;z, const T4 &amp;w){return sgn(det(x, y, z, w));}
template&lt;class T1, class T2, class T3, class T4&gt; inline int dott(const T1 &amp;x, const T2 &amp;y, const T3 &amp;z, const T4 &amp;w){return sgn(dot(x, y, z, w));}

inline DB dist_sqr(const DB &amp;x, const DB &amp;y){return sqr(x) + sqr(y);}
inline DB dist_sqr(const DB &amp;x, const DB &amp;y, const DB &amp;z){return sqr(x) + sqr(y) + sqr(z);}
inline DB dist_sqr(const Po &amp;a, const Po &amp;b){return sqr(a.x - b.x) + sqr(a.y - b.y);}
inline DB dist_sqr(const Po &amp;p, const Line &amp;l){Po v0 = l.b - l.a, v1 = p - l.a; return sqr(fabs(det(v0, v1))) / v0.length_sqr();}
inline DB dist_sqr(const Po &amp;p, const Seg &amp;l){
 Po v0 = l.b - l.a, v1 = p - l.a, v2 = p - l.b;
 if (sgn(dot(v0, v1)) * sgn(dot(v0, v2)) &lt;= 0) return dist_sqr(p, Line(l));
 else return min(v1.length_sqr(), v2.length_sqr());
}
inline DB dist_sqr(Line l, Po p){return dist_sqr(p, l);}
inline DB dist_sqr(Seg l, Po p){return dist_sqr(p, l);}
inline DB dist_sqr(Line l1, Line l2){
 if (sgn(det(l1, l2)) != 0) return 0;
 return dist_sqr(l1.a, l2);
}
inline DB dist_sqr(Line l1, Seg l2){
 Po v0 = l1.b - l1.a, v1 = l2.a - l1.a, v2 = l2.b - l1.a; DB c1 = det(v0, v1), c2 = det(v0, v2);
 return sgn(c1) != sgn(c2) ? 0 : sqr(min(fabs(c1), fabs(c2))) / v0.length_sqr();
}

bool isIntersect(Seg l1, Seg l2){

 if (l1.a == l2.a || l1.a == l2.b || l1.b == l2.a || l1.b == l2.b) return true;

 return
 min(l1.a.x, l1.b.x) &lt;= max(l2.a.x, l2.b.x) &amp;&amp;
 min(l2.a.x, l2.b.x) &lt;= max(l1.a.x, l1.b.x) &amp;&amp;
 min(l1.a.y, l1.b.y) &lt;= max(l2.a.y, l2.b.y) &amp;&amp;
 min(l2.a.y, l2.b.y) &lt;= max(l1.a.y, l1.b.y) &amp;&amp;
 sgn( det(l1.a, l2.a, l2.b) ) * sgn( det(l1.b, l2.a, l2.b) ) &lt;= 0 &amp;&amp;
 sgn( det(l2.a, l1.a, l1.b) ) * sgn( det(l2.b, l1.a, l1.b) ) &lt;= 0;

}

inline DB dist_sqr(Seg l1, Seg l2){
 if (isIntersect(l1, l2)) return 0;
 else return min(dist_sqr(l1.a, l2), dist_sqr(l1.b, l2), dist_sqr(l2.a, l1), dist_sqr(l2.b, l1));
}

inline bool isOnSide(const Po &amp;p, const Seg &amp;l){
 return p == l.a || p == l.b;
}

inline bool isOnSeg(const Po &amp;p, const Seg &amp;l){
 return sgn(det(p, l.a, l.b)) == 0 &amp;&amp;
 sgn(l.a.x, p.x) * sgn(l.b.x, p.x) &lt;= 0 &amp;&amp; sgn(l.a.y, p.y) * sgn(l.b.y, p.y) &lt;= 0;
}

inline bool isOnSegg(const Po &amp;p, const Seg &amp;l){
 return sgn(det(p, l.a, l.b)) == 0 &amp;&amp;
 sgn(l.a.x, p.x) * sgn(l.b.x, p.x) &lt; 0 &amp;&amp; sgn(l.a.y, p.y) * sgn(l.b.y, p.y) &lt; 0;
}

inline Po intersect(const Line &amp;l1, const Line &amp;l2){
 return l1.a + (l1.b - l1.a) * (det(l2.a, l1.a, l2.b) / det(l2, l1));
}

// perpendicular foot
inline Po intersect(const Po &amp; p, const Line &amp;l){
 return intersect(Line(p, p + Po(l.a.y - l.b.y, l.b.x - l.a.x)), l);
}

inline Po rotate(Po p, DB alpha, const Po&amp; o = Po()){
 p.x -= o.x, p.y -= o.y;
 return Po(p.x * cos(alpha) - p.y * sin(alpha), p.y * cos(alpha) + p.x * sin(alpha)) + o;
}

} using namespace CG;//}
//}

/** I/O Accelerator Interface .. **/ //{
template&lt;class T&gt; inline T&amp; RD(T &amp;x){
 //cin &gt;&gt; x;
 scanf("%d", &amp;x);
 //char c; for (c = getchar(); c &lt; '0'; c = getchar()); x = c - '0'; for (c = getchar(); '0' &lt;= c &amp;&amp; c &lt;= '9'; c = getchar()) x = x * 10 + c - '0';
 //char c; c = getchar(); x = c - '0'; for (c = getchar(); c &gt;= '0'; c = getchar()) x = x * 10 + c - '0';
 return x;
}

inline char* RS(char *s){
 //gets(s);
 scanf("%s", s);
 return s;
}

int Case; template&lt;class T&gt; inline void OT(const T &amp;x){
 //printf("Case %d: %d\n", ++Case, x);
 printf("%.2lf\n", x);
 //printf("%d\n", x);
 //cout &lt;&lt; x &lt;&lt; endl;
}
//}

//}/* .................................................................................................................................. */

const int N = 100009;
Po p[N], O, E, G;
int n; DB r;

DB get_alpha(const Po&amp; l1, const Po&amp; l2){
 //return acos(dot(l1, l2) / (l1.length() * l2.length()));
 return asin(det(l1, l2) / (l1.length() * l2.length()));
}

DB get_theta(double alpha, double r, double l){
 return asin(sin(alpha)/r*l) - alpha;
}

void init(){
 int t1, t2, t; RD(n, t1, t2, t); REP(i, n) p[i].input();
 E -= O; REP(i, n) p[i] -= O; O = Po();
 DB alpha = -E.atan(); REP(i, n) p[i].rotate(alpha);
 E.rotate(alpha); p[n] = p[0];

 // find the center of mass .. .
 DB mass = 0; G = Po(); REP(i, n){
 DB t = p[i] ^ p[i+1]; mass += t;
 G += (p[i] + p[i+1]) * t;
 }

 G /= 3 * mass;

 // rotateion &amp;&amp; revolution .. .
 DB revang=(t%t1)*(2*PI/t1), rotang=(t%t2)*(2*PI/t2);
 REP(i, n) p[i].rotate(rotang,G);
 Po offset = G; G.rotate(revang, E); offset = G - offset;
 REP(i, n) p[i] = p[i] + offset;
}

DB calc(){
 DB alpha = acos(r/E.x), ans = 2*r*alpha;
 if(sgn(dot(E,O,G)) &lt; 0) return ans;
 alpha = PI/2 - alpha;

 Po lp = p[0], rp = p[0]; FOR(i, 1, n){
 if(det(lp, p[i]) &lt; 0) lp = p[i];
 else if(det(rp, p[i]) &gt; 0) rp = p[i];
 }

 DB la = max(-alpha, get_alpha(E, lp)), ra = min(alpha, get_alpha(E, rp));
 if(ra &lt; la) return ans; // ?

 ans -= r * (get_theta(ra,r,E.x)-get_theta(la,r,E.x));
 return ans;
}

int main(){

#ifndef ONLINE_JUDGE
 freopen("in.txt", "r", stdin);
 //freopen("out.txt", "w", stdout);
#endif

 while(~scanf("%lf%lf%lf%lf%lf",&amp;O.x,&amp;O.y,&amp;E.x,&amp;E.y,&amp;r)){
 init(); OT(calc());
 }
}</pre>
<div>
</script>
<!-- acm-hf-01 -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9460629317209118" data-ad-slot="5011774182" style="display:inline-block;width:728px;height:90px"></ins>

(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div class="bdsharebuttonbox"><a class="bds_more" data-cmd="more" href="#"></a><a class="bds_qzone" data-cmd="qzone" href="#" title="分享到QQ空间"></a><a class="bds_tsina" data-cmd="tsina" href="#" title="分享到新浪微博"></a><a class="bds_tqq" data-cmd="tqq" href="#" title="分享到腾讯微博"></a><a class="bds_renren" data-cmd="renren" href="#" title="分享到人人网"></a><a class="bds_weixin" data-cmd="weixin" href="#" title="分享到微信"></a></div>

</div><ol id="commentlist">
<li class="comment even thread-even depth-1" id="li-comment-100060">
<article class="comment" id="comment-100060">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919525448" rel="external nofollow">新用户006245</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-100060" rel="nofollow"><time datetime="2017-04-20T21:02:06+00:00" pubdate="">2017年4月20日 at 下午9:02</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>这个毛子大叔不知道比爱狗人士高到哪儿去了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-71348">
<article class="comment" id="comment-71348">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://www.renren.com/profile.do?id=919517301" rel="external nofollow">新用户014930</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-71348" rel="nofollow"><time datetime="2017-04-11T15:16:35+00:00" pubdate="">2017年4月11日 at 下午3:16</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>更吧！更吧！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-51718">
<article class="comment" id="comment-51718">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">BGPY</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-51718" rel="nofollow"><time datetime="2015-07-08T06:30:54+00:00" pubdate="">2015年7月8日 at 上午6:30</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>多谢指出，已改正</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-35001">
<article class="comment" id="comment-35001">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">yelawolf</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-35001" rel="nofollow"><time datetime="2015-07-01T22:14:36+00:00" pubdate="">2015年7月1日 at 下午10:14</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>刚开始学习，为啥会报错了，你试过了吗</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-51716">
<article class="comment" id="comment-51716">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">MyHome</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-51716" rel="nofollow"><time datetime="2015-06-23T21:44:41+00:00" pubdate="">2015年6月23日 at 下午9:44</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>处凡愚而不减，在圣贤而不增；<br/>住烦恼而不乱，居禅定而不寂。</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-51717">
<article class="comment" id="comment-51717">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">0xc0de</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-51717" rel="nofollow"><time datetime="2015-06-14T18:14:47+00:00" pubdate="">2015年6月14日 at 下午6:14</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>有意思，有难度</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-35004">
<article class="comment" id="comment-35004">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">xun.gong</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-35004" rel="nofollow"><time datetime="2015-06-10T23:51:31+00:00" pubdate="">2015年6月10日 at 下午11:51</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>说的就是无向图啊，有向图的算法也是类似的</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-35000">
<article class="comment" id="comment-35000">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">huangduanjing</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-35000" rel="nofollow"><time datetime="2015-06-10T12:42:27+00:00" pubdate="">2015年6月10日 at 下午12:42</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>对于第一题，我的直觉告诉我换不换都一样，求指教</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-59931">
<article class="comment" id="comment-59931">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">ozhfo</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-59931" rel="nofollow"><time datetime="2015-05-31T12:45:30+00:00" pubdate="">2015年5月31日 at 下午12:45</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p><a href="http://www.realoj.com/problem/7如果楼主不介意，以可以在这个oj上做下，按照你的代码是错的。。。直接复制粘贴你的也是错。。不懂错在哪。" rel="nofollow">http://www.realoj.com/problem/7如果楼主不介意，以可以在这个oj上做下，按照你的代码是错的。。。直接复制粘贴你的也是错。。不懂错在哪。</a></p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-59929">
<article class="comment" id="comment-59929">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">hanyi</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-59929" rel="nofollow"><time datetime="2015-05-21T00:35:50+00:00" pubdate="">2015年5月21日 at 上午12:35</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>辛苦了，顶</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-59930">
<article class="comment" id="comment-59930">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">pascal</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-59930" rel="nofollow"><time datetime="2015-05-18T07:08:17+00:00" pubdate="">2015年5月18日 at 上午7:08</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>我没看懂题目<br/>
2<br/>
5 6 -1 5 4 -7<br/>
7 0 6 -1 1 -6 7 -5<br/>
我觉得第一个应该是5 6 -1 5 4 输出是19 5 4<br/>
第二个是7 0 6 -1 1 -6 7输出是14 7 7<br/>
不知道题目例子是怎么得出来的</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-35003">
<article class="comment" id="comment-35003">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">wall_</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-35003" rel="nofollow"><time datetime="2015-04-28T06:21:57+00:00" pubdate="">2015年4月28日 at 上午6:21</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>红绯鱼：<br/>
这模板神了</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment even thread-even depth-1" id="li-comment-64173">
<article class="comment" id="comment-64173">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">renke</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-64173" rel="nofollow"><time datetime="2015-04-20T18:46:31+00:00" pubdate="">2015年4月20日 at 下午6:46</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>多谢支持！</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-35002">
<article class="comment" id="comment-35002">
<footer class="comment-meta">
<cite class="comment-author vcard">
<span class="fn"><a class="url" href="http://fdsf" rel="external nofollow">jhxxszy</a></span> on <a href="http://www.acmerblog.com/hdu-3961-crisis-6964.html#comment-35002" rel="nofollow"><time datetime="2015-04-17T23:26:14+00:00" pubdate="">2015年4月17日 at 下午11:26</time></a> <span class="says">said:</span> </cite><!-- .comment-author .vcard -->
</footer>
<div class="comment-content"><p>学习了。找到这题</p>
</div>
</article><!-- #comment-## -->
</li><!-- #comment-## -->
</ol>